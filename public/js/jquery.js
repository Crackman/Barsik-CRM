/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/jquery.js":
/*!********************************!*\
  !*** ./resources/js/jquery.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n/*!\n * jQuery JavaScript Library v3.6.0\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2021-03-02T17:08Z\n */\n(function (global, factory) {\n  \"use strict\";\n\n  if (( false ? 0 : _typeof(module)) === \"object\" && _typeof(module.exports) === \"object\") {\n    // For CommonJS and CommonJS-like environments where a proper `window`\n    // is present, execute the factory and get jQuery.\n    // For environments that do not have a `window` with a `document`\n    // (such as Node.js), expose a factory as module.exports.\n    // This accentuates the need for the creation of a real `window`.\n    // e.g. var jQuery = require(\"jquery\")(window);\n    // See ticket #14549 for more info.\n    module.exports = global.document ? factory(global, true) : function (w) {\n      if (!w.document) {\n        throw new Error(\"jQuery requires a window with a document\");\n      }\n\n      return factory(w);\n    };\n  } else {\n    factory(global);\n  } // Pass this if window is not defined yet\n\n})(typeof window !== \"undefined\" ? window : this, function (window, noGlobal) {\n  // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n  // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n  // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n  // enough that all such attempts are guarded in a try block.\n  \"use strict\";\n\n  var arr = [];\n  var getProto = Object.getPrototypeOf;\n  var _slice = arr.slice;\n  var flat = arr.flat ? function (array) {\n    return arr.flat.call(array);\n  } : function (array) {\n    return arr.concat.apply([], array);\n  };\n  var push = arr.push;\n  var indexOf = arr.indexOf;\n  var class2type = {};\n  var toString = class2type.toString;\n  var hasOwn = class2type.hasOwnProperty;\n  var fnToString = hasOwn.toString;\n  var ObjectFunctionString = fnToString.call(Object);\n  var support = {};\n\n  var isFunction = function isFunction(obj) {\n    // Support: Chrome <=57, Firefox <=52\n    // In some browsers, typeof returns \"function\" for HTML <object> elements\n    // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n    // We don't want to classify *any* DOM node as a function.\n    // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5\n    // Plus for old WebKit, typeof returns \"function\" for HTML collections\n    // (e.g., `typeof document.getElementsByTagName(\"div\") === \"function\"`). (gh-4756)\n    return typeof obj === \"function\" && typeof obj.nodeType !== \"number\" && typeof obj.item !== \"function\";\n  };\n\n  var isWindow = function isWindow(obj) {\n    return obj != null && obj === obj.window;\n  };\n\n  var document = window.document;\n  var preservedScriptAttributes = {\n    type: true,\n    src: true,\n    nonce: true,\n    noModule: true\n  };\n\n  function DOMEval(code, node, doc) {\n    doc = doc || document;\n    var i,\n        val,\n        script = doc.createElement(\"script\");\n    script.text = code;\n\n    if (node) {\n      for (i in preservedScriptAttributes) {\n        // Support: Firefox 64+, Edge 18+\n        // Some browsers don't support the \"nonce\" property on scripts.\n        // On the other hand, just using `getAttribute` is not enough as\n        // the `nonce` attribute is reset to an empty string whenever it\n        // becomes browsing-context connected.\n        // See https://github.com/whatwg/html/issues/2369\n        // See https://html.spec.whatwg.org/#nonce-attributes\n        // The `node.getAttribute` check was added for the sake of\n        // `jQuery.globalEval` so that it can fake a nonce-containing node\n        // via an object.\n        val = node[i] || node.getAttribute && node.getAttribute(i);\n\n        if (val) {\n          script.setAttribute(i, val);\n        }\n      }\n    }\n\n    doc.head.appendChild(script).parentNode.removeChild(script);\n  }\n\n  function toType(obj) {\n    if (obj == null) {\n      return obj + \"\";\n    } // Support: Android <=2.3 only (functionish RegExp)\n\n\n    return _typeof(obj) === \"object\" || typeof obj === \"function\" ? class2type[toString.call(obj)] || \"object\" : _typeof(obj);\n  }\n  /* global Symbol */\n  // Defining this global in .eslintrc.json would create a danger of using the global\n  // unguarded in another place, it seems safer to define global only for this module\n\n\n  var version = \"3.6.0\",\n      // Define a local copy of jQuery\n  jQuery = function jQuery(selector, context) {\n    // The jQuery object is actually just the init constructor 'enhanced'\n    // Need init if jQuery is called (just allow error to be thrown if not included)\n    return new jQuery.fn.init(selector, context);\n  };\n\n  jQuery.fn = jQuery.prototype = {\n    // The current version of jQuery being used\n    jquery: version,\n    constructor: jQuery,\n    // The default length of a jQuery object is 0\n    length: 0,\n    toArray: function toArray() {\n      return _slice.call(this);\n    },\n    // Get the Nth element in the matched element set OR\n    // Get the whole matched element set as a clean array\n    get: function get(num) {\n      // Return all the elements in a clean array\n      if (num == null) {\n        return _slice.call(this);\n      } // Return just the one element from the set\n\n\n      return num < 0 ? this[num + this.length] : this[num];\n    },\n    // Take an array of elements and push it onto the stack\n    // (returning the new matched element set)\n    pushStack: function pushStack(elems) {\n      // Build a new jQuery matched element set\n      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)\n\n      ret.prevObject = this; // Return the newly-formed element set\n\n      return ret;\n    },\n    // Execute a callback for every element in the matched set.\n    each: function each(callback) {\n      return jQuery.each(this, callback);\n    },\n    map: function map(callback) {\n      return this.pushStack(jQuery.map(this, function (elem, i) {\n        return callback.call(elem, i, elem);\n      }));\n    },\n    slice: function slice() {\n      return this.pushStack(_slice.apply(this, arguments));\n    },\n    first: function first() {\n      return this.eq(0);\n    },\n    last: function last() {\n      return this.eq(-1);\n    },\n    even: function even() {\n      return this.pushStack(jQuery.grep(this, function (_elem, i) {\n        return (i + 1) % 2;\n      }));\n    },\n    odd: function odd() {\n      return this.pushStack(jQuery.grep(this, function (_elem, i) {\n        return i % 2;\n      }));\n    },\n    eq: function eq(i) {\n      var len = this.length,\n          j = +i + (i < 0 ? len : 0);\n      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);\n    },\n    end: function end() {\n      return this.prevObject || this.constructor();\n    },\n    // For internal use only.\n    // Behaves like an Array's method, not like a jQuery method.\n    push: push,\n    sort: arr.sort,\n    splice: arr.splice\n  };\n\n  jQuery.extend = jQuery.fn.extend = function () {\n    var options,\n        name,\n        src,\n        copy,\n        copyIsArray,\n        clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false; // Handle a deep copy situation\n\n    if (typeof target === \"boolean\") {\n      deep = target; // Skip the boolean and the target\n\n      target = arguments[i] || {};\n      i++;\n    } // Handle case when target is a string or something (possible in deep copy)\n\n\n    if (_typeof(target) !== \"object\" && !isFunction(target)) {\n      target = {};\n    } // Extend jQuery itself if only one argument is passed\n\n\n    if (i === length) {\n      target = this;\n      i--;\n    }\n\n    for (; i < length; i++) {\n      // Only deal with non-null/undefined values\n      if ((options = arguments[i]) != null) {\n        // Extend the base object\n        for (name in options) {\n          copy = options[name]; // Prevent Object.prototype pollution\n          // Prevent never-ending loop\n\n          if (name === \"__proto__\" || target === copy) {\n            continue;\n          } // Recurse if we're merging plain objects or arrays\n\n\n          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n            src = target[name]; // Ensure proper type for the source value\n\n            if (copyIsArray && !Array.isArray(src)) {\n              clone = [];\n            } else if (!copyIsArray && !jQuery.isPlainObject(src)) {\n              clone = {};\n            } else {\n              clone = src;\n            }\n\n            copyIsArray = false; // Never move original objects, clone them\n\n            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values\n          } else if (copy !== undefined) {\n            target[name] = copy;\n          }\n        }\n      }\n    } // Return the modified object\n\n\n    return target;\n  };\n\n  jQuery.extend({\n    // Unique for each copy of jQuery on the page\n    expando: \"jQuery\" + (version + Math.random()).replace(/\\D/g, \"\"),\n    // Assume jQuery is ready without the ready module\n    isReady: true,\n    error: function error(msg) {\n      throw new Error(msg);\n    },\n    noop: function noop() {},\n    isPlainObject: function isPlainObject(obj) {\n      var proto, Ctor; // Detect obvious negatives\n      // Use toString instead of jQuery.type to catch host objects\n\n      if (!obj || toString.call(obj) !== \"[object Object]\") {\n        return false;\n      }\n\n      proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain\n\n      if (!proto) {\n        return true;\n      } // Objects with prototype are plain iff they were constructed by a global Object function\n\n\n      Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\n      return typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString;\n    },\n    isEmptyObject: function isEmptyObject(obj) {\n      var name;\n\n      for (name in obj) {\n        return false;\n      }\n\n      return true;\n    },\n    // Evaluates a script in a provided context; falls back to the global one\n    // if not specified.\n    globalEval: function globalEval(code, options, doc) {\n      DOMEval(code, {\n        nonce: options && options.nonce\n      }, doc);\n    },\n    each: function each(obj, callback) {\n      var length,\n          i = 0;\n\n      if (isArrayLike(obj)) {\n        length = obj.length;\n\n        for (; i < length; i++) {\n          if (callback.call(obj[i], i, obj[i]) === false) {\n            break;\n          }\n        }\n      } else {\n        for (i in obj) {\n          if (callback.call(obj[i], i, obj[i]) === false) {\n            break;\n          }\n        }\n      }\n\n      return obj;\n    },\n    // results is for internal usage only\n    makeArray: function makeArray(arr, results) {\n      var ret = results || [];\n\n      if (arr != null) {\n        if (isArrayLike(Object(arr))) {\n          jQuery.merge(ret, typeof arr === \"string\" ? [arr] : arr);\n        } else {\n          push.call(ret, arr);\n        }\n      }\n\n      return ret;\n    },\n    inArray: function inArray(elem, arr, i) {\n      return arr == null ? -1 : indexOf.call(arr, elem, i);\n    },\n    // Support: Android <=4.0 only, PhantomJS 1 only\n    // push.apply(_, arraylike) throws on ancient WebKit\n    merge: function merge(first, second) {\n      var len = +second.length,\n          j = 0,\n          i = first.length;\n\n      for (; j < len; j++) {\n        first[i++] = second[j];\n      }\n\n      first.length = i;\n      return first;\n    },\n    grep: function grep(elems, callback, invert) {\n      var callbackInverse,\n          matches = [],\n          i = 0,\n          length = elems.length,\n          callbackExpect = !invert; // Go through the array, only saving the items\n      // that pass the validator function\n\n      for (; i < length; i++) {\n        callbackInverse = !callback(elems[i], i);\n\n        if (callbackInverse !== callbackExpect) {\n          matches.push(elems[i]);\n        }\n      }\n\n      return matches;\n    },\n    // arg is for internal usage only\n    map: function map(elems, callback, arg) {\n      var length,\n          value,\n          i = 0,\n          ret = []; // Go through the array, translating each of the items to their new values\n\n      if (isArrayLike(elems)) {\n        length = elems.length;\n\n        for (; i < length; i++) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret.push(value);\n          }\n        } // Go through every key on the object,\n\n      } else {\n        for (i in elems) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret.push(value);\n          }\n        }\n      } // Flatten any nested arrays\n\n\n      return flat(ret);\n    },\n    // A global GUID counter for objects\n    guid: 1,\n    // jQuery.support is not used in Core but other projects attach their\n    // properties to it so it needs to exist.\n    support: support\n  });\n\n  if (typeof Symbol === \"function\") {\n    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];\n  } // Populate the class2type map\n\n\n  jQuery.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function (_i, name) {\n    class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n  });\n\n  function isArrayLike(obj) {\n    // Support: real iOS 8.2 only (not reproducible in simulator)\n    // `in` check used to prevent JIT error (gh-2145)\n    // hasOwn isn't used here due to false negatives\n    // regarding Nodelist length in IE\n    var length = !!obj && \"length\" in obj && obj.length,\n        type = toType(obj);\n\n    if (isFunction(obj) || isWindow(obj)) {\n      return false;\n    }\n\n    return type === \"array\" || length === 0 || typeof length === \"number\" && length > 0 && length - 1 in obj;\n  }\n\n  var Sizzle =\n  /*!\n  * Sizzle CSS Selector Engine v2.3.6\n  * https://sizzlejs.com/\n  *\n  * Copyright JS Foundation and other contributors\n  * Released under the MIT license\n  * https://js.foundation/\n  *\n  * Date: 2021-02-16\n  */\n  function (window) {\n    var i,\n        support,\n        Expr,\n        getText,\n        isXML,\n        tokenize,\n        compile,\n        select,\n        outermostContext,\n        sortInput,\n        hasDuplicate,\n        // Local document vars\n    setDocument,\n        document,\n        docElem,\n        documentIsHTML,\n        rbuggyQSA,\n        rbuggyMatches,\n        matches,\n        contains,\n        // Instance-specific data\n    expando = \"sizzle\" + 1 * new Date(),\n        preferredDoc = window.document,\n        dirruns = 0,\n        done = 0,\n        classCache = createCache(),\n        tokenCache = createCache(),\n        compilerCache = createCache(),\n        nonnativeSelectorCache = createCache(),\n        sortOrder = function sortOrder(a, b) {\n      if (a === b) {\n        hasDuplicate = true;\n      }\n\n      return 0;\n    },\n        // Instance methods\n    hasOwn = {}.hasOwnProperty,\n        arr = [],\n        pop = arr.pop,\n        pushNative = arr.push,\n        push = arr.push,\n        slice = arr.slice,\n        // Use a stripped-down indexOf as it's faster than native\n    // https://jsperf.com/thor-indexof-vs-for/5\n    indexOf = function indexOf(list, elem) {\n      var i = 0,\n          len = list.length;\n\n      for (; i < len; i++) {\n        if (list[i] === elem) {\n          return i;\n        }\n      }\n\n      return -1;\n    },\n        booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|\" + \"ismap|loop|multiple|open|readonly|required|scoped\",\n        // Regular expressions\n    // http://www.w3.org/TR/css3-selectors/#whitespace\n    whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n        // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n    identifier = \"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",\n        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n    attributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace + // Operator (capture 2)\n    \"*([*^$|!~]?=)\" + whitespace + // \"Attribute values must be CSS identifiers [capture 5]\n    // or strings [capture 3 or capture 4]\"\n    \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\",\n        pseudos = \":(\" + identifier + \")(?:\\\\((\" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n    // 1. quoted (capture 3; capture 4 or capture 5)\n    \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" + // 2. simple (capture 6)\n    \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" + // 3. anything else (capture 2)\n    \".*\" + \")\\\\)|)\",\n        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n    rwhitespace = new RegExp(whitespace + \"+\", \"g\"),\n        rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n        rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n        rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\n        rdescend = new RegExp(whitespace + \"|>\"),\n        rpseudo = new RegExp(pseudos),\n        ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n        matchExpr = {\n      \"ID\": new RegExp(\"^#(\" + identifier + \")\"),\n      \"CLASS\": new RegExp(\"^\\\\.(\" + identifier + \")\"),\n      \"TAG\": new RegExp(\"^(\" + identifier + \"|[*])\"),\n      \"ATTR\": new RegExp(\"^\" + attributes),\n      \"PSEUDO\": new RegExp(\"^\" + pseudos),\n      \"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n      \"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n      // For use in libraries implementing .is()\n      // We use this for POS matching in `select`\n      \"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n    },\n        rhtml = /HTML$/i,\n        rinputs = /^(?:input|select|textarea|button)$/i,\n        rheader = /^h\\d$/i,\n        rnative = /^[^{]+\\{\\s*\\[native \\w/,\n        // Easily-parseable/retrievable ID or TAG or CLASS selectors\n    rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n        rsibling = /[+~]/,\n        // CSS escapes\n    // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n    runescape = new RegExp(\"\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\", \"g\"),\n        funescape = function funescape(escape, nonHex) {\n      var high = \"0x\" + escape.slice(1) - 0x10000;\n      return nonHex ? // Strip the backslash prefix from a non-hex escape sequence\n      nonHex : // Replace a hexadecimal escape sequence with the encoded Unicode code point\n      // Support: IE <=11+\n      // For values outside the Basic Multilingual Plane (BMP), manually construct a\n      // surrogate pair\n      high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n    },\n        // CSS string/identifier serialization\n    // https://drafts.csswg.org/cssom/#common-serializing-idioms\n    rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n        fcssescape = function fcssescape(ch, asCodePoint) {\n      if (asCodePoint) {\n        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n        if (ch === \"\\0\") {\n          return \"\\uFFFD\";\n        } // Control characters and (dependent upon position) numbers get escaped as code points\n\n\n        return ch.slice(0, -1) + \"\\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + \" \";\n      } // Other potentially-special ASCII characters get backslash-escaped\n\n\n      return \"\\\\\" + ch;\n    },\n        // Used for iframes\n    // See setDocument()\n    // Removing the function wrapper causes a \"Permission Denied\"\n    // error in IE\n    unloadHandler = function unloadHandler() {\n      setDocument();\n    },\n        inDisabledFieldset = addCombinator(function (elem) {\n      return elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n    }, {\n      dir: \"parentNode\",\n      next: \"legend\"\n    }); // Optimize for push.apply( _, NodeList )\n\n\n    try {\n      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0\n      // Detect silently failing push.apply\n      // eslint-disable-next-line no-unused-expressions\n\n      arr[preferredDoc.childNodes.length].nodeType;\n    } catch (e) {\n      push = {\n        apply: arr.length ? // Leverage slice if possible\n        function (target, els) {\n          pushNative.apply(target, slice.call(els));\n        } : // Support: IE<9\n        // Otherwise append directly\n        function (target, els) {\n          var j = target.length,\n              i = 0; // Can't trust NodeList.length\n\n          while (target[j++] = els[i++]) {}\n\n          target.length = j - 1;\n        }\n      };\n    }\n\n    function Sizzle(selector, context, results, seed) {\n      var m,\n          i,\n          elem,\n          nid,\n          match,\n          groups,\n          newSelector,\n          newContext = context && context.ownerDocument,\n          // nodeType defaults to 9, since context defaults to document\n      nodeType = context ? context.nodeType : 9;\n      results = results || []; // Return early from calls with invalid selector or context\n\n      if (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n        return results;\n      } // Try to shortcut find operations (as opposed to filters) in HTML documents\n\n\n      if (!seed) {\n        setDocument(context);\n        context = context || document;\n\n        if (documentIsHTML) {\n          // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n          // (excepting DocumentFragment context, where the methods don't exist)\n          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n            // ID selector\n            if (m = match[1]) {\n              // Document context\n              if (nodeType === 9) {\n                if (elem = context.getElementById(m)) {\n                  // Support: IE, Opera, Webkit\n                  // TODO: identify versions\n                  // getElementById can match elements by name instead of ID\n                  if (elem.id === m) {\n                    results.push(elem);\n                    return results;\n                  }\n                } else {\n                  return results;\n                } // Element context\n\n              } else {\n                // Support: IE, Opera, Webkit\n                // TODO: identify versions\n                // getElementById can match elements by name instead of ID\n                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\n                  results.push(elem);\n                  return results;\n                }\n              } // Type selector\n\n            } else if (match[2]) {\n              push.apply(results, context.getElementsByTagName(selector));\n              return results; // Class selector\n            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n              push.apply(results, context.getElementsByClassName(m));\n              return results;\n            }\n          } // Take advantage of querySelectorAll\n\n\n          if (support.qsa && !nonnativeSelectorCache[selector + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && ( // Support: IE 8 only\n          // Exclude object elements\n          nodeType !== 1 || context.nodeName.toLowerCase() !== \"object\")) {\n            newSelector = selector;\n            newContext = context; // qSA considers elements outside a scoping root when evaluating child or\n            // descendant combinators, which is not what we want.\n            // In such cases, we work around the behavior by prefixing every selector in the\n            // list with an ID selector referencing the scope context.\n            // The technique has to be used as well when a leading combinator is used\n            // as such selectors are not recognized by querySelectorAll.\n            // Thanks to Andrew Dupont for this technique.\n\n            if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {\n              // Expand context for sibling selectors\n              newContext = rsibling.test(selector) && testContext(context.parentNode) || context; // We can use :scope instead of the ID hack if the browser\n              // supports it & if we're not changing the context.\n\n              if (newContext !== context || !support.scope) {\n                // Capture the context ID, setting it first if necessary\n                if (nid = context.getAttribute(\"id\")) {\n                  nid = nid.replace(rcssescape, fcssescape);\n                } else {\n                  context.setAttribute(\"id\", nid = expando);\n                }\n              } // Prefix every selector in the list\n\n\n              groups = tokenize(selector);\n              i = groups.length;\n\n              while (i--) {\n                groups[i] = (nid ? \"#\" + nid : \":scope\") + \" \" + toSelector(groups[i]);\n              }\n\n              newSelector = groups.join(\",\");\n            }\n\n            try {\n              push.apply(results, newContext.querySelectorAll(newSelector));\n              return results;\n            } catch (qsaError) {\n              nonnativeSelectorCache(selector, true);\n            } finally {\n              if (nid === expando) {\n                context.removeAttribute(\"id\");\n              }\n            }\n          }\n        }\n      } // All others\n\n\n      return select(selector.replace(rtrim, \"$1\"), context, results, seed);\n    }\n    /**\n     * Create key-value caches of limited size\n     * @returns {function(string, object)} Returns the Object data after storing it on itself with\n     *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n     *\tdeleting the oldest entry\n     */\n\n\n    function createCache() {\n      var keys = [];\n\n      function cache(key, value) {\n        // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n        if (keys.push(key + \" \") > Expr.cacheLength) {\n          // Only keep the most recent entries\n          delete cache[keys.shift()];\n        }\n\n        return cache[key + \" \"] = value;\n      }\n\n      return cache;\n    }\n    /**\n     * Mark a function for special use by Sizzle\n     * @param {Function} fn The function to mark\n     */\n\n\n    function markFunction(fn) {\n      fn[expando] = true;\n      return fn;\n    }\n    /**\n     * Support testing using an element\n     * @param {Function} fn Passed the created element and returns a boolean result\n     */\n\n\n    function assert(fn) {\n      var el = document.createElement(\"fieldset\");\n\n      try {\n        return !!fn(el);\n      } catch (e) {\n        return false;\n      } finally {\n        // Remove from its parent by default\n        if (el.parentNode) {\n          el.parentNode.removeChild(el);\n        } // release memory in IE\n\n\n        el = null;\n      }\n    }\n    /**\n     * Adds the same handler for all of the specified attrs\n     * @param {String} attrs Pipe-separated list of attributes\n     * @param {Function} handler The method that will be applied\n     */\n\n\n    function addHandle(attrs, handler) {\n      var arr = attrs.split(\"|\"),\n          i = arr.length;\n\n      while (i--) {\n        Expr.attrHandle[arr[i]] = handler;\n      }\n    }\n    /**\n     * Checks document order of two siblings\n     * @param {Element} a\n     * @param {Element} b\n     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n     */\n\n\n    function siblingCheck(a, b) {\n      var cur = b && a,\n          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes\n\n      if (diff) {\n        return diff;\n      } // Check if b follows a\n\n\n      if (cur) {\n        while (cur = cur.nextSibling) {\n          if (cur === b) {\n            return -1;\n          }\n        }\n      }\n\n      return a ? 1 : -1;\n    }\n    /**\n     * Returns a function to use in pseudos for input types\n     * @param {String} type\n     */\n\n\n    function createInputPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return name === \"input\" && elem.type === type;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for buttons\n     * @param {String} type\n     */\n\n\n    function createButtonPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return (name === \"input\" || name === \"button\") && elem.type === type;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for :enabled/:disabled\n     * @param {Boolean} disabled true for :disabled; false for :enabled\n     */\n\n\n    function createDisabledPseudo(disabled) {\n      // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n      return function (elem) {\n        // Only certain elements can match :enabled or :disabled\n        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n        if (\"form\" in elem) {\n          // Check for inherited disabledness on relevant non-disabled elements:\n          // * listed form-associated elements in a disabled fieldset\n          //   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n          //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n          // * option elements in a disabled optgroup\n          //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n          // All such elements have a \"form\" property.\n          if (elem.parentNode && elem.disabled === false) {\n            // Option elements defer to a parent optgroup if present\n            if (\"label\" in elem) {\n              if (\"label\" in elem.parentNode) {\n                return elem.parentNode.disabled === disabled;\n              } else {\n                return elem.disabled === disabled;\n              }\n            } // Support: IE 6 - 11\n            // Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\n\n            return elem.isDisabled === disabled || // Where there is no isDisabled, check manually\n\n            /* jshint -W018 */\n            elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;\n          }\n\n          return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.\n          // Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n          // even exist on them, let alone have a boolean value.\n        } else if (\"label\" in elem) {\n          return elem.disabled === disabled;\n        } // Remaining elements are neither :enabled nor :disabled\n\n\n        return false;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for positionals\n     * @param {Function} fn\n     */\n\n\n    function createPositionalPseudo(fn) {\n      return markFunction(function (argument) {\n        argument = +argument;\n        return markFunction(function (seed, matches) {\n          var j,\n              matchIndexes = fn([], seed.length, argument),\n              i = matchIndexes.length; // Match elements found at the specified indexes\n\n          while (i--) {\n            if (seed[j = matchIndexes[i]]) {\n              seed[j] = !(matches[j] = seed[j]);\n            }\n          }\n        });\n      });\n    }\n    /**\n     * Checks a node for validity as a Sizzle context\n     * @param {Element|Object=} context\n     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n     */\n\n\n    function testContext(context) {\n      return context && typeof context.getElementsByTagName !== \"undefined\" && context;\n    } // Expose support vars for convenience\n\n\n    support = Sizzle.support = {};\n    /**\n     * Detects XML nodes\n     * @param {Element|Object} elem An element or a document\n     * @returns {Boolean} True iff elem is a non-HTML XML node\n     */\n\n    isXML = Sizzle.isXML = function (elem) {\n      var namespace = elem && elem.namespaceURI,\n          docElem = elem && (elem.ownerDocument || elem).documentElement; // Support: IE <=8\n      // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n      // https://bugs.jquery.com/ticket/4833\n\n      return !rhtml.test(namespace || docElem && docElem.nodeName || \"HTML\");\n    };\n    /**\n     * Sets document-related variables once based on the current document\n     * @param {Element|Object} [doc] An element or document object to use to set the document\n     * @returns {Object} Returns the current document\n     */\n\n\n    setDocument = Sizzle.setDocument = function (node) {\n      var hasCompare,\n          subWindow,\n          doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected\n      // Support: IE 11+, Edge 17 - 18+\n      // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n      // two documents; shallow comparisons work.\n      // eslint-disable-next-line eqeqeq\n\n      if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {\n        return document;\n      } // Update global variables\n\n\n      document = doc;\n      docElem = document.documentElement;\n      documentIsHTML = !isXML(document); // Support: IE 9 - 11+, Edge 12 - 18+\n      // Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n      // Support: IE 11+, Edge 17 - 18+\n      // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n      // two documents; shallow comparisons work.\n      // eslint-disable-next-line eqeqeq\n\n      if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {\n        // Support: IE 11, Edge\n        if (subWindow.addEventListener) {\n          subWindow.addEventListener(\"unload\", unloadHandler, false); // Support: IE 9 - 10 only\n        } else if (subWindow.attachEvent) {\n          subWindow.attachEvent(\"onunload\", unloadHandler);\n        }\n      } // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,\n      // Safari 4 - 5 only, Opera <=11.6 - 12.x only\n      // IE/Edge & older browsers don't support the :scope pseudo-class.\n      // Support: Safari 6.0 only\n      // Safari 6.0 supports :scope but it's an alias of :root there.\n\n\n      support.scope = assert(function (el) {\n        docElem.appendChild(el).appendChild(document.createElement(\"div\"));\n        return typeof el.querySelectorAll !== \"undefined\" && !el.querySelectorAll(\":scope fieldset div\").length;\n      });\n      /* Attributes\n      ---------------------------------------------------------------------- */\n      // Support: IE<8\n      // Verify that getAttribute really returns attributes and not properties\n      // (excepting IE8 booleans)\n\n      support.attributes = assert(function (el) {\n        el.className = \"i\";\n        return !el.getAttribute(\"className\");\n      });\n      /* getElement(s)By*\n      ---------------------------------------------------------------------- */\n      // Check if getElementsByTagName(\"*\") returns only elements\n\n      support.getElementsByTagName = assert(function (el) {\n        el.appendChild(document.createComment(\"\"));\n        return !el.getElementsByTagName(\"*\").length;\n      }); // Support: IE<9\n\n      support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10\n      // Check if getElementById returns elements by name\n      // The broken getElementById methods don't pick up programmatically-set names,\n      // so use a roundabout getElementsByName test\n\n      support.getById = assert(function (el) {\n        docElem.appendChild(el).id = expando;\n        return !document.getElementsByName || !document.getElementsByName(expando).length;\n      }); // ID filter and find\n\n      if (support.getById) {\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            return elem.getAttribute(\"id\") === attrId;\n          };\n        };\n\n        Expr.find[\"ID\"] = function (id, context) {\n          if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n            var elem = context.getElementById(id);\n            return elem ? [elem] : [];\n          }\n        };\n      } else {\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n            return node && node.value === attrId;\n          };\n        }; // Support: IE 6 - 7 only\n        // getElementById is not reliable as a find shortcut\n\n\n        Expr.find[\"ID\"] = function (id, context) {\n          if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n            var node,\n                i,\n                elems,\n                elem = context.getElementById(id);\n\n            if (elem) {\n              // Verify the id attribute\n              node = elem.getAttributeNode(\"id\");\n\n              if (node && node.value === id) {\n                return [elem];\n              } // Fall back on getElementsByName\n\n\n              elems = context.getElementsByName(id);\n              i = 0;\n\n              while (elem = elems[i++]) {\n                node = elem.getAttributeNode(\"id\");\n\n                if (node && node.value === id) {\n                  return [elem];\n                }\n              }\n            }\n\n            return [];\n          }\n        };\n      } // Tag\n\n\n      Expr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\n        if (typeof context.getElementsByTagName !== \"undefined\") {\n          return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN\n        } else if (support.qsa) {\n          return context.querySelectorAll(tag);\n        }\n      } : function (tag, context) {\n        var elem,\n            tmp = [],\n            i = 0,\n            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n        results = context.getElementsByTagName(tag); // Filter out possible comments\n\n        if (tag === \"*\") {\n          while (elem = results[i++]) {\n            if (elem.nodeType === 1) {\n              tmp.push(elem);\n            }\n          }\n\n          return tmp;\n        }\n\n        return results;\n      }; // Class\n\n      Expr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n        if (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\n          return context.getElementsByClassName(className);\n        }\n      };\n      /* QSA/matchesSelector\n      ---------------------------------------------------------------------- */\n      // QSA and matchesSelector support\n      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\n\n      rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)\n      // We allow this because of a bug in IE8/9 that throws an error\n      // whenever `document.activeElement` is accessed on an iframe\n      // So, we allow :focus to pass through QSA all the time to avoid the IE error\n      // See https://bugs.jquery.com/ticket/13378\n\n      rbuggyQSA = [];\n\n      if (support.qsa = rnative.test(document.querySelectorAll)) {\n        // Build QSA regex\n        // Regex strategy adopted from Diego Perini\n        assert(function (el) {\n          var input; // Select is set to empty string on purpose\n          // This is to test IE's treatment of not explicitly\n          // setting a boolean content attribute,\n          // since its presence should be enough\n          // https://bugs.jquery.com/ticket/12359\n\n          docElem.appendChild(el).innerHTML = \"<a id='\" + expando + \"'></a>\" + \"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" + \"<option selected=''></option></select>\"; // Support: IE8, Opera 11-12.16\n          // Nothing should be selected when empty strings follow ^= or $= or *=\n          // The test attribute must be unknown in Opera but \"safe\" for WinRT\n          // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\n          if (el.querySelectorAll(\"[msallowcapture^='']\").length) {\n            rbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n          } // Support: IE8\n          // Boolean attributes and \"value\" are not treated correctly\n\n\n          if (!el.querySelectorAll(\"[selected]\").length) {\n            rbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n          } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\n\n          if (!el.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n            rbuggyQSA.push(\"~=\");\n          } // Support: IE 11+, Edge 15 - 18+\n          // IE 11/Edge don't find elements on a `[name='']` query in some cases.\n          // Adding a temporary attribute to the document before the selection works\n          // around the issue.\n          // Interestingly, IE 10 & older don't seem to have the issue.\n\n\n          input = document.createElement(\"input\");\n          input.setAttribute(\"name\", \"\");\n          el.appendChild(input);\n\n          if (!el.querySelectorAll(\"[name='']\").length) {\n            rbuggyQSA.push(\"\\\\[\" + whitespace + \"*name\" + whitespace + \"*=\" + whitespace + \"*(?:''|\\\"\\\")\");\n          } // Webkit/Opera - :checked should return selected option elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          // IE8 throws error here and will not see later tests\n\n\n          if (!el.querySelectorAll(\":checked\").length) {\n            rbuggyQSA.push(\":checked\");\n          } // Support: Safari 8+, iOS 8+\n          // https://bugs.webkit.org/show_bug.cgi?id=136851\n          // In-page `selector#id sibling-combinator selector` fails\n\n\n          if (!el.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n            rbuggyQSA.push(\".#.+[+~]\");\n          } // Support: Firefox <=3.6 - 5 only\n          // Old Firefox doesn't throw on a badly-escaped identifier.\n\n\n          el.querySelectorAll(\"\\\\\\f\");\n          rbuggyQSA.push(\"[\\\\r\\\\n\\\\f]\");\n        });\n        assert(function (el) {\n          el.innerHTML = \"<a href='' disabled='disabled'></a>\" + \"<select disabled='disabled'><option/></select>\"; // Support: Windows 8 Native Apps\n          // The type and name attributes are restricted during .innerHTML assignment\n\n          var input = document.createElement(\"input\");\n          input.setAttribute(\"type\", \"hidden\");\n          el.appendChild(input).setAttribute(\"name\", \"D\"); // Support: IE8\n          // Enforce case-sensitivity of name attribute\n\n          if (el.querySelectorAll(\"[name=d]\").length) {\n            rbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n          // IE8 throws error here and will not see later tests\n\n\n          if (el.querySelectorAll(\":enabled\").length !== 2) {\n            rbuggyQSA.push(\":enabled\", \":disabled\");\n          } // Support: IE9-11+\n          // IE's :disabled selector does not pick up the children of disabled fieldsets\n\n\n          docElem.appendChild(el).disabled = true;\n\n          if (el.querySelectorAll(\":disabled\").length !== 2) {\n            rbuggyQSA.push(\":enabled\", \":disabled\");\n          } // Support: Opera 10 - 11 only\n          // Opera 10-11 does not throw on post-comma invalid pseudos\n\n\n          el.querySelectorAll(\"*,:x\");\n          rbuggyQSA.push(\",.*:\");\n        });\n      }\n\n      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n        assert(function (el) {\n          // Check to see if it's possible to do matchesSelector\n          // on a disconnected node (IE 9)\n          support.disconnectedMatch = matches.call(el, \"*\"); // This should fail with an exception\n          // Gecko does not error, returns false instead\n\n          matches.call(el, \"[s!='']:x\");\n          rbuggyMatches.push(\"!=\", pseudos);\n        });\n      }\n\n      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\n      /* Contains\n      ---------------------------------------------------------------------- */\n\n      hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another\n      // Purposefully self-exclusive\n      // As in, an element does not contain itself\n\n      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n        var adown = a.nodeType === 9 ? a.documentElement : a,\n            bup = b && b.parentNode;\n        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n      } : function (a, b) {\n        if (b) {\n          while (b = b.parentNode) {\n            if (b === a) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      };\n      /* Sorting\n      ---------------------------------------------------------------------- */\n      // Document order sorting\n\n      sortOrder = hasCompare ? function (a, b) {\n        // Flag for duplicate removal\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        } // Sort on method existence if only one input has compareDocumentPosition\n\n\n        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\n        if (compare) {\n          return compare;\n        } // Calculate position if both inputs belong to the same document\n        // Support: IE 11+, Edge 17 - 18+\n        // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n        // two documents; shallow comparisons work.\n        // eslint-disable-next-line eqeqeq\n\n\n        compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected\n        1; // Disconnected nodes\n\n        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n          // Choose the first element that is related to our preferred document\n          // Support: IE 11+, Edge 17 - 18+\n          // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n          // two documents; shallow comparisons work.\n          // eslint-disable-next-line eqeqeq\n          if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {\n            return -1;\n          } // Support: IE 11+, Edge 17 - 18+\n          // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n          // two documents; shallow comparisons work.\n          // eslint-disable-next-line eqeqeq\n\n\n          if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {\n            return 1;\n          } // Maintain original order\n\n\n          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n        }\n\n        return compare & 4 ? -1 : 1;\n      } : function (a, b) {\n        // Exit early if the nodes are identical\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        }\n\n        var cur,\n            i = 0,\n            aup = a.parentNode,\n            bup = b.parentNode,\n            ap = [a],\n            bp = [b]; // Parentless nodes are either documents or disconnected\n\n        if (!aup || !bup) {\n          // Support: IE 11+, Edge 17 - 18+\n          // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n          // two documents; shallow comparisons work.\n\n          /* eslint-disable eqeqeq */\n          return a == document ? -1 : b == document ? 1 :\n          /* eslint-enable eqeqeq */\n          aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check\n        } else if (aup === bup) {\n          return siblingCheck(a, b);\n        } // Otherwise we need full lists of their ancestors for comparison\n\n\n        cur = a;\n\n        while (cur = cur.parentNode) {\n          ap.unshift(cur);\n        }\n\n        cur = b;\n\n        while (cur = cur.parentNode) {\n          bp.unshift(cur);\n        } // Walk down the tree looking for a discrepancy\n\n\n        while (ap[i] === bp[i]) {\n          i++;\n        }\n\n        return i ? // Do a sibling check if the nodes have a common ancestor\n        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first\n        // Support: IE 11+, Edge 17 - 18+\n        // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n        // two documents; shallow comparisons work.\n\n        /* eslint-disable eqeqeq */\n        ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 :\n        /* eslint-enable eqeqeq */\n        0;\n      };\n      return document;\n    };\n\n    Sizzle.matches = function (expr, elements) {\n      return Sizzle(expr, null, null, elements);\n    };\n\n    Sizzle.matchesSelector = function (elem, expr) {\n      setDocument(elem);\n\n      if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + \" \"] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n        try {\n          var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes\n\n          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document\n          // fragment in IE 9\n          elem.document && elem.document.nodeType !== 11) {\n            return ret;\n          }\n        } catch (e) {\n          nonnativeSelectorCache(expr, true);\n        }\n      }\n\n      return Sizzle(expr, document, null, [elem]).length > 0;\n    };\n\n    Sizzle.contains = function (context, elem) {\n      // Set document vars if needed\n      // Support: IE 11+, Edge 17 - 18+\n      // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n      // two documents; shallow comparisons work.\n      // eslint-disable-next-line eqeqeq\n      if ((context.ownerDocument || context) != document) {\n        setDocument(context);\n      }\n\n      return contains(context, elem);\n    };\n\n    Sizzle.attr = function (elem, name) {\n      // Set document vars if needed\n      // Support: IE 11+, Edge 17 - 18+\n      // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n      // two documents; shallow comparisons work.\n      // eslint-disable-next-line eqeqeq\n      if ((elem.ownerDocument || elem) != document) {\n        setDocument(elem);\n      }\n\n      var fn = Expr.attrHandle[name.toLowerCase()],\n          // Don't get fooled by Object.prototype properties (jQuery #13807)\n      val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n    };\n\n    Sizzle.escape = function (sel) {\n      return (sel + \"\").replace(rcssescape, fcssescape);\n    };\n\n    Sizzle.error = function (msg) {\n      throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n    };\n    /**\n     * Document sorting and removing duplicates\n     * @param {ArrayLike} results\n     */\n\n\n    Sizzle.uniqueSort = function (results) {\n      var elem,\n          duplicates = [],\n          j = 0,\n          i = 0; // Unless we *know* we can detect duplicates, assume their presence\n\n      hasDuplicate = !support.detectDuplicates;\n      sortInput = !support.sortStable && results.slice(0);\n      results.sort(sortOrder);\n\n      if (hasDuplicate) {\n        while (elem = results[i++]) {\n          if (elem === results[i]) {\n            j = duplicates.push(i);\n          }\n        }\n\n        while (j--) {\n          results.splice(duplicates[j], 1);\n        }\n      } // Clear input after sorting to release objects\n      // See https://github.com/jquery/sizzle/pull/225\n\n\n      sortInput = null;\n      return results;\n    };\n    /**\n     * Utility function for retrieving the text value of an array of DOM nodes\n     * @param {Array|Element} elem\n     */\n\n\n    getText = Sizzle.getText = function (elem) {\n      var node,\n          ret = \"\",\n          i = 0,\n          nodeType = elem.nodeType;\n\n      if (!nodeType) {\n        // If no nodeType, this is expected to be an array\n        while (node = elem[i++]) {\n          // Do not traverse comment nodes\n          ret += getText(node);\n        }\n      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n        // Use textContent for elements\n        // innerText usage removed for consistency of new lines (jQuery #11153)\n        if (typeof elem.textContent === \"string\") {\n          return elem.textContent;\n        } else {\n          // Traverse its children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            ret += getText(elem);\n          }\n        }\n      } else if (nodeType === 3 || nodeType === 4) {\n        return elem.nodeValue;\n      } // Do not include comment or processing instruction nodes\n\n\n      return ret;\n    };\n\n    Expr = Sizzle.selectors = {\n      // Can be adjusted by the user\n      cacheLength: 50,\n      createPseudo: markFunction,\n      match: matchExpr,\n      attrHandle: {},\n      find: {},\n      relative: {\n        \">\": {\n          dir: \"parentNode\",\n          first: true\n        },\n        \" \": {\n          dir: \"parentNode\"\n        },\n        \"+\": {\n          dir: \"previousSibling\",\n          first: true\n        },\n        \"~\": {\n          dir: \"previousSibling\"\n        }\n      },\n      preFilter: {\n        \"ATTR\": function ATTR(match) {\n          match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted\n\n          match[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n\n          if (match[2] === \"~=\") {\n            match[3] = \" \" + match[3] + \" \";\n          }\n\n          return match.slice(0, 4);\n        },\n        \"CHILD\": function CHILD(match) {\n          /* matches from matchExpr[\"CHILD\"]\n          1 type (only|nth|...)\n          2 what (child|of-type)\n          3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n          4 xn-component of xn+y argument ([+-]?\\d*n|)\n          5 sign of xn-component\n          6 x of xn-component\n          7 sign of y-component\n          8 y of y-component\n          */\n          match[1] = match[1].toLowerCase();\n\n          if (match[1].slice(0, 3) === \"nth\") {\n            // nth-* requires argument\n            if (!match[3]) {\n              Sizzle.error(match[0]);\n            } // numeric x and y parameters for Expr.filter.CHILD\n            // remember that false/true cast respectively to 0/1\n\n\n            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n            match[5] = +(match[7] + match[8] || match[3] === \"odd\"); // other types prohibit arguments\n          } else if (match[3]) {\n            Sizzle.error(match[0]);\n          }\n\n          return match;\n        },\n        \"PSEUDO\": function PSEUDO(match) {\n          var excess,\n              unquoted = !match[6] && match[2];\n\n          if (matchExpr[\"CHILD\"].test(match[0])) {\n            return null;\n          } // Accept quoted arguments as-is\n\n\n          if (match[3]) {\n            match[2] = match[4] || match[5] || \"\"; // Strip excess characters from unquoted arguments\n          } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)\n          excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis\n          excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n            // excess is a negative index\n            match[0] = match[0].slice(0, excess);\n            match[2] = unquoted.slice(0, excess);\n          } // Return only captures needed by the pseudo filter method (type and argument)\n\n\n          return match.slice(0, 3);\n        }\n      },\n      filter: {\n        \"TAG\": function TAG(nodeNameSelector) {\n          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n          return nodeNameSelector === \"*\" ? function () {\n            return true;\n          } : function (elem) {\n            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n          };\n        },\n        \"CLASS\": function CLASS(className) {\n          var pattern = classCache[className + \" \"];\n          return pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n            return pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n          });\n        },\n        \"ATTR\": function ATTR(name, operator, check) {\n          return function (elem) {\n            var result = Sizzle.attr(elem, name);\n\n            if (result == null) {\n              return operator === \"!=\";\n            }\n\n            if (!operator) {\n              return true;\n            }\n\n            result += \"\";\n            /* eslint-disable max-len */\n\n            return operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n            /* eslint-enable max-len */\n          };\n        },\n        \"CHILD\": function CHILD(type, what, _argument, first, last) {\n          var simple = type.slice(0, 3) !== \"nth\",\n              forward = type.slice(-4) !== \"last\",\n              ofType = what === \"of-type\";\n          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)\n          function (elem) {\n            return !!elem.parentNode;\n          } : function (elem, _context, xml) {\n            var cache,\n                uniqueCache,\n                outerCache,\n                node,\n                nodeIndex,\n                start,\n                dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n                parent = elem.parentNode,\n                name = ofType && elem.nodeName.toLowerCase(),\n                useCache = !xml && !ofType,\n                diff = false;\n\n            if (parent) {\n              // :(first|last|only)-(child|of-type)\n              if (simple) {\n                while (dir) {\n                  node = elem;\n\n                  while (node = node[dir]) {\n                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n                      return false;\n                    }\n                  } // Reverse direction for :only-* (if we haven't yet done so)\n\n\n                  start = dir = type === \"only\" && !start && \"nextSibling\";\n                }\n\n                return true;\n              }\n\n              start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`\n\n              if (forward && useCache) {\n                // Seek `elem` from a previously-cached index\n                // ...in a gzip-friendly way\n                node = parent;\n                outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                // Defend against cloned attroperties (jQuery gh-1709)\n\n                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                cache = uniqueCache[type] || [];\n                nodeIndex = cache[0] === dirruns && cache[1];\n                diff = nodeIndex && cache[2];\n                node = nodeIndex && parent.childNodes[nodeIndex];\n\n                while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start\n                diff = nodeIndex = 0) || start.pop()) {\n                  // When found, cache indexes on `parent` and break\n                  if (node.nodeType === 1 && ++diff && node === elem) {\n                    uniqueCache[type] = [dirruns, nodeIndex, diff];\n                    break;\n                  }\n                }\n              } else {\n                // Use previously-cached element index if available\n                if (useCache) {\n                  // ...in a gzip-friendly way\n                  node = elem;\n                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                  // Defend against cloned attroperties (jQuery gh-1709)\n\n                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                  cache = uniqueCache[type] || [];\n                  nodeIndex = cache[0] === dirruns && cache[1];\n                  diff = nodeIndex;\n                } // xml :nth-child(...)\n                // or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\n\n                if (diff === false) {\n                  // Use the same loop as above to seek `elem` from the start\n                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n                      // Cache the index of each encountered element\n                      if (useCache) {\n                        outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                        // Defend against cloned attroperties (jQuery gh-1709)\n\n                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                        uniqueCache[type] = [dirruns, diff];\n                      }\n\n                      if (node === elem) {\n                        break;\n                      }\n                    }\n                  }\n                }\n              } // Incorporate the offset, then check against cycle size\n\n\n              diff -= last;\n              return diff === first || diff % first === 0 && diff / first >= 0;\n            }\n          };\n        },\n        \"PSEUDO\": function PSEUDO(pseudo, argument) {\n          // pseudo-class names are case-insensitive\n          // http://www.w3.org/TR/selectors/#pseudo-classes\n          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n          // Remember that setFilters inherits from pseudos\n          var args,\n              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo); // The user may use createPseudo to indicate that\n          // arguments are needed to create the filter function\n          // just as Sizzle does\n\n          if (fn[expando]) {\n            return fn(argument);\n          } // But maintain support for old signatures\n\n\n          if (fn.length > 1) {\n            args = [pseudo, pseudo, \"\", argument];\n            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n              var idx,\n                  matched = fn(seed, argument),\n                  i = matched.length;\n\n              while (i--) {\n                idx = indexOf(seed, matched[i]);\n                seed[idx] = !(matches[idx] = matched[i]);\n              }\n            }) : function (elem) {\n              return fn(elem, 0, args);\n            };\n          }\n\n          return fn;\n        }\n      },\n      pseudos: {\n        // Potentially complex pseudos\n        \"not\": markFunction(function (selector) {\n          // Trim the selector passed to compile\n          // to avoid treating leading and trailing\n          // spaces as combinators\n          var input = [],\n              results = [],\n              matcher = compile(selector.replace(rtrim, \"$1\"));\n          return matcher[expando] ? markFunction(function (seed, matches, _context, xml) {\n            var elem,\n                unmatched = matcher(seed, null, xml, []),\n                i = seed.length; // Match elements unmatched by `matcher`\n\n            while (i--) {\n              if (elem = unmatched[i]) {\n                seed[i] = !(matches[i] = elem);\n              }\n            }\n          }) : function (elem, _context, xml) {\n            input[0] = elem;\n            matcher(input, null, xml, results); // Don't keep the element (issue #299)\n\n            input[0] = null;\n            return !results.pop();\n          };\n        }),\n        \"has\": markFunction(function (selector) {\n          return function (elem) {\n            return Sizzle(selector, elem).length > 0;\n          };\n        }),\n        \"contains\": markFunction(function (text) {\n          text = text.replace(runescape, funescape);\n          return function (elem) {\n            return (elem.textContent || getText(elem)).indexOf(text) > -1;\n          };\n        }),\n        // \"Whether an element is represented by a :lang() selector\n        // is based solely on the element's language value\n        // being equal to the identifier C,\n        // or beginning with the identifier C immediately followed by \"-\".\n        // The matching of C against the element's language value is performed case-insensitively.\n        // The identifier C does not have to be a valid language name.\"\n        // http://www.w3.org/TR/selectors/#lang-pseudo\n        \"lang\": markFunction(function (lang) {\n          // lang value must be a valid identifier\n          if (!ridentifier.test(lang || \"\")) {\n            Sizzle.error(\"unsupported lang: \" + lang);\n          }\n\n          lang = lang.replace(runescape, funescape).toLowerCase();\n          return function (elem) {\n            var elemLang;\n\n            do {\n              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n                elemLang = elemLang.toLowerCase();\n                return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n              }\n            } while ((elem = elem.parentNode) && elem.nodeType === 1);\n\n            return false;\n          };\n        }),\n        // Miscellaneous\n        \"target\": function target(elem) {\n          var hash = window.location && window.location.hash;\n          return hash && hash.slice(1) === elem.id;\n        },\n        \"root\": function root(elem) {\n          return elem === docElem;\n        },\n        \"focus\": function focus(elem) {\n          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n        },\n        // Boolean properties\n        \"enabled\": createDisabledPseudo(false),\n        \"disabled\": createDisabledPseudo(true),\n        \"checked\": function checked(elem) {\n          // In CSS3, :checked should return both checked and selected elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          var nodeName = elem.nodeName.toLowerCase();\n          return nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n        },\n        \"selected\": function selected(elem) {\n          // Accessing this property makes selected-by-default\n          // options in Safari work properly\n          if (elem.parentNode) {\n            // eslint-disable-next-line no-unused-expressions\n            elem.parentNode.selectedIndex;\n          }\n\n          return elem.selected === true;\n        },\n        // Contents\n        \"empty\": function empty(elem) {\n          // http://www.w3.org/TR/selectors/#empty-pseudo\n          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n          //   but not by others (comment: 8; processing instruction: 7; etc.)\n          // nodeType < 6 works because attributes (2) do not appear as children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            if (elem.nodeType < 6) {\n              return false;\n            }\n          }\n\n          return true;\n        },\n        \"parent\": function parent(elem) {\n          return !Expr.pseudos[\"empty\"](elem);\n        },\n        // Element/input types\n        \"header\": function header(elem) {\n          return rheader.test(elem.nodeName);\n        },\n        \"input\": function input(elem) {\n          return rinputs.test(elem.nodeName);\n        },\n        \"button\": function button(elem) {\n          var name = elem.nodeName.toLowerCase();\n          return name === \"input\" && elem.type === \"button\" || name === \"button\";\n        },\n        \"text\": function text(elem) {\n          var attr;\n          return elem.nodeName.toLowerCase() === \"input\" && elem.type === \"text\" && ( // Support: IE<8\n          // New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n          (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\n        },\n        // Position-in-collection\n        \"first\": createPositionalPseudo(function () {\n          return [0];\n        }),\n        \"last\": createPositionalPseudo(function (_matchIndexes, length) {\n          return [length - 1];\n        }),\n        \"eq\": createPositionalPseudo(function (_matchIndexes, length, argument) {\n          return [argument < 0 ? argument + length : argument];\n        }),\n        \"even\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 0;\n\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"odd\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 1;\n\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument > length ? length : argument;\n\n          for (; --i >= 0;) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument;\n\n          for (; ++i < length;) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        })\n      }\n    };\n    Expr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"]; // Add button/input type pseudos\n\n    for (i in {\n      radio: true,\n      checkbox: true,\n      file: true,\n      password: true,\n      image: true\n    }) {\n      Expr.pseudos[i] = createInputPseudo(i);\n    }\n\n    for (i in {\n      submit: true,\n      reset: true\n    }) {\n      Expr.pseudos[i] = createButtonPseudo(i);\n    } // Easy API for creating new setFilters\n\n\n    function setFilters() {}\n\n    setFilters.prototype = Expr.filters = Expr.pseudos;\n    Expr.setFilters = new setFilters();\n\n    tokenize = Sizzle.tokenize = function (selector, parseOnly) {\n      var matched,\n          match,\n          tokens,\n          type,\n          soFar,\n          groups,\n          preFilters,\n          cached = tokenCache[selector + \" \"];\n\n      if (cached) {\n        return parseOnly ? 0 : cached.slice(0);\n      }\n\n      soFar = selector;\n      groups = [];\n      preFilters = Expr.preFilter;\n\n      while (soFar) {\n        // Comma and first run\n        if (!matched || (match = rcomma.exec(soFar))) {\n          if (match) {\n            // Don't consume trailing commas as valid\n            soFar = soFar.slice(match[0].length) || soFar;\n          }\n\n          groups.push(tokens = []);\n        }\n\n        matched = false; // Combinators\n\n        if (match = rcombinators.exec(soFar)) {\n          matched = match.shift();\n          tokens.push({\n            value: matched,\n            // Cast descendant combinators to space\n            type: match[0].replace(rtrim, \" \")\n          });\n          soFar = soFar.slice(matched.length);\n        } // Filters\n\n\n        for (type in Expr.filter) {\n          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n            matched = match.shift();\n            tokens.push({\n              value: matched,\n              type: type,\n              matches: match\n            });\n            soFar = soFar.slice(matched.length);\n          }\n        }\n\n        if (!matched) {\n          break;\n        }\n      } // Return the length of the invalid excess\n      // if we're just parsing\n      // Otherwise, throw an error or return tokens\n\n\n      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens\n      tokenCache(selector, groups).slice(0);\n    };\n\n    function toSelector(tokens) {\n      var i = 0,\n          len = tokens.length,\n          selector = \"\";\n\n      for (; i < len; i++) {\n        selector += tokens[i].value;\n      }\n\n      return selector;\n    }\n\n    function addCombinator(matcher, combinator, base) {\n      var dir = combinator.dir,\n          skip = combinator.next,\n          key = skip || dir,\n          checkNonElements = base && key === \"parentNode\",\n          doneName = done++;\n      return combinator.first ? // Check against closest ancestor/preceding element\n      function (elem, context, xml) {\n        while (elem = elem[dir]) {\n          if (elem.nodeType === 1 || checkNonElements) {\n            return matcher(elem, context, xml);\n          }\n        }\n\n        return false;\n      } : // Check against all ancestor/preceding elements\n      function (elem, context, xml) {\n        var oldCache,\n            uniqueCache,\n            outerCache,\n            newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\n        if (xml) {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              if (matcher(elem, context, xml)) {\n                return true;\n              }\n            }\n          }\n        } else {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only\n              // Defend against cloned attroperties (jQuery gh-1709)\n\n              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\n\n              if (skip && skip === elem.nodeName.toLowerCase()) {\n                elem = elem[dir] || elem;\n              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n                // Assign to newCache so results back-propagate to previous elements\n                return newCache[2] = oldCache[2];\n              } else {\n                // Reuse newcache so results back-propagate to previous elements\n                uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking\n\n                if (newCache[2] = matcher(elem, context, xml)) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n\n        return false;\n      };\n    }\n\n    function elementMatcher(matchers) {\n      return matchers.length > 1 ? function (elem, context, xml) {\n        var i = matchers.length;\n\n        while (i--) {\n          if (!matchers[i](elem, context, xml)) {\n            return false;\n          }\n        }\n\n        return true;\n      } : matchers[0];\n    }\n\n    function multipleContexts(selector, contexts, results) {\n      var i = 0,\n          len = contexts.length;\n\n      for (; i < len; i++) {\n        Sizzle(selector, contexts[i], results);\n      }\n\n      return results;\n    }\n\n    function condense(unmatched, map, filter, context, xml) {\n      var elem,\n          newUnmatched = [],\n          i = 0,\n          len = unmatched.length,\n          mapped = map != null;\n\n      for (; i < len; i++) {\n        if (elem = unmatched[i]) {\n          if (!filter || filter(elem, context, xml)) {\n            newUnmatched.push(elem);\n\n            if (mapped) {\n              map.push(i);\n            }\n          }\n        }\n      }\n\n      return newUnmatched;\n    }\n\n    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n      if (postFilter && !postFilter[expando]) {\n        postFilter = setMatcher(postFilter);\n      }\n\n      if (postFinder && !postFinder[expando]) {\n        postFinder = setMatcher(postFinder, postSelector);\n      }\n\n      return markFunction(function (seed, results, context, xml) {\n        var temp,\n            i,\n            elem,\n            preMap = [],\n            postMap = [],\n            preexisting = results.length,\n            // Get initial elements from seed or context\n        elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n            // Prefilter to get matcher input, preserving a map for seed-results synchronization\n        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary\n        [] : // ...otherwise use results directly\n        results : matcherIn; // Find primary matches\n\n        if (matcher) {\n          matcher(matcherIn, matcherOut, context, xml);\n        } // Apply postFilter\n\n\n        if (postFilter) {\n          temp = condense(matcherOut, postMap);\n          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn\n\n          i = temp.length;\n\n          while (i--) {\n            if (elem = temp[i]) {\n              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n            }\n          }\n        }\n\n        if (seed) {\n          if (postFinder || preFilter) {\n            if (postFinder) {\n              // Get the final matcherOut by condensing this intermediate into postFinder contexts\n              temp = [];\n              i = matcherOut.length;\n\n              while (i--) {\n                if (elem = matcherOut[i]) {\n                  // Restore matcherIn since elem is not yet a final match\n                  temp.push(matcherIn[i] = elem);\n                }\n              }\n\n              postFinder(null, matcherOut = [], temp, xml);\n            } // Move matched elements from seed to results to keep them synchronized\n\n\n            i = matcherOut.length;\n\n            while (i--) {\n              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n                seed[temp] = !(results[temp] = elem);\n              }\n            }\n          } // Add elements to results, through postFinder if defined\n\n        } else {\n          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\n          if (postFinder) {\n            postFinder(null, results, matcherOut, xml);\n          } else {\n            push.apply(results, matcherOut);\n          }\n        }\n      });\n    }\n\n    function matcherFromTokens(tokens) {\n      var checkContext,\n          matcher,\n          j,\n          len = tokens.length,\n          leadingRelative = Expr.relative[tokens[0].type],\n          implicitRelative = leadingRelative || Expr.relative[\" \"],\n          i = leadingRelative ? 1 : 0,\n          // The foundational matcher ensures that elements are reachable from top-level context(s)\n      matchContext = addCombinator(function (elem) {\n        return elem === checkContext;\n      }, implicitRelative, true),\n          matchAnyContext = addCombinator(function (elem) {\n        return indexOf(checkContext, elem) > -1;\n      }, implicitRelative, true),\n          matchers = [function (elem, context, xml) {\n        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)\n\n        checkContext = null;\n        return ret;\n      }];\n\n      for (; i < len; i++) {\n        if (matcher = Expr.relative[tokens[i].type]) {\n          matchers = [addCombinator(elementMatcher(matchers), matcher)];\n        } else {\n          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher\n\n          if (matcher[expando]) {\n            // Find the next relative operator (if any) for proper handling\n            j = ++i;\n\n            for (; j < len; j++) {\n              if (Expr.relative[tokens[j].type]) {\n                break;\n              }\n            }\n\n            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n            tokens.slice(0, i - 1).concat({\n              value: tokens[i - 2].type === \" \" ? \"*\" : \"\"\n            })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n          }\n\n          matchers.push(matcher);\n        }\n      }\n\n      return elementMatcher(matchers);\n    }\n\n    function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n      var bySet = setMatchers.length > 0,\n          byElement = elementMatchers.length > 0,\n          superMatcher = function superMatcher(seed, context, xml, results, outermost) {\n        var elem,\n            j,\n            matcher,\n            matchedCount = 0,\n            i = \"0\",\n            unmatched = seed && [],\n            setMatched = [],\n            contextBackup = outermostContext,\n            // We must always have either seed elements or outermost context\n        elems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\n            // Use integer dirruns iff this is the outermost matcher\n        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n            len = elems.length;\n\n        if (outermost) {\n          // Support: IE 11+, Edge 17 - 18+\n          // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n          // two documents; shallow comparisons work.\n          // eslint-disable-next-line eqeqeq\n          outermostContext = context == document || context || outermost;\n        } // Add elements passing elementMatchers directly to results\n        // Support: IE<9, Safari\n        // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\n\n        for (; i !== len && (elem = elems[i]) != null; i++) {\n          if (byElement && elem) {\n            j = 0; // Support: IE 11+, Edge 17 - 18+\n            // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n            // two documents; shallow comparisons work.\n            // eslint-disable-next-line eqeqeq\n\n            if (!context && elem.ownerDocument != document) {\n              setDocument(elem);\n              xml = !documentIsHTML;\n            }\n\n            while (matcher = elementMatchers[j++]) {\n              if (matcher(elem, context || document, xml)) {\n                results.push(elem);\n                break;\n              }\n            }\n\n            if (outermost) {\n              dirruns = dirrunsUnique;\n            }\n          } // Track unmatched elements for set filters\n\n\n          if (bySet) {\n            // They will have gone through all possible matchers\n            if (elem = !matcher && elem) {\n              matchedCount--;\n            } // Lengthen the array for every element, matched or not\n\n\n            if (seed) {\n              unmatched.push(elem);\n            }\n          }\n        } // `i` is now the count of elements visited above, and adding it to `matchedCount`\n        // makes the latter nonnegative.\n\n\n        matchedCount += i; // Apply set filters to unmatched elements\n        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n        // no element matchers and no seed.\n        // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n        // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n        // numerically zero.\n\n        if (bySet && i !== matchedCount) {\n          j = 0;\n\n          while (matcher = setMatchers[j++]) {\n            matcher(unmatched, setMatched, context, xml);\n          }\n\n          if (seed) {\n            // Reintegrate element matches to eliminate the need for sorting\n            if (matchedCount > 0) {\n              while (i--) {\n                if (!(unmatched[i] || setMatched[i])) {\n                  setMatched[i] = pop.call(results);\n                }\n              }\n            } // Discard index placeholder values to get only actual matches\n\n\n            setMatched = condense(setMatched);\n          } // Add matches to results\n\n\n          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting\n\n          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n            Sizzle.uniqueSort(results);\n          }\n        } // Override manipulation of globals by nested matchers\n\n\n        if (outermost) {\n          dirruns = dirrunsUnique;\n          outermostContext = contextBackup;\n        }\n\n        return unmatched;\n      };\n\n      return bySet ? markFunction(superMatcher) : superMatcher;\n    }\n\n    compile = Sizzle.compile = function (selector, match\n    /* Internal Use Only */\n    ) {\n      var i,\n          setMatchers = [],\n          elementMatchers = [],\n          cached = compilerCache[selector + \" \"];\n\n      if (!cached) {\n        // Generate a function of recursive functions that can be used to check each element\n        if (!match) {\n          match = tokenize(selector);\n        }\n\n        i = match.length;\n\n        while (i--) {\n          cached = matcherFromTokens(match[i]);\n\n          if (cached[expando]) {\n            setMatchers.push(cached);\n          } else {\n            elementMatchers.push(cached);\n          }\n        } // Cache the compiled function\n\n\n        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization\n\n        cached.selector = selector;\n      }\n\n      return cached;\n    };\n    /**\n     * A low-level selection function that works with Sizzle's compiled\n     *  selector functions\n     * @param {String|Function} selector A selector or a pre-compiled\n     *  selector function built with Sizzle.compile\n     * @param {Element} context\n     * @param {Array} [results]\n     * @param {Array} [seed] A set of elements to match against\n     */\n\n\n    select = Sizzle.select = function (selector, context, results, seed) {\n      var i,\n          tokens,\n          token,\n          type,\n          find,\n          compiled = typeof selector === \"function\" && selector,\n          match = !seed && tokenize(selector = compiled.selector || selector);\n      results = results || []; // Try to minimize operations if there is only one selector in the list and no seed\n      // (the latter of which guarantees us context)\n\n      if (match.length === 1) {\n        // Reduce context if the leading compound selector is an ID\n        tokens = match[0] = match[0].slice(0);\n\n        if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n          context = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n\n          if (!context) {\n            return results; // Precompiled matchers will still verify ancestry, so step up a level\n          } else if (compiled) {\n            context = context.parentNode;\n          }\n\n          selector = selector.slice(tokens.shift().value.length);\n        } // Fetch a seed set for right-to-left matching\n\n\n        i = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\n        while (i--) {\n          token = tokens[i]; // Abort if we hit a combinator\n\n          if (Expr.relative[type = token.type]) {\n            break;\n          }\n\n          if (find = Expr.find[type]) {\n            // Search, expanding context for leading sibling combinators\n            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n              // If seed is empty or no tokens remain, we can return early\n              tokens.splice(i, 1);\n              selector = seed.length && toSelector(tokens);\n\n              if (!selector) {\n                push.apply(results, seed);\n                return results;\n              }\n\n              break;\n            }\n          }\n        }\n      } // Compile and execute a filtering function if one is not provided\n      // Provide `match` to avoid retokenization if we modified the selector above\n\n\n      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n      return results;\n    }; // One-time assignments\n    // Sort stability\n\n\n    support.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando; // Support: Chrome 14-35+\n    // Always assume duplicates if they aren't passed to the comparison function\n\n    support.detectDuplicates = !!hasDuplicate; // Initialize against the default document\n\n    setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n    // Detached nodes confoundingly follow *each other*\n\n    support.sortDetached = assert(function (el) {\n      // Should return 1, but returns 4 (following)\n      return el.compareDocumentPosition(document.createElement(\"fieldset\")) & 1;\n    }); // Support: IE<8\n    // Prevent attribute/property \"interpolation\"\n    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\n    if (!assert(function (el) {\n      el.innerHTML = \"<a href='#'></a>\";\n      return el.firstChild.getAttribute(\"href\") === \"#\";\n    })) {\n      addHandle(\"type|href|height|width\", function (elem, name, isXML) {\n        if (!isXML) {\n          return elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n        }\n      });\n    } // Support: IE<9\n    // Use defaultValue in place of getAttribute(\"value\")\n\n\n    if (!support.attributes || !assert(function (el) {\n      el.innerHTML = \"<input/>\";\n      el.firstChild.setAttribute(\"value\", \"\");\n      return el.firstChild.getAttribute(\"value\") === \"\";\n    })) {\n      addHandle(\"value\", function (elem, _name, isXML) {\n        if (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n          return elem.defaultValue;\n        }\n      });\n    } // Support: IE<9\n    // Use getAttributeNode to fetch booleans when getAttribute lies\n\n\n    if (!assert(function (el) {\n      return el.getAttribute(\"disabled\") == null;\n    })) {\n      addHandle(booleans, function (elem, name, isXML) {\n        var val;\n\n        if (!isXML) {\n          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n        }\n      });\n    }\n\n    return Sizzle;\n  }(window);\n\n  jQuery.find = Sizzle;\n  jQuery.expr = Sizzle.selectors; // Deprecated\n\n  jQuery.expr[\":\"] = jQuery.expr.pseudos;\n  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n  jQuery.text = Sizzle.getText;\n  jQuery.isXMLDoc = Sizzle.isXML;\n  jQuery.contains = Sizzle.contains;\n  jQuery.escapeSelector = Sizzle.escape;\n\n  var dir = function dir(elem, _dir, until) {\n    var matched = [],\n        truncate = until !== undefined;\n\n    while ((elem = elem[_dir]) && elem.nodeType !== 9) {\n      if (elem.nodeType === 1) {\n        if (truncate && jQuery(elem).is(until)) {\n          break;\n        }\n\n        matched.push(elem);\n      }\n    }\n\n    return matched;\n  };\n\n  var _siblings = function siblings(n, elem) {\n    var matched = [];\n\n    for (; n; n = n.nextSibling) {\n      if (n.nodeType === 1 && n !== elem) {\n        matched.push(n);\n      }\n    }\n\n    return matched;\n  };\n\n  var rneedsContext = jQuery.expr.match.needsContext;\n\n  function nodeName(elem, name) {\n    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n  }\n\n  var rsingleTag = /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i; // Implement the identical functionality for filter and not\n\n  function winnow(elements, qualifier, not) {\n    if (isFunction(qualifier)) {\n      return jQuery.grep(elements, function (elem, i) {\n        return !!qualifier.call(elem, i, elem) !== not;\n      });\n    } // Single element\n\n\n    if (qualifier.nodeType) {\n      return jQuery.grep(elements, function (elem) {\n        return elem === qualifier !== not;\n      });\n    } // Arraylike of elements (jQuery, arguments, Array)\n\n\n    if (typeof qualifier !== \"string\") {\n      return jQuery.grep(elements, function (elem) {\n        return indexOf.call(qualifier, elem) > -1 !== not;\n      });\n    } // Filtered directly for both simple and complex selectors\n\n\n    return jQuery.filter(qualifier, elements, not);\n  }\n\n  jQuery.filter = function (expr, elems, not) {\n    var elem = elems[0];\n\n    if (not) {\n      expr = \":not(\" + expr + \")\";\n    }\n\n    if (elems.length === 1 && elem.nodeType === 1) {\n      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];\n    }\n\n    return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {\n      return elem.nodeType === 1;\n    }));\n  };\n\n  jQuery.fn.extend({\n    find: function find(selector) {\n      var i,\n          ret,\n          len = this.length,\n          self = this;\n\n      if (typeof selector !== \"string\") {\n        return this.pushStack(jQuery(selector).filter(function () {\n          for (i = 0; i < len; i++) {\n            if (jQuery.contains(self[i], this)) {\n              return true;\n            }\n          }\n        }));\n      }\n\n      ret = this.pushStack([]);\n\n      for (i = 0; i < len; i++) {\n        jQuery.find(selector, self[i], ret);\n      }\n\n      return len > 1 ? jQuery.uniqueSort(ret) : ret;\n    },\n    filter: function filter(selector) {\n      return this.pushStack(winnow(this, selector || [], false));\n    },\n    not: function not(selector) {\n      return this.pushStack(winnow(this, selector || [], true));\n    },\n    is: function is(selector) {\n      return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set\n      // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n      typeof selector === \"string\" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;\n    }\n  }); // Initialize a jQuery object\n  // A central reference to the root jQuery(document)\n\n  var rootjQuery,\n      // A simple way to check for HTML strings\n  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n  // Strict HTML recognition (#11290: must start with <)\n  // Shortcut simple #id case for speed\n  rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n      init = jQuery.fn.init = function (selector, context, root) {\n    var match, elem; // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\n    if (!selector) {\n      return this;\n    } // Method init() accepts an alternate rootjQuery\n    // so migrate can support jQuery.sub (gh-2101)\n\n\n    root = root || rootjQuery; // Handle HTML strings\n\n    if (typeof selector === \"string\") {\n      if (selector[0] === \"<\" && selector[selector.length - 1] === \">\" && selector.length >= 3) {\n        // Assume that strings that start and end with <> are HTML and skip the regex check\n        match = [null, selector, null];\n      } else {\n        match = rquickExpr.exec(selector);\n      } // Match html or make sure no context is specified for #id\n\n\n      if (match && (match[1] || !context)) {\n        // HANDLE: $(html) -> $(array)\n        if (match[1]) {\n          context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat\n          // Intentionally let the error be thrown if parseHTML is not present\n\n          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)\n\n          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n            for (match in context) {\n              // Properties of context are called as methods if possible\n              if (isFunction(this[match])) {\n                this[match](context[match]); // ...and otherwise set as attributes\n              } else {\n                this.attr(match, context[match]);\n              }\n            }\n          }\n\n          return this; // HANDLE: $(#id)\n        } else {\n          elem = document.getElementById(match[2]);\n\n          if (elem) {\n            // Inject the element directly into the jQuery object\n            this[0] = elem;\n            this.length = 1;\n          }\n\n          return this;\n        } // HANDLE: $(expr, $(...))\n\n      } else if (!context || context.jquery) {\n        return (context || root).find(selector); // HANDLE: $(expr, context)\n        // (which is just equivalent to: $(context).find(expr)\n      } else {\n        return this.constructor(context).find(selector);\n      } // HANDLE: $(DOMElement)\n\n    } else if (selector.nodeType) {\n      this[0] = selector;\n      this.length = 1;\n      return this; // HANDLE: $(function)\n      // Shortcut for document ready\n    } else if (isFunction(selector)) {\n      return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present\n      selector(jQuery);\n    }\n\n    return jQuery.makeArray(selector, this);\n  }; // Give the init function the jQuery prototype for later instantiation\n\n\n  init.prototype = jQuery.fn; // Initialize central reference\n\n  rootjQuery = jQuery(document);\n  var rparentsprev = /^(?:parents|prev(?:Until|All))/,\n      // Methods guaranteed to produce a unique set when starting from a unique set\n  guaranteedUnique = {\n    children: true,\n    contents: true,\n    next: true,\n    prev: true\n  };\n  jQuery.fn.extend({\n    has: function has(target) {\n      var targets = jQuery(target, this),\n          l = targets.length;\n      return this.filter(function () {\n        var i = 0;\n\n        for (; i < l; i++) {\n          if (jQuery.contains(this, targets[i])) {\n            return true;\n          }\n        }\n      });\n    },\n    closest: function closest(selectors, context) {\n      var cur,\n          i = 0,\n          l = this.length,\n          matched = [],\n          targets = typeof selectors !== \"string\" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context\n\n      if (!rneedsContext.test(selectors)) {\n        for (; i < l; i++) {\n          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\n            // Always skip document fragments\n            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle\n            cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {\n              matched.push(cur);\n              break;\n            }\n          }\n        }\n      }\n\n      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);\n    },\n    // Determine the position of an element within the set\n    index: function index(elem) {\n      // No argument, return index in parent\n      if (!elem) {\n        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n      } // Index in selector\n\n\n      if (typeof elem === \"string\") {\n        return indexOf.call(jQuery(elem), this[0]);\n      } // Locate the position of the desired element\n\n\n      return indexOf.call(this, // If it receives a jQuery object, the first element is used\n      elem.jquery ? elem[0] : elem);\n    },\n    add: function add(selector, context) {\n      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));\n    },\n    addBack: function addBack(selector) {\n      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n    }\n  });\n\n  function sibling(cur, dir) {\n    while ((cur = cur[dir]) && cur.nodeType !== 1) {}\n\n    return cur;\n  }\n\n  jQuery.each({\n    parent: function parent(elem) {\n      var parent = elem.parentNode;\n      return parent && parent.nodeType !== 11 ? parent : null;\n    },\n    parents: function parents(elem) {\n      return dir(elem, \"parentNode\");\n    },\n    parentsUntil: function parentsUntil(elem, _i, until) {\n      return dir(elem, \"parentNode\", until);\n    },\n    next: function next(elem) {\n      return sibling(elem, \"nextSibling\");\n    },\n    prev: function prev(elem) {\n      return sibling(elem, \"previousSibling\");\n    },\n    nextAll: function nextAll(elem) {\n      return dir(elem, \"nextSibling\");\n    },\n    prevAll: function prevAll(elem) {\n      return dir(elem, \"previousSibling\");\n    },\n    nextUntil: function nextUntil(elem, _i, until) {\n      return dir(elem, \"nextSibling\", until);\n    },\n    prevUntil: function prevUntil(elem, _i, until) {\n      return dir(elem, \"previousSibling\", until);\n    },\n    siblings: function siblings(elem) {\n      return _siblings((elem.parentNode || {}).firstChild, elem);\n    },\n    children: function children(elem) {\n      return _siblings(elem.firstChild);\n    },\n    contents: function contents(elem) {\n      if (elem.contentDocument != null && // Support: IE 11+\n      // <object> elements with no `data` attribute has an object\n      // `contentDocument` with a `null` prototype.\n      getProto(elem.contentDocument)) {\n        return elem.contentDocument;\n      } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n      // Treat the template element as a regular one in browsers that\n      // don't support it.\n\n\n      if (nodeName(elem, \"template\")) {\n        elem = elem.content || elem;\n      }\n\n      return jQuery.merge([], elem.childNodes);\n    }\n  }, function (name, fn) {\n    jQuery.fn[name] = function (until, selector) {\n      var matched = jQuery.map(this, fn, until);\n\n      if (name.slice(-5) !== \"Until\") {\n        selector = until;\n      }\n\n      if (selector && typeof selector === \"string\") {\n        matched = jQuery.filter(selector, matched);\n      }\n\n      if (this.length > 1) {\n        // Remove duplicates\n        if (!guaranteedUnique[name]) {\n          jQuery.uniqueSort(matched);\n        } // Reverse order for parents* and prev-derivatives\n\n\n        if (rparentsprev.test(name)) {\n          matched.reverse();\n        }\n      }\n\n      return this.pushStack(matched);\n    };\n  });\n  var rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g; // Convert String-formatted options into Object-formatted ones\n\n  function createOptions(options) {\n    var object = {};\n    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {\n      object[flag] = true;\n    });\n    return object;\n  }\n  /*\n  * Create a callback list using the following parameters:\n  *\n  *\toptions: an optional list of space-separated options that will change how\n  *\t\t\tthe callback list behaves or a more traditional option object\n  *\n  * By default a callback list will act like an event callback list and can be\n  * \"fired\" multiple times.\n  *\n  * Possible options:\n  *\n  *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n  *\n  *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n  *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n  *\t\t\t\t\tvalues (like a Deferred)\n  *\n  *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n  *\n  *\tstopOnFalse:\tinterrupt callings when a callback returns false\n  *\n  */\n\n\n  jQuery.Callbacks = function (options) {\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === \"string\" ? createOptions(options) : jQuery.extend({}, options);\n\n    var // Flag to know if list is currently firing\n    firing,\n        // Last fire value for non-forgettable lists\n    memory,\n        // Flag to know if list was already fired\n    _fired,\n        // Flag to prevent firing\n    _locked,\n        // Actual callback list\n    list = [],\n        // Queue of execution data for repeatable lists\n    queue = [],\n        // Index of currently firing callback (modified by add/remove as needed)\n    firingIndex = -1,\n        // Fire callbacks\n    fire = function fire() {\n      // Enforce single-firing\n      _locked = _locked || options.once; // Execute callbacks for all pending executions,\n      // respecting firingIndex overrides and runtime changes\n\n      _fired = firing = true;\n\n      for (; queue.length; firingIndex = -1) {\n        memory = queue.shift();\n\n        while (++firingIndex < list.length) {\n          // Run callback and check for early termination\n          if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\n            // Jump to end and forget the data so .add doesn't re-fire\n            firingIndex = list.length;\n            memory = false;\n          }\n        }\n      } // Forget the data if we're done with it\n\n\n      if (!options.memory) {\n        memory = false;\n      }\n\n      firing = false; // Clean up if we're done firing for good\n\n      if (_locked) {\n        // Keep an empty list if we have data for future add calls\n        if (memory) {\n          list = []; // Otherwise, this object is spent\n        } else {\n          list = \"\";\n        }\n      }\n    },\n        // Actual Callbacks object\n    self = {\n      // Add a callback or a collection of callbacks to the list\n      add: function add() {\n        if (list) {\n          // If we have memory from a past run, we should fire after adding\n          if (memory && !firing) {\n            firingIndex = list.length - 1;\n            queue.push(memory);\n          }\n\n          (function add(args) {\n            jQuery.each(args, function (_, arg) {\n              if (isFunction(arg)) {\n                if (!options.unique || !self.has(arg)) {\n                  list.push(arg);\n                }\n              } else if (arg && arg.length && toType(arg) !== \"string\") {\n                // Inspect recursively\n                add(arg);\n              }\n            });\n          })(arguments);\n\n          if (memory && !firing) {\n            fire();\n          }\n        }\n\n        return this;\n      },\n      // Remove a callback from the list\n      remove: function remove() {\n        jQuery.each(arguments, function (_, arg) {\n          var index;\n\n          while ((index = jQuery.inArray(arg, list, index)) > -1) {\n            list.splice(index, 1); // Handle firing indexes\n\n            if (index <= firingIndex) {\n              firingIndex--;\n            }\n          }\n        });\n        return this;\n      },\n      // Check if a given callback is in the list.\n      // If no argument is given, return whether or not list has callbacks attached.\n      has: function has(fn) {\n        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;\n      },\n      // Remove all callbacks from the list\n      empty: function empty() {\n        if (list) {\n          list = [];\n        }\n\n        return this;\n      },\n      // Disable .fire and .add\n      // Abort any current/pending executions\n      // Clear all callbacks and values\n      disable: function disable() {\n        _locked = queue = [];\n        list = memory = \"\";\n        return this;\n      },\n      disabled: function disabled() {\n        return !list;\n      },\n      // Disable .fire\n      // Also disable .add unless we have memory (since it would have no effect)\n      // Abort any pending executions\n      lock: function lock() {\n        _locked = queue = [];\n\n        if (!memory && !firing) {\n          list = memory = \"\";\n        }\n\n        return this;\n      },\n      locked: function locked() {\n        return !!_locked;\n      },\n      // Call all callbacks with the given context and arguments\n      fireWith: function fireWith(context, args) {\n        if (!_locked) {\n          args = args || [];\n          args = [context, args.slice ? args.slice() : args];\n          queue.push(args);\n\n          if (!firing) {\n            fire();\n          }\n        }\n\n        return this;\n      },\n      // Call all the callbacks with the given arguments\n      fire: function fire() {\n        self.fireWith(this, arguments);\n        return this;\n      },\n      // To know if the callbacks have already been called at least once\n      fired: function fired() {\n        return !!_fired;\n      }\n    };\n\n    return self;\n  };\n\n  function Identity(v) {\n    return v;\n  }\n\n  function Thrower(ex) {\n    throw ex;\n  }\n\n  function adoptValue(value, resolve, reject, noValue) {\n    var method;\n\n    try {\n      // Check for promise aspect first to privilege synchronous behavior\n      if (value && isFunction(method = value.promise)) {\n        method.call(value).done(resolve).fail(reject); // Other thenables\n      } else if (value && isFunction(method = value.then)) {\n        method.call(value, resolve, reject); // Other non-thenables\n      } else {\n        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n        // * false: [ value ].slice( 0 ) => resolve( value )\n        // * true: [ value ].slice( 1 ) => resolve()\n        resolve.apply(undefined, [value].slice(noValue));\n      } // For Promises/A+, convert exceptions into rejections\n      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n      // Deferred#then to conditionally suppress rejection.\n\n    } catch (value) {\n      // Support: Android 4.0 only\n      // Strict mode functions invoked without .call/.apply get global-object context\n      reject.apply(undefined, [value]);\n    }\n  }\n\n  jQuery.extend({\n    Deferred: function Deferred(func) {\n      var tuples = [// action, add listener, callbacks,\n      // ... .then handlers, argument index, [final state]\n      [\"notify\", \"progress\", jQuery.Callbacks(\"memory\"), jQuery.Callbacks(\"memory\"), 2], [\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), jQuery.Callbacks(\"once memory\"), 0, \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), jQuery.Callbacks(\"once memory\"), 1, \"rejected\"]],\n          _state = \"pending\",\n          _promise = {\n        state: function state() {\n          return _state;\n        },\n        always: function always() {\n          deferred.done(arguments).fail(arguments);\n          return this;\n        },\n        \"catch\": function _catch(fn) {\n          return _promise.then(null, fn);\n        },\n        // Keep pipe for back-compat\n        pipe: function\n          /* fnDone, fnFail, fnProgress */\n        pipe() {\n          var fns = arguments;\n          return jQuery.Deferred(function (newDefer) {\n            jQuery.each(tuples, function (_i, tuple) {\n              // Map tuples (progress, done, fail) to arguments (done, fail, progress)\n              var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })\n              // deferred.done(function() { bind to newDefer or newDefer.resolve })\n              // deferred.fail(function() { bind to newDefer or newDefer.reject })\n\n              deferred[tuple[1]](function () {\n                var returned = fn && fn.apply(this, arguments);\n\n                if (returned && isFunction(returned.promise)) {\n                  returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);\n                } else {\n                  newDefer[tuple[0] + \"With\"](this, fn ? [returned] : arguments);\n                }\n              });\n            });\n            fns = null;\n          }).promise();\n        },\n        then: function then(onFulfilled, onRejected, onProgress) {\n          var maxDepth = 0;\n\n          function resolve(depth, deferred, handler, special) {\n            return function () {\n              var that = this,\n                  args = arguments,\n                  mightThrow = function mightThrow() {\n                var returned, then; // Support: Promises/A+ section 2.3.3.3.3\n                // https://promisesaplus.com/#point-59\n                // Ignore double-resolution attempts\n\n                if (depth < maxDepth) {\n                  return;\n                }\n\n                returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1\n                // https://promisesaplus.com/#point-48\n\n                if (returned === deferred.promise()) {\n                  throw new TypeError(\"Thenable self-resolution\");\n                } // Support: Promises/A+ sections 2.3.3.1, 3.5\n                // https://promisesaplus.com/#point-54\n                // https://promisesaplus.com/#point-75\n                // Retrieve `then` only once\n\n\n                then = returned && ( // Support: Promises/A+ section 2.3.4\n                // https://promisesaplus.com/#point-64\n                // Only check objects and functions for thenability\n                _typeof(returned) === \"object\" || typeof returned === \"function\") && returned.then; // Handle a returned thenable\n\n                if (isFunction(then)) {\n                  // Special processors (notify) just wait for resolution\n                  if (special) {\n                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress\n                  } else {\n                    // ...and disregard older resolution values\n                    maxDepth++;\n                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));\n                  } // Handle all other returned values\n\n                } else {\n                  // Only substitute handlers pass on context\n                  // and multiple values (non-spec behavior)\n                  if (handler !== Identity) {\n                    that = undefined;\n                    args = [returned];\n                  } // Process the value(s)\n                  // Default process is resolve\n\n\n                  (special || deferred.resolveWith)(that, args);\n                }\n              },\n                  // Only normal processors (resolve) catch and reject exceptions\n              process = special ? mightThrow : function () {\n                try {\n                  mightThrow();\n                } catch (e) {\n                  if (jQuery.Deferred.exceptionHook) {\n                    jQuery.Deferred.exceptionHook(e, process.stackTrace);\n                  } // Support: Promises/A+ section 2.3.3.3.4.1\n                  // https://promisesaplus.com/#point-61\n                  // Ignore post-resolution exceptions\n\n\n                  if (depth + 1 >= maxDepth) {\n                    // Only substitute handlers pass on context\n                    // and multiple values (non-spec behavior)\n                    if (handler !== Thrower) {\n                      that = undefined;\n                      args = [e];\n                    }\n\n                    deferred.rejectWith(that, args);\n                  }\n                }\n              }; // Support: Promises/A+ section 2.3.3.3.1\n              // https://promisesaplus.com/#point-57\n              // Re-resolve promises immediately to dodge false rejection from\n              // subsequent errors\n\n\n              if (depth) {\n                process();\n              } else {\n                // Call an optional hook to record the stack, in case of exception\n                // since it's otherwise lost when execution goes async\n                if (jQuery.Deferred.getStackHook) {\n                  process.stackTrace = jQuery.Deferred.getStackHook();\n                }\n\n                window.setTimeout(process);\n              }\n            };\n          }\n\n          return jQuery.Deferred(function (newDefer) {\n            // progress_handlers.add( ... )\n            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )\n\n            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )\n\n            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));\n          }).promise();\n        },\n        // Get a promise for this deferred\n        // If obj is provided, the promise aspect is added to the object\n        promise: function promise(obj) {\n          return obj != null ? jQuery.extend(obj, _promise) : _promise;\n        }\n      },\n          deferred = {}; // Add list-specific methods\n\n      jQuery.each(tuples, function (i, tuple) {\n        var list = tuple[2],\n            stateString = tuple[5]; // promise.progress = list.add\n        // promise.done = list.add\n        // promise.fail = list.add\n\n        _promise[tuple[1]] = list.add; // Handle state\n\n        if (stateString) {\n          list.add(function () {\n            // state = \"resolved\" (i.e., fulfilled)\n            // state = \"rejected\"\n            _state = stateString;\n          }, // rejected_callbacks.disable\n          // fulfilled_callbacks.disable\n          tuples[3 - i][2].disable, // rejected_handlers.disable\n          // fulfilled_handlers.disable\n          tuples[3 - i][3].disable, // progress_callbacks.lock\n          tuples[0][2].lock, // progress_handlers.lock\n          tuples[0][3].lock);\n        } // progress_handlers.fire\n        // fulfilled_handlers.fire\n        // rejected_handlers.fire\n\n\n        list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }\n        // deferred.resolve = function() { deferred.resolveWith(...) }\n        // deferred.reject = function() { deferred.rejectWith(...) }\n\n        deferred[tuple[0]] = function () {\n          deferred[tuple[0] + \"With\"](this === deferred ? undefined : this, arguments);\n          return this;\n        }; // deferred.notifyWith = list.fireWith\n        // deferred.resolveWith = list.fireWith\n        // deferred.rejectWith = list.fireWith\n\n\n        deferred[tuple[0] + \"With\"] = list.fireWith;\n      }); // Make the deferred a promise\n\n      _promise.promise(deferred); // Call given func if any\n\n\n      if (func) {\n        func.call(deferred, deferred);\n      } // All done!\n\n\n      return deferred;\n    },\n    // Deferred helper\n    when: function when(singleValue) {\n      var // count of uncompleted subordinates\n      remaining = arguments.length,\n          // count of unprocessed arguments\n      i = remaining,\n          // subordinate fulfillment data\n      resolveContexts = Array(i),\n          resolveValues = _slice.call(arguments),\n          // the primary Deferred\n      primary = jQuery.Deferred(),\n          // subordinate callback factory\n      updateFunc = function updateFunc(i) {\n        return function (value) {\n          resolveContexts[i] = this;\n          resolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;\n\n          if (! --remaining) {\n            primary.resolveWith(resolveContexts, resolveValues);\n          }\n        };\n      }; // Single- and empty arguments are adopted like Promise.resolve\n\n\n      if (remaining <= 1) {\n        adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)\n\n        if (primary.state() === \"pending\" || isFunction(resolveValues[i] && resolveValues[i].then)) {\n          return primary.then();\n        }\n      } // Multiple arguments are aggregated like Promise.all array elements\n\n\n      while (i--) {\n        adoptValue(resolveValues[i], updateFunc(i), primary.reject);\n      }\n\n      return primary.promise();\n    }\n  }); // These usually indicate a programmer mistake during development,\n  // warn about them ASAP rather than swallowing them by default.\n\n  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\n  jQuery.Deferred.exceptionHook = function (error, stack) {\n    // Support: IE 8 - 9 only\n    // Console exists when dev tools are open, which can happen at any time\n    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {\n      window.console.warn(\"jQuery.Deferred exception: \" + error.message, error.stack, stack);\n    }\n  };\n\n  jQuery.readyException = function (error) {\n    window.setTimeout(function () {\n      throw error;\n    });\n  }; // The deferred used on DOM ready\n\n\n  var readyList = jQuery.Deferred();\n\n  jQuery.fn.ready = function (fn) {\n    readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup\n    // happens at the time of error handling instead of callback\n    // registration.\n    [\"catch\"](function (error) {\n      jQuery.readyException(error);\n    });\n    return this;\n  };\n\n  jQuery.extend({\n    // Is the DOM ready to be used? Set to true once it occurs.\n    isReady: false,\n    // A counter to track how many items to wait for before\n    // the ready event fires. See #6781\n    readyWait: 1,\n    // Handle when the DOM is ready\n    ready: function ready(wait) {\n      // Abort if there are pending holds or we're already ready\n      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n        return;\n      } // Remember that the DOM is ready\n\n\n      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be\n\n      if (wait !== true && --jQuery.readyWait > 0) {\n        return;\n      } // If there are functions bound, to execute\n\n\n      readyList.resolveWith(document, [jQuery]);\n    }\n  });\n  jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method\n\n  function completed() {\n    document.removeEventListener(\"DOMContentLoaded\", completed);\n    window.removeEventListener(\"load\", completed);\n    jQuery.ready();\n  } // Catch cases where $(document).ready() is called\n  // after the browser event has already occurred.\n  // Support: IE <=9 - 10 only\n  // Older IE sometimes signals \"interactive\" too soon\n\n\n  if (document.readyState === \"complete\" || document.readyState !== \"loading\" && !document.documentElement.doScroll) {\n    // Handle it asynchronously to allow scripts the opportunity to delay ready\n    window.setTimeout(jQuery.ready);\n  } else {\n    // Use the handy event callback\n    document.addEventListener(\"DOMContentLoaded\", completed); // A fallback to window.onload, that will always work\n\n    window.addEventListener(\"load\", completed);\n  } // Multifunctional method to get and set values of a collection\n  // The value/s can optionally be executed if it's a function\n\n\n  var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {\n    var i = 0,\n        len = elems.length,\n        bulk = key == null; // Sets many values\n\n    if (toType(key) === \"object\") {\n      chainable = true;\n\n      for (i in key) {\n        access(elems, fn, i, key[i], true, emptyGet, raw);\n      } // Sets one value\n\n    } else if (value !== undefined) {\n      chainable = true;\n\n      if (!isFunction(value)) {\n        raw = true;\n      }\n\n      if (bulk) {\n        // Bulk operations run against the entire set\n        if (raw) {\n          fn.call(elems, value);\n          fn = null; // ...except when executing function values\n        } else {\n          bulk = fn;\n\n          fn = function fn(elem, _key, value) {\n            return bulk.call(jQuery(elem), value);\n          };\n        }\n      }\n\n      if (fn) {\n        for (; i < len; i++) {\n          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\n        }\n      }\n    }\n\n    if (chainable) {\n      return elems;\n    } // Gets\n\n\n    if (bulk) {\n      return fn.call(elems);\n    }\n\n    return len ? fn(elems[0], key) : emptyGet;\n  }; // Matches dashed string for camelizing\n\n\n  var rmsPrefix = /^-ms-/,\n      rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()\n\n  function fcamelCase(_all, letter) {\n    return letter.toUpperCase();\n  } // Convert dashed to camelCase; used by the css and data modules\n  // Support: IE <=9 - 11, Edge 12 - 15\n  // Microsoft forgot to hump their vendor prefix (#9572)\n\n\n  function camelCase(string) {\n    return string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\n  }\n\n  var acceptData = function acceptData(owner) {\n    // Accepts only:\n    //  - Node\n    //    - Node.ELEMENT_NODE\n    //    - Node.DOCUMENT_NODE\n    //  - Object\n    //    - Any\n    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;\n  };\n\n  function Data() {\n    this.expando = jQuery.expando + Data.uid++;\n  }\n\n  Data.uid = 1;\n  Data.prototype = {\n    cache: function cache(owner) {\n      // Check if the owner object already has a cache\n      var value = owner[this.expando]; // If not, create one\n\n      if (!value) {\n        value = {}; // We can accept data for non-element nodes in modern browsers,\n        // but we should not, see #8335.\n        // Always return an empty object.\n\n        if (acceptData(owner)) {\n          // If it is a node unlikely to be stringify-ed or looped over\n          // use plain assignment\n          if (owner.nodeType) {\n            owner[this.expando] = value; // Otherwise secure it in a non-enumerable property\n            // configurable must be true to allow the property to be\n            // deleted when data is removed\n          } else {\n            Object.defineProperty(owner, this.expando, {\n              value: value,\n              configurable: true\n            });\n          }\n        }\n      }\n\n      return value;\n    },\n    set: function set(owner, data, value) {\n      var prop,\n          cache = this.cache(owner); // Handle: [ owner, key, value ] args\n      // Always use camelCase key (gh-2257)\n\n      if (typeof data === \"string\") {\n        cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args\n      } else {\n        // Copy the properties one-by-one to the cache object\n        for (prop in data) {\n          cache[camelCase(prop)] = data[prop];\n        }\n      }\n\n      return cache;\n    },\n    get: function get(owner, key) {\n      return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)\n      owner[this.expando] && owner[this.expando][camelCase(key)];\n    },\n    access: function access(owner, key, value) {\n      // In cases where either:\n      //\n      //   1. No key was specified\n      //   2. A string key was specified, but no value provided\n      //\n      // Take the \"read\" path and allow the get method to determine\n      // which value to return, respectively either:\n      //\n      //   1. The entire cache object\n      //   2. The data stored at the key\n      //\n      if (key === undefined || key && typeof key === \"string\" && value === undefined) {\n        return this.get(owner, key);\n      } // When the key is not a string, or both a key and value\n      // are specified, set or extend (existing objects) with either:\n      //\n      //   1. An object of properties\n      //   2. A key and value\n      //\n\n\n      this.set(owner, key, value); // Since the \"set\" path can have two possible entry points\n      // return the expected data based on which path was taken[*]\n\n      return value !== undefined ? value : key;\n    },\n    remove: function remove(owner, key) {\n      var i,\n          cache = owner[this.expando];\n\n      if (cache === undefined) {\n        return;\n      }\n\n      if (key !== undefined) {\n        // Support array or space separated string of keys\n        if (Array.isArray(key)) {\n          // If key is an array of keys...\n          // We always set camelCase keys, so remove that.\n          key = key.map(camelCase);\n        } else {\n          key = camelCase(key); // If a key with the spaces exists, use it.\n          // Otherwise, create an array by matching non-whitespace\n\n          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];\n        }\n\n        i = key.length;\n\n        while (i--) {\n          delete cache[key[i]];\n        }\n      } // Remove the expando if there's no more data\n\n\n      if (key === undefined || jQuery.isEmptyObject(cache)) {\n        // Support: Chrome <=35 - 45\n        // Webkit & Blink performance suffers when deleting properties\n        // from DOM nodes, so set to undefined instead\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n        if (owner.nodeType) {\n          owner[this.expando] = undefined;\n        } else {\n          delete owner[this.expando];\n        }\n      }\n    },\n    hasData: function hasData(owner) {\n      var cache = owner[this.expando];\n      return cache !== undefined && !jQuery.isEmptyObject(cache);\n    }\n  };\n  var dataPriv = new Data();\n  var dataUser = new Data(); //\tImplementation Summary\n  //\n  //\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n  //\t2. Improve the module's maintainability by reducing the storage\n  //\t\tpaths to a single mechanism.\n  //\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n  //\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n  //\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n  //\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\n  var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n      rmultiDash = /[A-Z]/g;\n\n  function getData(data) {\n    if (data === \"true\") {\n      return true;\n    }\n\n    if (data === \"false\") {\n      return false;\n    }\n\n    if (data === \"null\") {\n      return null;\n    } // Only convert to a number if it doesn't change the string\n\n\n    if (data === +data + \"\") {\n      return +data;\n    }\n\n    if (rbrace.test(data)) {\n      return JSON.parse(data);\n    }\n\n    return data;\n  }\n\n  function dataAttr(elem, key, data) {\n    var name; // If nothing was found internally, try to fetch any\n    // data from the HTML5 data-* attribute\n\n    if (data === undefined && elem.nodeType === 1) {\n      name = \"data-\" + key.replace(rmultiDash, \"-$&\").toLowerCase();\n      data = elem.getAttribute(name);\n\n      if (typeof data === \"string\") {\n        try {\n          data = getData(data);\n        } catch (e) {} // Make sure we set the data so it isn't changed later\n\n\n        dataUser.set(elem, key, data);\n      } else {\n        data = undefined;\n      }\n    }\n\n    return data;\n  }\n\n  jQuery.extend({\n    hasData: function hasData(elem) {\n      return dataUser.hasData(elem) || dataPriv.hasData(elem);\n    },\n    data: function data(elem, name, _data) {\n      return dataUser.access(elem, name, _data);\n    },\n    removeData: function removeData(elem, name) {\n      dataUser.remove(elem, name);\n    },\n    // TODO: Now that all calls to _data and _removeData have been replaced\n    // with direct calls to dataPriv methods, these can be deprecated.\n    _data: function _data(elem, name, data) {\n      return dataPriv.access(elem, name, data);\n    },\n    _removeData: function _removeData(elem, name) {\n      dataPriv.remove(elem, name);\n    }\n  });\n  jQuery.fn.extend({\n    data: function data(key, value) {\n      var i,\n          name,\n          data,\n          elem = this[0],\n          attrs = elem && elem.attributes; // Gets all values\n\n      if (key === undefined) {\n        if (this.length) {\n          data = dataUser.get(elem);\n\n          if (elem.nodeType === 1 && !dataPriv.get(elem, \"hasDataAttrs\")) {\n            i = attrs.length;\n\n            while (i--) {\n              // Support: IE 11 only\n              // The attrs elements can be null (#14894)\n              if (attrs[i]) {\n                name = attrs[i].name;\n\n                if (name.indexOf(\"data-\") === 0) {\n                  name = camelCase(name.slice(5));\n                  dataAttr(elem, name, data[name]);\n                }\n              }\n            }\n\n            dataPriv.set(elem, \"hasDataAttrs\", true);\n          }\n        }\n\n        return data;\n      } // Sets multiple values\n\n\n      if (_typeof(key) === \"object\") {\n        return this.each(function () {\n          dataUser.set(this, key);\n        });\n      }\n\n      return access(this, function (value) {\n        var data; // The calling jQuery object (element matches) is not empty\n        // (and therefore has an element appears at this[ 0 ]) and the\n        // `value` parameter was not undefined. An empty jQuery object\n        // will result in `undefined` for elem = this[ 0 ] which will\n        // throw an exception if an attempt to read a data cache is made.\n\n        if (elem && value === undefined) {\n          // Attempt to get data from the cache\n          // The key will always be camelCased in Data\n          data = dataUser.get(elem, key);\n\n          if (data !== undefined) {\n            return data;\n          } // Attempt to \"discover\" the data in\n          // HTML5 custom data-* attrs\n\n\n          data = dataAttr(elem, key);\n\n          if (data !== undefined) {\n            return data;\n          } // We tried really hard, but the data doesn't exist.\n\n\n          return;\n        } // Set the data...\n\n\n        this.each(function () {\n          // We always store the camelCased key\n          dataUser.set(this, key, value);\n        });\n      }, null, value, arguments.length > 1, null, true);\n    },\n    removeData: function removeData(key) {\n      return this.each(function () {\n        dataUser.remove(this, key);\n      });\n    }\n  });\n  jQuery.extend({\n    queue: function queue(elem, type, data) {\n      var queue;\n\n      if (elem) {\n        type = (type || \"fx\") + \"queue\";\n        queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup\n\n        if (data) {\n          if (!queue || Array.isArray(data)) {\n            queue = dataPriv.access(elem, type, jQuery.makeArray(data));\n          } else {\n            queue.push(data);\n          }\n        }\n\n        return queue || [];\n      }\n    },\n    dequeue: function dequeue(elem, type) {\n      type = type || \"fx\";\n\n      var queue = jQuery.queue(elem, type),\n          startLength = queue.length,\n          fn = queue.shift(),\n          hooks = jQuery._queueHooks(elem, type),\n          next = function next() {\n        jQuery.dequeue(elem, type);\n      }; // If the fx queue is dequeued, always remove the progress sentinel\n\n\n      if (fn === \"inprogress\") {\n        fn = queue.shift();\n        startLength--;\n      }\n\n      if (fn) {\n        // Add a progress sentinel to prevent the fx queue from being\n        // automatically dequeued\n        if (type === \"fx\") {\n          queue.unshift(\"inprogress\");\n        } // Clear up the last queue stop function\n\n\n        delete hooks.stop;\n        fn.call(elem, next, hooks);\n      }\n\n      if (!startLength && hooks) {\n        hooks.empty.fire();\n      }\n    },\n    // Not public - generate a queueHooks object, or return the current one\n    _queueHooks: function _queueHooks(elem, type) {\n      var key = type + \"queueHooks\";\n      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {\n        empty: jQuery.Callbacks(\"once memory\").add(function () {\n          dataPriv.remove(elem, [type + \"queue\", key]);\n        })\n      });\n    }\n  });\n  jQuery.fn.extend({\n    queue: function queue(type, data) {\n      var setter = 2;\n\n      if (typeof type !== \"string\") {\n        data = type;\n        type = \"fx\";\n        setter--;\n      }\n\n      if (arguments.length < setter) {\n        return jQuery.queue(this[0], type);\n      }\n\n      return data === undefined ? this : this.each(function () {\n        var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue\n\n        jQuery._queueHooks(this, type);\n\n        if (type === \"fx\" && queue[0] !== \"inprogress\") {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    dequeue: function dequeue(type) {\n      return this.each(function () {\n        jQuery.dequeue(this, type);\n      });\n    },\n    clearQueue: function clearQueue(type) {\n      return this.queue(type || \"fx\", []);\n    },\n    // Get a promise resolved when queues of a certain type\n    // are emptied (fx is the type by default)\n    promise: function promise(type, obj) {\n      var tmp,\n          count = 1,\n          defer = jQuery.Deferred(),\n          elements = this,\n          i = this.length,\n          resolve = function resolve() {\n        if (! --count) {\n          defer.resolveWith(elements, [elements]);\n        }\n      };\n\n      if (typeof type !== \"string\") {\n        obj = type;\n        type = undefined;\n      }\n\n      type = type || \"fx\";\n\n      while (i--) {\n        tmp = dataPriv.get(elements[i], type + \"queueHooks\");\n\n        if (tmp && tmp.empty) {\n          count++;\n          tmp.empty.add(resolve);\n        }\n      }\n\n      resolve();\n      return defer.promise(obj);\n    }\n  });\n  var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n  var rcssNum = new RegExp(\"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\");\n  var cssExpand = [\"Top\", \"Right\", \"Bottom\", \"Left\"];\n  var documentElement = document.documentElement;\n\n  var isAttached = function isAttached(elem) {\n    return jQuery.contains(elem.ownerDocument, elem);\n  },\n      composed = {\n    composed: true\n  }; // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n  // Check attachment across shadow DOM boundaries when possible (gh-3504)\n  // Support: iOS 10.0-10.2 only\n  // Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n  // leading to errors. We need to check for `getRootNode`.\n\n\n  if (documentElement.getRootNode) {\n    isAttached = function isAttached(elem) {\n      return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;\n    };\n  }\n\n  var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {\n    // isHiddenWithinTree might be called from jQuery#filter function;\n    // in that case, element will be second argument\n    elem = el || elem; // Inline style trumps all\n\n    return elem.style.display === \"none\" || elem.style.display === \"\" && // Otherwise, check computed style\n    // Support: Firefox <=43 - 45\n    // Disconnected elements can have computed display: none, so first confirm that elem is\n    // in the document.\n    isAttached(elem) && jQuery.css(elem, \"display\") === \"none\";\n  };\n\n  function adjustCSS(elem, prop, valueParts, tween) {\n    var adjusted,\n        scale,\n        maxIterations = 20,\n        currentValue = tween ? function () {\n      return tween.cur();\n    } : function () {\n      return jQuery.css(elem, prop, \"\");\n    },\n        initial = currentValue(),\n        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? \"\" : \"px\"),\n        // Starting value computation is required for potential unit mismatches\n    initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== \"px\" && +initial) && rcssNum.exec(jQuery.css(elem, prop));\n\n    if (initialInUnit && initialInUnit[3] !== unit) {\n      // Support: Firefox <=54\n      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n      initial = initial / 2; // Trust units reported by jQuery.css\n\n      unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point\n\n      initialInUnit = +initial || 1;\n\n      while (maxIterations--) {\n        // Evaluate and update our best guess (doubling guesses that zero out).\n        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n        jQuery.style(elem, prop, initialInUnit + unit);\n\n        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {\n          maxIterations = 0;\n        }\n\n        initialInUnit = initialInUnit / scale;\n      }\n\n      initialInUnit = initialInUnit * 2;\n      jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on\n\n      valueParts = valueParts || [];\n    }\n\n    if (valueParts) {\n      initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified\n\n      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];\n\n      if (tween) {\n        tween.unit = unit;\n        tween.start = initialInUnit;\n        tween.end = adjusted;\n      }\n    }\n\n    return adjusted;\n  }\n\n  var defaultDisplayMap = {};\n\n  function getDefaultDisplay(elem) {\n    var temp,\n        doc = elem.ownerDocument,\n        nodeName = elem.nodeName,\n        display = defaultDisplayMap[nodeName];\n\n    if (display) {\n      return display;\n    }\n\n    temp = doc.body.appendChild(doc.createElement(nodeName));\n    display = jQuery.css(temp, \"display\");\n    temp.parentNode.removeChild(temp);\n\n    if (display === \"none\") {\n      display = \"block\";\n    }\n\n    defaultDisplayMap[nodeName] = display;\n    return display;\n  }\n\n  function showHide(elements, show) {\n    var display,\n        elem,\n        values = [],\n        index = 0,\n        length = elements.length; // Determine new display value for elements that need to change\n\n    for (; index < length; index++) {\n      elem = elements[index];\n\n      if (!elem.style) {\n        continue;\n      }\n\n      display = elem.style.display;\n\n      if (show) {\n        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n        // check is required in this first loop unless we have a nonempty display value (either\n        // inline or about-to-be-restored)\n        if (display === \"none\") {\n          values[index] = dataPriv.get(elem, \"display\") || null;\n\n          if (!values[index]) {\n            elem.style.display = \"\";\n          }\n        }\n\n        if (elem.style.display === \"\" && isHiddenWithinTree(elem)) {\n          values[index] = getDefaultDisplay(elem);\n        }\n      } else {\n        if (display !== \"none\") {\n          values[index] = \"none\"; // Remember what we're overwriting\n\n          dataPriv.set(elem, \"display\", display);\n        }\n      }\n    } // Set the display of the elements in a second loop to avoid constant reflow\n\n\n    for (index = 0; index < length; index++) {\n      if (values[index] != null) {\n        elements[index].style.display = values[index];\n      }\n    }\n\n    return elements;\n  }\n\n  jQuery.fn.extend({\n    show: function show() {\n      return showHide(this, true);\n    },\n    hide: function hide() {\n      return showHide(this);\n    },\n    toggle: function toggle(state) {\n      if (typeof state === \"boolean\") {\n        return state ? this.show() : this.hide();\n      }\n\n      return this.each(function () {\n        if (isHiddenWithinTree(this)) {\n          jQuery(this).show();\n        } else {\n          jQuery(this).hide();\n        }\n      });\n    }\n  });\n  var rcheckableType = /^(?:checkbox|radio)$/i;\n  var rtagName = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i;\n  var rscriptType = /^$|^module$|\\/(?:java|ecma)script/i;\n\n  (function () {\n    var fragment = document.createDocumentFragment(),\n        div = fragment.appendChild(document.createElement(\"div\")),\n        input = document.createElement(\"input\"); // Support: Android 4.0 - 4.3 only\n    // Check state lost if the name is set (#11217)\n    // Support: Windows Web Apps (WWA)\n    // `name` and `type` must use .setAttribute for WWA (#14901)\n\n    input.setAttribute(\"type\", \"radio\");\n    input.setAttribute(\"checked\", \"checked\");\n    input.setAttribute(\"name\", \"t\");\n    div.appendChild(input); // Support: Android <=4.1 only\n    // Older WebKit doesn't clone checked state correctly in fragments\n\n    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only\n    // Make sure textarea (and checkbox) defaultValue is properly cloned\n\n    div.innerHTML = \"<textarea>x</textarea>\";\n    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue; // Support: IE <=9 only\n    // IE <=9 replaces <option> tags with their contents when inserted outside of\n    // the select element.\n\n    div.innerHTML = \"<option></option>\";\n    support.option = !!div.lastChild;\n  })(); // We have to close these tags to support XHTML (#13200)\n\n\n  var wrapMap = {\n    // XHTML parsers do not magically insert elements in the\n    // same way that tag soup parsers do. So we cannot shorten\n    // this by omitting <tbody> or other required elements.\n    thead: [1, \"<table>\", \"</table>\"],\n    col: [2, \"<table><colgroup>\", \"</colgroup></table>\"],\n    tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n    td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n    _default: [0, \"\", \"\"]\n  };\n  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n  wrapMap.th = wrapMap.td; // Support: IE <=9 only\n\n  if (!support.option) {\n    wrapMap.optgroup = wrapMap.option = [1, \"<select multiple='multiple'>\", \"</select>\"];\n  }\n\n  function getAll(context, tag) {\n    // Support: IE <=9 - 11 only\n    // Use typeof to avoid zero-argument method invocation on host objects (#15151)\n    var ret;\n\n    if (typeof context.getElementsByTagName !== \"undefined\") {\n      ret = context.getElementsByTagName(tag || \"*\");\n    } else if (typeof context.querySelectorAll !== \"undefined\") {\n      ret = context.querySelectorAll(tag || \"*\");\n    } else {\n      ret = [];\n    }\n\n    if (tag === undefined || tag && nodeName(context, tag)) {\n      return jQuery.merge([context], ret);\n    }\n\n    return ret;\n  } // Mark scripts as having already been evaluated\n\n\n  function setGlobalEval(elems, refElements) {\n    var i = 0,\n        l = elems.length;\n\n    for (; i < l; i++) {\n      dataPriv.set(elems[i], \"globalEval\", !refElements || dataPriv.get(refElements[i], \"globalEval\"));\n    }\n  }\n\n  var rhtml = /<|&#?\\w+;/;\n\n  function buildFragment(elems, context, scripts, selection, ignored) {\n    var elem,\n        tmp,\n        tag,\n        wrap,\n        attached,\n        j,\n        fragment = context.createDocumentFragment(),\n        nodes = [],\n        i = 0,\n        l = elems.length;\n\n    for (; i < l; i++) {\n      elem = elems[i];\n\n      if (elem || elem === 0) {\n        // Add nodes directly\n        if (toType(elem) === \"object\") {\n          // Support: Android <=4.0 only, PhantomJS 1 only\n          // push.apply(_, arraylike) throws on ancient WebKit\n          jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node\n        } else if (!rhtml.test(elem)) {\n          nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes\n        } else {\n          tmp = tmp || fragment.appendChild(context.createElement(\"div\")); // Deserialize a standard representation\n\n          tag = (rtagName.exec(elem) || [\"\", \"\"])[1].toLowerCase();\n          wrap = wrapMap[tag] || wrapMap._default;\n          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content\n\n          j = wrap[0];\n\n          while (j--) {\n            tmp = tmp.lastChild;\n          } // Support: Android <=4.0 only, PhantomJS 1 only\n          // push.apply(_, arraylike) throws on ancient WebKit\n\n\n          jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container\n\n          tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)\n\n          tmp.textContent = \"\";\n        }\n      }\n    } // Remove wrapper from fragment\n\n\n    fragment.textContent = \"\";\n    i = 0;\n\n    while (elem = nodes[i++]) {\n      // Skip elements already in the context collection (trac-4087)\n      if (selection && jQuery.inArray(elem, selection) > -1) {\n        if (ignored) {\n          ignored.push(elem);\n        }\n\n        continue;\n      }\n\n      attached = isAttached(elem); // Append to fragment\n\n      tmp = getAll(fragment.appendChild(elem), \"script\"); // Preserve script evaluation history\n\n      if (attached) {\n        setGlobalEval(tmp);\n      } // Capture executables\n\n\n      if (scripts) {\n        j = 0;\n\n        while (elem = tmp[j++]) {\n          if (rscriptType.test(elem.type || \"\")) {\n            scripts.push(elem);\n          }\n        }\n      }\n    }\n\n    return fragment;\n  }\n\n  var rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\n  function returnTrue() {\n    return true;\n  }\n\n  function returnFalse() {\n    return false;\n  } // Support: IE <=9 - 11+\n  // focus() and blur() are asynchronous, except when they are no-op.\n  // So expect focus to be synchronous when the element is already active,\n  // and blur to be synchronous when the element is not already active.\n  // (focus and blur are always synchronous in other supported browsers,\n  // this just defines when we can count on it).\n\n\n  function expectSync(elem, type) {\n    return elem === safeActiveElement() === (type === \"focus\");\n  } // Support: IE <=9 only\n  // Accessing document.activeElement can throw unexpectedly\n  // https://bugs.jquery.com/ticket/13393\n\n\n  function safeActiveElement() {\n    try {\n      return document.activeElement;\n    } catch (err) {}\n  }\n\n  function _on(elem, types, selector, data, fn, one) {\n    var origFn, type; // Types can be a map of types/handlers\n\n    if (_typeof(types) === \"object\") {\n      // ( types-Object, selector, data )\n      if (typeof selector !== \"string\") {\n        // ( types-Object, data )\n        data = data || selector;\n        selector = undefined;\n      }\n\n      for (type in types) {\n        _on(elem, type, selector, data, types[type], one);\n      }\n\n      return elem;\n    }\n\n    if (data == null && fn == null) {\n      // ( types, fn )\n      fn = selector;\n      data = selector = undefined;\n    } else if (fn == null) {\n      if (typeof selector === \"string\") {\n        // ( types, selector, fn )\n        fn = data;\n        data = undefined;\n      } else {\n        // ( types, data, fn )\n        fn = data;\n        data = selector;\n        selector = undefined;\n      }\n    }\n\n    if (fn === false) {\n      fn = returnFalse;\n    } else if (!fn) {\n      return elem;\n    }\n\n    if (one === 1) {\n      origFn = fn;\n\n      fn = function fn(event) {\n        // Can use an empty set, since event contains the info\n        jQuery().off(event);\n        return origFn.apply(this, arguments);\n      }; // Use same guid so caller can remove using origFn\n\n\n      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n    }\n\n    return elem.each(function () {\n      jQuery.event.add(this, types, fn, data, selector);\n    });\n  }\n  /*\n  * Helper functions for managing events -- not part of the public interface.\n  * Props to Dean Edwards' addEvent library for many of the ideas.\n  */\n\n\n  jQuery.event = {\n    global: {},\n    add: function add(elem, types, handler, data, selector) {\n      var handleObjIn,\n          eventHandle,\n          tmp,\n          events,\n          t,\n          handleObj,\n          special,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = dataPriv.get(elem); // Only attach events to objects that accept data\n\n      if (!acceptData(elem)) {\n        return;\n      } // Caller can pass in an object of custom data in lieu of the handler\n\n\n      if (handler.handler) {\n        handleObjIn = handler;\n        handler = handleObjIn.handler;\n        selector = handleObjIn.selector;\n      } // Ensure that invalid selectors throw exceptions at attach time\n      // Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\n\n      if (selector) {\n        jQuery.find.matchesSelector(documentElement, selector);\n      } // Make sure that the handler has a unique ID, used to find/remove it later\n\n\n      if (!handler.guid) {\n        handler.guid = jQuery.guid++;\n      } // Init the element's event structure and main handler, if this is the first\n\n\n      if (!(events = elemData.events)) {\n        events = elemData.events = Object.create(null);\n      }\n\n      if (!(eventHandle = elemData.handle)) {\n        eventHandle = elemData.handle = function (e) {\n          // Discard the second event of a jQuery.event.trigger() and\n          // when an event is called after a page has unloaded\n          return typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;\n        };\n      } // Handle multiple events separated by a space\n\n\n      types = (types || \"\").match(rnothtmlwhite) || [\"\"];\n      t = types.length;\n\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort(); // There *must* be a type, no attaching namespace-only handlers\n\n        if (!type) {\n          continue;\n        } // If event changes its type, use the special event handlers for the changed type\n\n\n        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type\n\n        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type\n\n        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers\n\n        handleObj = jQuery.extend({\n          type: type,\n          origType: origType,\n          data: data,\n          handler: handler,\n          guid: handler.guid,\n          selector: selector,\n          needsContext: selector && jQuery.expr.match.needsContext.test(selector),\n          namespace: namespaces.join(\".\")\n        }, handleObjIn); // Init the event handler queue if we're the first\n\n        if (!(handlers = events[type])) {\n          handlers = events[type] = [];\n          handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false\n\n          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n            if (elem.addEventListener) {\n              elem.addEventListener(type, eventHandle);\n            }\n          }\n        }\n\n        if (special.add) {\n          special.add.call(elem, handleObj);\n\n          if (!handleObj.handler.guid) {\n            handleObj.handler.guid = handler.guid;\n          }\n        } // Add to the element's handler list, delegates in front\n\n\n        if (selector) {\n          handlers.splice(handlers.delegateCount++, 0, handleObj);\n        } else {\n          handlers.push(handleObj);\n        } // Keep track of which events have ever been used, for event optimization\n\n\n        jQuery.event.global[type] = true;\n      }\n    },\n    // Detach an event or set of events from an element\n    remove: function remove(elem, types, handler, selector, mappedTypes) {\n      var j,\n          origCount,\n          tmp,\n          events,\n          t,\n          handleObj,\n          special,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);\n\n      if (!elemData || !(events = elemData.events)) {\n        return;\n      } // Once for each type.namespace in types; type may be omitted\n\n\n      types = (types || \"\").match(rnothtmlwhite) || [\"\"];\n      t = types.length;\n\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort(); // Unbind all events (on this namespace, if provided) for the element\n\n        if (!type) {\n          for (type in events) {\n            jQuery.event.remove(elem, type + types[t], handler, selector, true);\n          }\n\n          continue;\n        }\n\n        special = jQuery.event.special[type] || {};\n        type = (selector ? special.delegateType : special.bindType) || type;\n        handlers = events[type] || [];\n        tmp = tmp[2] && new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"); // Remove matching events\n\n        origCount = j = handlers.length;\n\n        while (j--) {\n          handleObj = handlers[j];\n\n          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector)) {\n            handlers.splice(j, 1);\n\n            if (handleObj.selector) {\n              handlers.delegateCount--;\n            }\n\n            if (special.remove) {\n              special.remove.call(elem, handleObj);\n            }\n          }\n        } // Remove generic event handler if we removed something and no more handlers exist\n        // (avoids potential for endless recursion during removal of special event handlers)\n\n\n        if (origCount && !handlers.length) {\n          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n            jQuery.removeEvent(elem, type, elemData.handle);\n          }\n\n          delete events[type];\n        }\n      } // Remove data and the expando if it's no longer used\n\n\n      if (jQuery.isEmptyObject(events)) {\n        dataPriv.remove(elem, \"handle events\");\n      }\n    },\n    dispatch: function dispatch(nativeEvent) {\n      var i,\n          j,\n          ret,\n          matched,\n          handleObj,\n          handlerQueue,\n          args = new Array(arguments.length),\n          // Make a writable jQuery.Event from the native event object\n      event = jQuery.event.fix(nativeEvent),\n          handlers = (dataPriv.get(this, \"events\") || Object.create(null))[event.type] || [],\n          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event\n\n      args[0] = event;\n\n      for (i = 1; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n\n      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired\n\n      if (special.preDispatch && special.preDispatch.call(this, event) === false) {\n        return;\n      } // Determine handlers\n\n\n      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us\n\n      i = 0;\n\n      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n        event.currentTarget = matched.elem;\n        j = 0;\n\n        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n          // If the event is namespaced, then each handler is only invoked if it is\n          // specially universal or its namespaces are a superset of the event's.\n          if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {\n            event.handleObj = handleObj;\n            event.data = handleObj.data;\n            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n\n            if (ret !== undefined) {\n              if ((event.result = ret) === false) {\n                event.preventDefault();\n                event.stopPropagation();\n              }\n            }\n          }\n        }\n      } // Call the postDispatch hook for the mapped type\n\n\n      if (special.postDispatch) {\n        special.postDispatch.call(this, event);\n      }\n\n      return event.result;\n    },\n    handlers: function handlers(event, _handlers) {\n      var i,\n          handleObj,\n          sel,\n          matchedHandlers,\n          matchedSelectors,\n          handlerQueue = [],\n          delegateCount = _handlers.delegateCount,\n          cur = event.target; // Find delegate handlers\n\n      if (delegateCount && // Support: IE <=9\n      // Black-hole SVG <use> instance trees (trac-13180)\n      cur.nodeType && // Support: Firefox <=42\n      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n      // Support: IE 11 only\n      // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n      !(event.type === \"click\" && event.button >= 1)) {\n        for (; cur !== this; cur = cur.parentNode || this) {\n          // Don't check non-elements (#13208)\n          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n          if (cur.nodeType === 1 && !(event.type === \"click\" && cur.disabled === true)) {\n            matchedHandlers = [];\n            matchedSelectors = {};\n\n            for (i = 0; i < delegateCount; i++) {\n              handleObj = _handlers[i]; // Don't conflict with Object.prototype properties (#13203)\n\n              sel = handleObj.selector + \" \";\n\n              if (matchedSelectors[sel] === undefined) {\n                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;\n              }\n\n              if (matchedSelectors[sel]) {\n                matchedHandlers.push(handleObj);\n              }\n            }\n\n            if (matchedHandlers.length) {\n              handlerQueue.push({\n                elem: cur,\n                handlers: matchedHandlers\n              });\n            }\n          }\n        }\n      } // Add the remaining (directly-bound) handlers\n\n\n      cur = this;\n\n      if (delegateCount < _handlers.length) {\n        handlerQueue.push({\n          elem: cur,\n          handlers: _handlers.slice(delegateCount)\n        });\n      }\n\n      return handlerQueue;\n    },\n    addProp: function addProp(name, hook) {\n      Object.defineProperty(jQuery.Event.prototype, name, {\n        enumerable: true,\n        configurable: true,\n        get: isFunction(hook) ? function () {\n          if (this.originalEvent) {\n            return hook(this.originalEvent);\n          }\n        } : function () {\n          if (this.originalEvent) {\n            return this.originalEvent[name];\n          }\n        },\n        set: function set(value) {\n          Object.defineProperty(this, name, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: value\n          });\n        }\n      });\n    },\n    fix: function fix(originalEvent) {\n      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);\n    },\n    special: {\n      load: {\n        // Prevent triggered image.load events from bubbling to window.load\n        noBubble: true\n      },\n      click: {\n        // Utilize native event to ensure correct state for checkable inputs\n        setup: function setup(data) {\n          // For mutual compressibility with _default, replace `this` access with a local var.\n          // `|| data` is dead code meant only to preserve the variable through minification.\n          var el = this || data; // Claim the first handler\n\n          if (rcheckableType.test(el.type) && el.click && nodeName(el, \"input\")) {\n            // dataPriv.set( el, \"click\", ... )\n            leverageNative(el, \"click\", returnTrue);\n          } // Return false to allow normal processing in the caller\n\n\n          return false;\n        },\n        trigger: function trigger(data) {\n          // For mutual compressibility with _default, replace `this` access with a local var.\n          // `|| data` is dead code meant only to preserve the variable through minification.\n          var el = this || data; // Force setup before triggering a click\n\n          if (rcheckableType.test(el.type) && el.click && nodeName(el, \"input\")) {\n            leverageNative(el, \"click\");\n          } // Return non-false to allow normal event-path propagation\n\n\n          return true;\n        },\n        // For cross-browser consistency, suppress native .click() on links\n        // Also prevent it if we're currently inside a leveraged native-event stack\n        _default: function _default(event) {\n          var target = event.target;\n          return rcheckableType.test(target.type) && target.click && nodeName(target, \"input\") && dataPriv.get(target, \"click\") || nodeName(target, \"a\");\n        }\n      },\n      beforeunload: {\n        postDispatch: function postDispatch(event) {\n          // Support: Firefox 20+\n          // Firefox doesn't alert if the returnValue field is not set.\n          if (event.result !== undefined && event.originalEvent) {\n            event.originalEvent.returnValue = event.result;\n          }\n        }\n      }\n    }\n  }; // Ensure the presence of an event listener that handles manually-triggered\n  // synthetic events by interrupting progress until reinvoked in response to\n  // *native* events that it fires directly, ensuring that state changes have\n  // already occurred before other listeners are invoked.\n\n  function leverageNative(el, type, expectSync) {\n    // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\n    if (!expectSync) {\n      if (dataPriv.get(el, type) === undefined) {\n        jQuery.event.add(el, type, returnTrue);\n      }\n\n      return;\n    } // Register the controller as a special universal handler for all event namespaces\n\n\n    dataPriv.set(el, type, false);\n    jQuery.event.add(el, type, {\n      namespace: false,\n      handler: function handler(event) {\n        var notAsync,\n            result,\n            saved = dataPriv.get(this, type);\n\n        if (event.isTrigger & 1 && this[type]) {\n          // Interrupt processing of the outer synthetic .trigger()ed event\n          // Saved data should be false in such cases, but might be a leftover capture object\n          // from an async native handler (gh-4350)\n          if (!saved.length) {\n            // Store arguments for use when handling the inner native event\n            // There will always be at least one argument (an event object), so this array\n            // will not be confused with a leftover capture object.\n            saved = _slice.call(arguments);\n            dataPriv.set(this, type, saved); // Trigger the native event and capture its result\n            // Support: IE <=9 - 11+\n            // focus() and blur() are asynchronous\n\n            notAsync = expectSync(this, type);\n            this[type]();\n            result = dataPriv.get(this, type);\n\n            if (saved !== result || notAsync) {\n              dataPriv.set(this, type, false);\n            } else {\n              result = {};\n            }\n\n            if (saved !== result) {\n              // Cancel the outer synthetic event\n              event.stopImmediatePropagation();\n              event.preventDefault(); // Support: Chrome 86+\n              // In Chrome, if an element having a focusout handler is blurred by\n              // clicking outside of it, it invokes the handler synchronously. If\n              // that handler calls `.remove()` on the element, the data is cleared,\n              // leaving `result` undefined. We need to guard against this.\n\n              return result && result.value;\n            } // If this is an inner synthetic event for an event with a bubbling surrogate\n            // (focus or blur), assume that the surrogate already propagated from triggering the\n            // native event and prevent that from happening again here.\n            // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n            // bubbling surrogate propagates *after* the non-bubbling base), but that seems\n            // less bad than duplication.\n\n          } else if ((jQuery.event.special[type] || {}).delegateType) {\n            event.stopPropagation();\n          } // If this is a native event triggered above, everything is now in order\n          // Fire an inner synthetic event with the original arguments\n\n        } else if (saved.length) {\n          // ...and capture the result\n          dataPriv.set(this, type, {\n            value: jQuery.event.trigger( // Support: IE <=9 - 11+\n            // Extend with the prototype to reset the above stopImmediatePropagation()\n            jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)\n          }); // Abort handling of the native event\n\n          event.stopImmediatePropagation();\n        }\n      }\n    });\n  }\n\n  jQuery.removeEvent = function (elem, type, handle) {\n    // This \"if\" is needed for plain objects\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, handle);\n    }\n  };\n\n  jQuery.Event = function (src, props) {\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof jQuery.Event)) {\n      return new jQuery.Event(src, props);\n    } // Event object\n\n\n    if (src && src.type) {\n      this.originalEvent = src;\n      this.type = src.type; // Events bubbling up the document may have been marked as prevented\n      // by a handler lower down the tree; reflect the correct value.\n\n      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only\n      src.returnValue === false ? returnTrue : returnFalse; // Create target properties\n      // Support: Safari <=6 - 7 only\n      // Target should not be a text node (#504, #13143)\n\n      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;\n      this.currentTarget = src.currentTarget;\n      this.relatedTarget = src.relatedTarget; // Event type\n    } else {\n      this.type = src;\n    } // Put explicitly provided properties onto the event object\n\n\n    if (props) {\n      jQuery.extend(this, props);\n    } // Create a timestamp if incoming event doesn't have one\n\n\n    this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed\n\n    this[jQuery.expando] = true;\n  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\n\n  jQuery.Event.prototype = {\n    constructor: jQuery.Event,\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse,\n    isSimulated: false,\n    preventDefault: function preventDefault() {\n      var e = this.originalEvent;\n      this.isDefaultPrevented = returnTrue;\n\n      if (e && !this.isSimulated) {\n        e.preventDefault();\n      }\n    },\n    stopPropagation: function stopPropagation() {\n      var e = this.originalEvent;\n      this.isPropagationStopped = returnTrue;\n\n      if (e && !this.isSimulated) {\n        e.stopPropagation();\n      }\n    },\n    stopImmediatePropagation: function stopImmediatePropagation() {\n      var e = this.originalEvent;\n      this.isImmediatePropagationStopped = returnTrue;\n\n      if (e && !this.isSimulated) {\n        e.stopImmediatePropagation();\n      }\n\n      this.stopPropagation();\n    }\n  }; // Includes all common event props including KeyEvent and MouseEvent specific props\n\n  jQuery.each({\n    altKey: true,\n    bubbles: true,\n    cancelable: true,\n    changedTouches: true,\n    ctrlKey: true,\n    detail: true,\n    eventPhase: true,\n    metaKey: true,\n    pageX: true,\n    pageY: true,\n    shiftKey: true,\n    view: true,\n    \"char\": true,\n    code: true,\n    charCode: true,\n    key: true,\n    keyCode: true,\n    button: true,\n    buttons: true,\n    clientX: true,\n    clientY: true,\n    offsetX: true,\n    offsetY: true,\n    pointerId: true,\n    pointerType: true,\n    screenX: true,\n    screenY: true,\n    targetTouches: true,\n    toElement: true,\n    touches: true,\n    which: true\n  }, jQuery.event.addProp);\n  jQuery.each({\n    focus: \"focusin\",\n    blur: \"focusout\"\n  }, function (type, delegateType) {\n    jQuery.event.special[type] = {\n      // Utilize native event if possible so blur/focus sequence is correct\n      setup: function setup() {\n        // Claim the first handler\n        // dataPriv.set( this, \"focus\", ... )\n        // dataPriv.set( this, \"blur\", ... )\n        leverageNative(this, type, expectSync); // Return false to allow normal processing in the caller\n\n        return false;\n      },\n      trigger: function trigger() {\n        // Force setup before trigger\n        leverageNative(this, type); // Return non-false to allow normal event-path propagation\n\n        return true;\n      },\n      // Suppress native focus or blur as it's already being fired\n      // in leverageNative.\n      _default: function _default() {\n        return true;\n      },\n      delegateType: delegateType\n    };\n  }); // Create mouseenter/leave events using mouseover/out and event-time checks\n  // so that event delegation works in jQuery.\n  // Do the same for pointerenter/pointerleave and pointerover/pointerout\n  //\n  // Support: Safari 7 only\n  // Safari sends mouseenter too often; see:\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n  // for the description of the bug (it existed in older Chrome versions as well).\n\n  jQuery.each({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\",\n    pointerenter: \"pointerover\",\n    pointerleave: \"pointerout\"\n  }, function (orig, fix) {\n    jQuery.event.special[orig] = {\n      delegateType: fix,\n      bindType: fix,\n      handle: function handle(event) {\n        var ret,\n            target = this,\n            related = event.relatedTarget,\n            handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.\n        // NB: No relatedTarget if the mouse left/entered the browser window\n\n        if (!related || related !== target && !jQuery.contains(target, related)) {\n          event.type = handleObj.origType;\n          ret = handleObj.handler.apply(this, arguments);\n          event.type = fix;\n        }\n\n        return ret;\n      }\n    };\n  });\n  jQuery.fn.extend({\n    on: function on(types, selector, data, fn) {\n      return _on(this, types, selector, data, fn);\n    },\n    one: function one(types, selector, data, fn) {\n      return _on(this, types, selector, data, fn, 1);\n    },\n    off: function off(types, selector, fn) {\n      var handleObj, type;\n\n      if (types && types.preventDefault && types.handleObj) {\n        // ( event )  dispatched jQuery.Event\n        handleObj = types.handleObj;\n        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n        return this;\n      }\n\n      if (_typeof(types) === \"object\") {\n        // ( types-object [, selector] )\n        for (type in types) {\n          this.off(type, selector, types[type]);\n        }\n\n        return this;\n      }\n\n      if (selector === false || typeof selector === \"function\") {\n        // ( types [, fn] )\n        fn = selector;\n        selector = undefined;\n      }\n\n      if (fn === false) {\n        fn = returnFalse;\n      }\n\n      return this.each(function () {\n        jQuery.event.remove(this, types, fn, selector);\n      });\n    }\n  });\n  var // Support: IE <=10 - 11, Edge 12 - 13 only\n  // In IE/Edge using regex groups here causes severe slowdowns.\n  // See https://connect.microsoft.com/IE/feedback/details/1736512/\n  rnoInnerhtml = /<script|<style|<link/i,\n      // checked=\"checked\" or checked\n  rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n      rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g; // Prefer a tbody over its parent table for containing new rows\n\n  function manipulationTarget(elem, content) {\n    if (nodeName(elem, \"table\") && nodeName(content.nodeType !== 11 ? content : content.firstChild, \"tr\")) {\n      return jQuery(elem).children(\"tbody\")[0] || elem;\n    }\n\n    return elem;\n  } // Replace/restore the type attribute of script elements for safe DOM manipulation\n\n\n  function disableScript(elem) {\n    elem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n    return elem;\n  }\n\n  function restoreScript(elem) {\n    if ((elem.type || \"\").slice(0, 5) === \"true/\") {\n      elem.type = elem.type.slice(5);\n    } else {\n      elem.removeAttribute(\"type\");\n    }\n\n    return elem;\n  }\n\n  function cloneCopyEvent(src, dest) {\n    var i, l, type, pdataOld, udataOld, udataCur, events;\n\n    if (dest.nodeType !== 1) {\n      return;\n    } // 1. Copy private data: events, handlers, etc.\n\n\n    if (dataPriv.hasData(src)) {\n      pdataOld = dataPriv.get(src);\n      events = pdataOld.events;\n\n      if (events) {\n        dataPriv.remove(dest, \"handle events\");\n\n        for (type in events) {\n          for (i = 0, l = events[type].length; i < l; i++) {\n            jQuery.event.add(dest, type, events[type][i]);\n          }\n        }\n      }\n    } // 2. Copy user data\n\n\n    if (dataUser.hasData(src)) {\n      udataOld = dataUser.access(src);\n      udataCur = jQuery.extend({}, udataOld);\n      dataUser.set(dest, udataCur);\n    }\n  } // Fix IE bugs, see support tests\n\n\n  function fixInput(src, dest) {\n    var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.\n\n    if (nodeName === \"input\" && rcheckableType.test(src.type)) {\n      dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options\n    } else if (nodeName === \"input\" || nodeName === \"textarea\") {\n      dest.defaultValue = src.defaultValue;\n    }\n  }\n\n  function domManip(collection, args, callback, ignored) {\n    // Flatten any nested arrays\n    args = flat(args);\n    var fragment,\n        first,\n        scripts,\n        hasScripts,\n        node,\n        doc,\n        i = 0,\n        l = collection.length,\n        iNoClone = l - 1,\n        value = args[0],\n        valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit\n\n    if (valueIsFunction || l > 1 && typeof value === \"string\" && !support.checkClone && rchecked.test(value)) {\n      return collection.each(function (index) {\n        var self = collection.eq(index);\n\n        if (valueIsFunction) {\n          args[0] = value.call(this, index, self.html());\n        }\n\n        domManip(self, args, callback, ignored);\n      });\n    }\n\n    if (l) {\n      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);\n      first = fragment.firstChild;\n\n      if (fragment.childNodes.length === 1) {\n        fragment = first;\n      } // Require either new content or an interest in ignored elements to invoke the callback\n\n\n      if (first || ignored) {\n        scripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\n        hasScripts = scripts.length; // Use the original fragment for the last item\n        // instead of the first because it can end up\n        // being emptied incorrectly in certain situations (#8070).\n\n        for (; i < l; i++) {\n          node = fragment;\n\n          if (i !== iNoClone) {\n            node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration\n\n            if (hasScripts) {\n              // Support: Android <=4.0 only, PhantomJS 1 only\n              // push.apply(_, arraylike) throws on ancient WebKit\n              jQuery.merge(scripts, getAll(node, \"script\"));\n            }\n          }\n\n          callback.call(collection[i], node, i);\n        }\n\n        if (hasScripts) {\n          doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts\n\n          jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion\n\n          for (i = 0; i < hasScripts; i++) {\n            node = scripts[i];\n\n            if (rscriptType.test(node.type || \"\") && !dataPriv.access(node, \"globalEval\") && jQuery.contains(doc, node)) {\n              if (node.src && (node.type || \"\").toLowerCase() !== \"module\") {\n                // Optional AJAX dependency, but won't run scripts if not present\n                if (jQuery._evalUrl && !node.noModule) {\n                  jQuery._evalUrl(node.src, {\n                    nonce: node.nonce || node.getAttribute(\"nonce\")\n                  }, doc);\n                }\n              } else {\n                DOMEval(node.textContent.replace(rcleanScript, \"\"), node, doc);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return collection;\n  }\n\n  function _remove(elem, selector, keepData) {\n    var node,\n        nodes = selector ? jQuery.filter(selector, elem) : elem,\n        i = 0;\n\n    for (; (node = nodes[i]) != null; i++) {\n      if (!keepData && node.nodeType === 1) {\n        jQuery.cleanData(getAll(node));\n      }\n\n      if (node.parentNode) {\n        if (keepData && isAttached(node)) {\n          setGlobalEval(getAll(node, \"script\"));\n        }\n\n        node.parentNode.removeChild(node);\n      }\n    }\n\n    return elem;\n  }\n\n  jQuery.extend({\n    htmlPrefilter: function htmlPrefilter(html) {\n      return html;\n    },\n    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {\n      var i,\n          l,\n          srcElements,\n          destElements,\n          clone = elem.cloneNode(true),\n          inPage = isAttached(elem); // Fix IE cloning issues\n\n      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n        destElements = getAll(clone);\n        srcElements = getAll(elem);\n\n        for (i = 0, l = srcElements.length; i < l; i++) {\n          fixInput(srcElements[i], destElements[i]);\n        }\n      } // Copy the events from the original to the clone\n\n\n      if (dataAndEvents) {\n        if (deepDataAndEvents) {\n          srcElements = srcElements || getAll(elem);\n          destElements = destElements || getAll(clone);\n\n          for (i = 0, l = srcElements.length; i < l; i++) {\n            cloneCopyEvent(srcElements[i], destElements[i]);\n          }\n        } else {\n          cloneCopyEvent(elem, clone);\n        }\n      } // Preserve script evaluation history\n\n\n      destElements = getAll(clone, \"script\");\n\n      if (destElements.length > 0) {\n        setGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\n      } // Return the cloned set\n\n\n      return clone;\n    },\n    cleanData: function cleanData(elems) {\n      var data,\n          elem,\n          type,\n          special = jQuery.event.special,\n          i = 0;\n\n      for (; (elem = elems[i]) !== undefined; i++) {\n        if (acceptData(elem)) {\n          if (data = elem[dataPriv.expando]) {\n            if (data.events) {\n              for (type in data.events) {\n                if (special[type]) {\n                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead\n                } else {\n                  jQuery.removeEvent(elem, type, data.handle);\n                }\n              }\n            } // Support: Chrome <=35 - 45+\n            // Assign undefined instead of using delete, see Data#remove\n\n\n            elem[dataPriv.expando] = undefined;\n          }\n\n          if (elem[dataUser.expando]) {\n            // Support: Chrome <=35 - 45+\n            // Assign undefined instead of using delete, see Data#remove\n            elem[dataUser.expando] = undefined;\n          }\n        }\n      }\n    }\n  });\n  jQuery.fn.extend({\n    detach: function detach(selector) {\n      return _remove(this, selector, true);\n    },\n    remove: function remove(selector) {\n      return _remove(this, selector);\n    },\n    text: function text(value) {\n      return access(this, function (value) {\n        return value === undefined ? jQuery.text(this) : this.empty().each(function () {\n          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n            this.textContent = value;\n          }\n        });\n      }, null, value, arguments.length);\n    },\n    append: function append() {\n      return domManip(this, arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem);\n          target.appendChild(elem);\n        }\n      });\n    },\n    prepend: function prepend() {\n      return domManip(this, arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem);\n          target.insertBefore(elem, target.firstChild);\n        }\n      });\n    },\n    before: function before() {\n      return domManip(this, arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this);\n        }\n      });\n    },\n    after: function after() {\n      return domManip(this, arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this.nextSibling);\n        }\n      });\n    },\n    empty: function empty() {\n      var elem,\n          i = 0;\n\n      for (; (elem = this[i]) != null; i++) {\n        if (elem.nodeType === 1) {\n          // Prevent memory leaks\n          jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes\n\n          elem.textContent = \"\";\n        }\n      }\n\n      return this;\n    },\n    clone: function clone(dataAndEvents, deepDataAndEvents) {\n      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n      return this.map(function () {\n        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n      });\n    },\n    html: function html(value) {\n      return access(this, function (value) {\n        var elem = this[0] || {},\n            i = 0,\n            l = this.length;\n\n        if (value === undefined && elem.nodeType === 1) {\n          return elem.innerHTML;\n        } // See if we can take a shortcut and just use innerHTML\n\n\n        if (typeof value === \"string\" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [\"\", \"\"])[1].toLowerCase()]) {\n          value = jQuery.htmlPrefilter(value);\n\n          try {\n            for (; i < l; i++) {\n              elem = this[i] || {}; // Remove element nodes and prevent memory leaks\n\n              if (elem.nodeType === 1) {\n                jQuery.cleanData(getAll(elem, false));\n                elem.innerHTML = value;\n              }\n            }\n\n            elem = 0; // If using innerHTML throws an exception, use the fallback method\n          } catch (e) {}\n        }\n\n        if (elem) {\n          this.empty().append(value);\n        }\n      }, null, value, arguments.length);\n    },\n    replaceWith: function replaceWith() {\n      var ignored = []; // Make the changes, replacing each non-ignored context element with the new content\n\n      return domManip(this, arguments, function (elem) {\n        var parent = this.parentNode;\n\n        if (jQuery.inArray(this, ignored) < 0) {\n          jQuery.cleanData(getAll(this));\n\n          if (parent) {\n            parent.replaceChild(elem, this);\n          }\n        } // Force callback invocation\n\n      }, ignored);\n    }\n  });\n  jQuery.each({\n    appendTo: \"append\",\n    prependTo: \"prepend\",\n    insertBefore: \"before\",\n    insertAfter: \"after\",\n    replaceAll: \"replaceWith\"\n  }, function (name, original) {\n    jQuery.fn[name] = function (selector) {\n      var elems,\n          ret = [],\n          insert = jQuery(selector),\n          last = insert.length - 1,\n          i = 0;\n\n      for (; i <= last; i++) {\n        elems = i === last ? this : this.clone(true);\n        jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only\n        // .get() because push.apply(_, arraylike) throws on ancient WebKit\n\n        push.apply(ret, elems.get());\n      }\n\n      return this.pushStack(ret);\n    };\n  });\n  var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n\n  var getStyles = function getStyles(elem) {\n    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n    // IE throws on elements created in popups\n    // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n    var view = elem.ownerDocument.defaultView;\n\n    if (!view || !view.opener) {\n      view = window;\n    }\n\n    return view.getComputedStyle(elem);\n  };\n\n  var swap = function swap(elem, options, callback) {\n    var ret,\n        name,\n        old = {}; // Remember the old values, and insert the new ones\n\n    for (name in options) {\n      old[name] = elem.style[name];\n      elem.style[name] = options[name];\n    }\n\n    ret = callback.call(elem); // Revert the old values\n\n    for (name in options) {\n      elem.style[name] = old[name];\n    }\n\n    return ret;\n  };\n\n  var rboxStyle = new RegExp(cssExpand.join(\"|\"), \"i\");\n\n  (function () {\n    // Executing both pixelPosition & boxSizingReliable tests require only one layout\n    // so they're executed at the same time to save the second computation.\n    function computeStyleTests() {\n      // This is a singleton, we need to execute it only once\n      if (!div) {\n        return;\n      }\n\n      container.style.cssText = \"position:absolute;left:-11111px;width:60px;\" + \"margin-top:1px;padding:0;border:0\";\n      div.style.cssText = \"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" + \"margin:auto;border:1px;padding:1px;\" + \"width:60%;top:1%\";\n      documentElement.appendChild(container).appendChild(div);\n      var divStyle = window.getComputedStyle(div);\n      pixelPositionVal = divStyle.top !== \"1%\"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\n      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n      // Some styles come back with percentage values, even though they shouldn't\n\n      div.style.right = \"60%\";\n      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only\n      // Detect misreporting of content dimensions for box-sizing:border-box elements\n\n      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only\n      // Detect overflow:scroll screwiness (gh-3699)\n      // Support: Chrome <=64\n      // Don't get tricked when zoom affects offsetWidth (gh-4029)\n\n      div.style.position = \"absolute\";\n      scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;\n      documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and\n      // it will also be a sign that checks already performed\n\n      div = null;\n    }\n\n    function roundPixelMeasures(measure) {\n      return Math.round(parseFloat(measure));\n    }\n\n    var pixelPositionVal,\n        boxSizingReliableVal,\n        scrollboxSizeVal,\n        pixelBoxStylesVal,\n        reliableTrDimensionsVal,\n        reliableMarginLeftVal,\n        container = document.createElement(\"div\"),\n        div = document.createElement(\"div\"); // Finish early in limited (non-browser) environments\n\n    if (!div.style) {\n      return;\n    } // Support: IE <=9 - 11 only\n    // Style of cloned element affects source element cloned (#8908)\n\n\n    div.style.backgroundClip = \"content-box\";\n    div.cloneNode(true).style.backgroundClip = \"\";\n    support.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n    jQuery.extend(support, {\n      boxSizingReliable: function boxSizingReliable() {\n        computeStyleTests();\n        return boxSizingReliableVal;\n      },\n      pixelBoxStyles: function pixelBoxStyles() {\n        computeStyleTests();\n        return pixelBoxStylesVal;\n      },\n      pixelPosition: function pixelPosition() {\n        computeStyleTests();\n        return pixelPositionVal;\n      },\n      reliableMarginLeft: function reliableMarginLeft() {\n        computeStyleTests();\n        return reliableMarginLeftVal;\n      },\n      scrollboxSize: function scrollboxSize() {\n        computeStyleTests();\n        return scrollboxSizeVal;\n      },\n      // Support: IE 9 - 11+, Edge 15 - 18+\n      // IE/Edge misreport `getComputedStyle` of table rows with width/height\n      // set in CSS while `offset*` properties report correct values.\n      // Behavior in IE 9 is more subtle than in newer versions & it passes\n      // some versions of this test; make sure not to make it pass there!\n      //\n      // Support: Firefox 70+\n      // Only Firefox includes border widths\n      // in computed dimensions. (gh-4529)\n      reliableTrDimensions: function reliableTrDimensions() {\n        var table, tr, trChild, trStyle;\n\n        if (reliableTrDimensionsVal == null) {\n          table = document.createElement(\"table\");\n          tr = document.createElement(\"tr\");\n          trChild = document.createElement(\"div\");\n          table.style.cssText = \"position:absolute;left:-11111px;border-collapse:separate\";\n          tr.style.cssText = \"border:1px solid\"; // Support: Chrome 86+\n          // Height set through cssText does not get applied.\n          // Computed height then comes back as 0.\n\n          tr.style.height = \"1px\";\n          trChild.style.height = \"9px\"; // Support: Android 8 Chrome 86+\n          // In our bodyBackground.html iframe,\n          // display for all div elements is set to \"inline\",\n          // which causes a problem only in Android 8 Chrome 86.\n          // Ensuring the div is display: block\n          // gets around this issue.\n\n          trChild.style.display = \"block\";\n          documentElement.appendChild(table).appendChild(tr).appendChild(trChild);\n          trStyle = window.getComputedStyle(tr);\n          reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;\n          documentElement.removeChild(table);\n        }\n\n        return reliableTrDimensionsVal;\n      }\n    });\n  })();\n\n  function curCSS(elem, name, computed) {\n    var width,\n        minWidth,\n        maxWidth,\n        ret,\n        // Support: Firefox 51+\n    // Retrieving style before computed somehow\n    // fixes an issue with getting wrong values\n    // on detached elements\n    style = elem.style;\n    computed = computed || getStyles(elem); // getPropertyValue is needed for:\n    //   .css('filter') (IE 9 only, #12537)\n    //   .css('--customProperty) (#3144)\n\n    if (computed) {\n      ret = computed.getPropertyValue(name) || computed[name];\n\n      if (ret === \"\" && !isAttached(elem)) {\n        ret = jQuery.style(elem, name);\n      } // A tribute to the \"awesome hack by Dean Edwards\"\n      // Android Browser returns percentage for some values,\n      // but width seems to be reliably pixels.\n      // This is against the CSSOM draft spec:\n      // https://drafts.csswg.org/cssom/#resolved-values\n\n\n      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {\n        // Remember the original values\n        width = style.width;\n        minWidth = style.minWidth;\n        maxWidth = style.maxWidth; // Put in the new values to get a computed value out\n\n        style.minWidth = style.maxWidth = style.width = ret;\n        ret = computed.width; // Revert the changed values\n\n        style.width = width;\n        style.minWidth = minWidth;\n        style.maxWidth = maxWidth;\n      }\n    }\n\n    return ret !== undefined ? // Support: IE <=9 - 11 only\n    // IE returns zIndex value as an integer.\n    ret + \"\" : ret;\n  }\n\n  function addGetHookIf(conditionFn, hookFn) {\n    // Define the hook, we'll check on the first run if it's really needed.\n    return {\n      get: function get() {\n        if (conditionFn()) {\n          // Hook not needed (or it's not possible to use it due\n          // to missing dependency), remove it.\n          delete this.get;\n          return;\n        } // Hook needed; redefine it so that the support test is not executed again.\n\n\n        return (this.get = hookFn).apply(this, arguments);\n      }\n    };\n  }\n\n  var cssPrefixes = [\"Webkit\", \"Moz\", \"ms\"],\n      emptyStyle = document.createElement(\"div\").style,\n      vendorProps = {}; // Return a vendor-prefixed property or undefined\n\n  function vendorPropName(name) {\n    // Check for vendor prefixed names\n    var capName = name[0].toUpperCase() + name.slice(1),\n        i = cssPrefixes.length;\n\n    while (i--) {\n      name = cssPrefixes[i] + capName;\n\n      if (name in emptyStyle) {\n        return name;\n      }\n    }\n  } // Return a potentially-mapped jQuery.cssProps or vendor prefixed property\n\n\n  function finalPropName(name) {\n    var _final = jQuery.cssProps[name] || vendorProps[name];\n\n    if (_final) {\n      return _final;\n    }\n\n    if (name in emptyStyle) {\n      return name;\n    }\n\n    return vendorProps[name] = vendorPropName(name) || name;\n  }\n\n  var // Swappable if display is none or starts with table\n  // except \"table\", \"table-cell\", or \"table-caption\"\n  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n  rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n      rcustomProp = /^--/,\n      cssShow = {\n    position: \"absolute\",\n    visibility: \"hidden\",\n    display: \"block\"\n  },\n      cssNormalTransform = {\n    letterSpacing: \"0\",\n    fontWeight: \"400\"\n  };\n\n  function setPositiveNumber(_elem, value, subtract) {\n    // Any relative (+/-) values have already been\n    // normalized at this point\n    var matches = rcssNum.exec(value);\n    return matches ? // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || \"px\") : value;\n  }\n\n  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {\n    var i = dimension === \"width\" ? 1 : 0,\n        extra = 0,\n        delta = 0; // Adjustment may not be necessary\n\n    if (box === (isBorderBox ? \"border\" : \"content\")) {\n      return 0;\n    }\n\n    for (; i < 4; i += 2) {\n      // Both box models exclude margin\n      if (box === \"margin\") {\n        delta += jQuery.css(elem, box + cssExpand[i], true, styles);\n      } // If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\n\n      if (!isBorderBox) {\n        // Add padding\n        delta += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles); // For \"border\" or \"margin\", add border\n\n        if (box !== \"padding\") {\n          delta += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles); // But still keep track of it otherwise\n        } else {\n          extra += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        } // If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n        // \"padding\" or \"margin\"\n\n      } else {\n        // For \"content\", subtract padding\n        if (box === \"content\") {\n          delta -= jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n        } // For \"content\" or \"padding\", subtract border\n\n\n        if (box !== \"margin\") {\n          delta -= jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        }\n      }\n    } // Account for positive content-box scroll gutter when requested by providing computedVal\n\n\n    if (!isBorderBox && computedVal >= 0) {\n      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n      // Assuming integer scroll gutter, subtract the rest and round down\n      delta += Math.max(0, Math.ceil(elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5 // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter\n      // Use an explicit zero to avoid NaN (gh-3964)\n      )) || 0;\n    }\n\n    return delta;\n  }\n\n  function getWidthOrHeight(elem, dimension, extra) {\n    // Start with computed style\n    var styles = getStyles(elem),\n        // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n    // Fake content-box until we know it's needed to know the true value.\n    boxSizingNeeded = !support.boxSizingReliable() || extra,\n        isBorderBox = boxSizingNeeded && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\",\n        valueIsBorderBox = isBorderBox,\n        val = curCSS(elem, dimension, styles),\n        offsetProp = \"offset\" + dimension[0].toUpperCase() + dimension.slice(1); // Support: Firefox <=54\n    // Return a confounding non-pixel value or feign ignorance, as appropriate.\n\n    if (rnumnonpx.test(val)) {\n      if (!extra) {\n        return val;\n      }\n\n      val = \"auto\";\n    } // Support: IE 9 - 11 only\n    // Use offsetWidth/offsetHeight for when box sizing is unreliable.\n    // In those cases, the computed value can be trusted to be border-box.\n\n\n    if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+\n    // IE/Edge misreport `getComputedStyle` of table rows with width/height\n    // set in CSS while `offset*` properties report correct values.\n    // Interestingly, in some cases IE 9 doesn't suffer from this issue.\n    !support.reliableTrDimensions() && nodeName(elem, \"tr\") || // Fall back to offsetWidth/offsetHeight when value is \"auto\"\n    // This happens for inline elements with no explicit setting (gh-3571)\n    val === \"auto\" || // Support: Android <=4.1 - 4.3 only\n    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n    !parseFloat(val) && jQuery.css(elem, \"display\", false, styles) === \"inline\") && // Make sure the element is visible & connected\n    elem.getClientRects().length) {\n      isBorderBox = jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\"; // Where available, offsetWidth/offsetHeight approximate border box dimensions.\n      // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n      // retrieved value as a content box dimension.\n\n      valueIsBorderBox = offsetProp in elem;\n\n      if (valueIsBorderBox) {\n        val = elem[offsetProp];\n      }\n    } // Normalize \"\" and auto\n\n\n    val = parseFloat(val) || 0; // Adjust for the element's box model\n\n    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)\n    val) + \"px\";\n  }\n\n  jQuery.extend({\n    // Add in style property hooks for overriding the default\n    // behavior of getting and setting a style property\n    cssHooks: {\n      opacity: {\n        get: function get(elem, computed) {\n          if (computed) {\n            // We should always get a number back from opacity\n            var ret = curCSS(elem, \"opacity\");\n            return ret === \"\" ? \"1\" : ret;\n          }\n        }\n      }\n    },\n    // Don't automatically add \"px\" to these possibly-unitless properties\n    cssNumber: {\n      \"animationIterationCount\": true,\n      \"columnCount\": true,\n      \"fillOpacity\": true,\n      \"flexGrow\": true,\n      \"flexShrink\": true,\n      \"fontWeight\": true,\n      \"gridArea\": true,\n      \"gridColumn\": true,\n      \"gridColumnEnd\": true,\n      \"gridColumnStart\": true,\n      \"gridRow\": true,\n      \"gridRowEnd\": true,\n      \"gridRowStart\": true,\n      \"lineHeight\": true,\n      \"opacity\": true,\n      \"order\": true,\n      \"orphans\": true,\n      \"widows\": true,\n      \"zIndex\": true,\n      \"zoom\": true\n    },\n    // Add in properties whose names you wish to fix before\n    // setting or getting the value\n    cssProps: {},\n    // Get and set the style property on a DOM Node\n    style: function style(elem, name, value, extra) {\n      // Don't set styles on text and comment nodes\n      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n        return;\n      } // Make sure that we're working with the right name\n\n\n      var ret,\n          type,\n          hooks,\n          origName = camelCase(name),\n          isCustomProp = rcustomProp.test(name),\n          style = elem.style; // Make sure that we're working with the right name. We don't\n      // want to query the value if it is a CSS custom property\n      // since they are user-defined.\n\n      if (!isCustomProp) {\n        name = finalPropName(origName);\n      } // Gets hook for the prefixed version, then unprefixed version\n\n\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value\n\n      if (value !== undefined) {\n        type = _typeof(value); // Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\n        if (type === \"string\" && (ret = rcssNum.exec(value)) && ret[1]) {\n          value = adjustCSS(elem, name, ret); // Fixes bug #9237\n\n          type = \"number\";\n        } // Make sure that null and NaN values aren't set (#7116)\n\n\n        if (value == null || value !== value) {\n          return;\n        } // If a number was passed in, add the unit (except for certain CSS properties)\n        // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n        // \"px\" to a few hardcoded values.\n\n\n        if (type === \"number\" && !isCustomProp) {\n          value += ret && ret[3] || (jQuery.cssNumber[origName] ? \"\" : \"px\");\n        } // background-* props affect original clone's values\n\n\n        if (!support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0) {\n          style[name] = \"inherit\";\n        } // If a hook was provided, use that value, otherwise just set the specified value\n\n\n        if (!hooks || !(\"set\" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\n          if (isCustomProp) {\n            style.setProperty(name, value);\n          } else {\n            style[name] = value;\n          }\n        }\n      } else {\n        // If a hook was provided get the non-computed value from there\n        if (hooks && \"get\" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n          return ret;\n        } // Otherwise just get the value from the style object\n\n\n        return style[name];\n      }\n    },\n    css: function css(elem, name, extra, styles) {\n      var val,\n          num,\n          hooks,\n          origName = camelCase(name),\n          isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't\n      // want to modify the value if it is a CSS custom property\n      // since they are user-defined.\n\n      if (!isCustomProp) {\n        name = finalPropName(origName);\n      } // Try prefixed name followed by the unprefixed name\n\n\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there\n\n      if (hooks && \"get\" in hooks) {\n        val = hooks.get(elem, true, extra);\n      } // Otherwise, if a way to get the computed value exists, use that\n\n\n      if (val === undefined) {\n        val = curCSS(elem, name, styles);\n      } // Convert \"normal\" to computed value\n\n\n      if (val === \"normal\" && name in cssNormalTransform) {\n        val = cssNormalTransform[name];\n      } // Make numeric if forced or a qualifier was provided and val looks numeric\n\n\n      if (extra === \"\" || extra) {\n        num = parseFloat(val);\n        return extra === true || isFinite(num) ? num || 0 : val;\n      }\n\n      return val;\n    }\n  });\n  jQuery.each([\"height\", \"width\"], function (_i, dimension) {\n    jQuery.cssHooks[dimension] = {\n      get: function get(elem, computed, extra) {\n        if (computed) {\n          // Certain elements can have dimension info if we invisibly show them\n          // but it must have a current display style that would benefit\n          return rdisplayswap.test(jQuery.css(elem, \"display\")) && ( // Support: Safari 8+\n          // Table columns in Safari have non-zero offsetWidth & zero\n          // getBoundingClientRect().width unless display is changed.\n          // Support: IE <=11 only\n          // Running getBoundingClientRect on a disconnected node\n          // in IE throws an error.\n          !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {\n            return getWidthOrHeight(elem, dimension, extra);\n          }) : getWidthOrHeight(elem, dimension, extra);\n        }\n      },\n      set: function set(elem, value, extra) {\n        var matches,\n            styles = getStyles(elem),\n            // Only read styles.position if the test has a chance to fail\n        // to avoid forcing a reflow.\n        scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === \"absolute\",\n            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n        boxSizingNeeded = scrollboxSizeBuggy || extra,\n            isBorderBox = boxSizingNeeded && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\",\n            subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0; // Account for unreliable border-box dimensions by comparing offset* to computed and\n        // faking a content-box to get border and padding (gh-3699)\n\n        if (isBorderBox && scrollboxSizeBuggy) {\n          subtract -= Math.ceil(elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, \"border\", false, styles) - 0.5);\n        } // Convert to pixels if value adjustment is needed\n\n\n        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || \"px\") !== \"px\") {\n          elem.style[dimension] = value;\n          value = jQuery.css(elem, dimension);\n        }\n\n        return setPositiveNumber(elem, value, subtract);\n      }\n    };\n  });\n  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {\n    if (computed) {\n      return (parseFloat(curCSS(elem, \"marginLeft\")) || elem.getBoundingClientRect().left - swap(elem, {\n        marginLeft: 0\n      }, function () {\n        return elem.getBoundingClientRect().left;\n      })) + \"px\";\n    }\n  }); // These hooks are used by animate to expand properties\n\n  jQuery.each({\n    margin: \"\",\n    padding: \"\",\n    border: \"Width\"\n  }, function (prefix, suffix) {\n    jQuery.cssHooks[prefix + suffix] = {\n      expand: function expand(value) {\n        var i = 0,\n            expanded = {},\n            // Assumes a single number if not a string\n        parts = typeof value === \"string\" ? value.split(\" \") : [value];\n\n        for (; i < 4; i++) {\n          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\n        }\n\n        return expanded;\n      }\n    };\n\n    if (prefix !== \"margin\") {\n      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n    }\n  });\n  jQuery.fn.extend({\n    css: function css(name, value) {\n      return access(this, function (elem, name, value) {\n        var styles,\n            len,\n            map = {},\n            i = 0;\n\n        if (Array.isArray(name)) {\n          styles = getStyles(elem);\n          len = name.length;\n\n          for (; i < len; i++) {\n            map[name[i]] = jQuery.css(elem, name[i], false, styles);\n          }\n\n          return map;\n        }\n\n        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\n      }, name, value, arguments.length > 1);\n    }\n  });\n\n  function Tween(elem, options, prop, end, easing) {\n    return new Tween.prototype.init(elem, options, prop, end, easing);\n  }\n\n  jQuery.Tween = Tween;\n  Tween.prototype = {\n    constructor: Tween,\n    init: function init(elem, options, prop, end, easing, unit) {\n      this.elem = elem;\n      this.prop = prop;\n      this.easing = easing || jQuery.easing._default;\n      this.options = options;\n      this.start = this.now = this.cur();\n      this.end = end;\n      this.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\n    },\n    cur: function cur() {\n      var hooks = Tween.propHooks[this.prop];\n      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\n    },\n    run: function run(percent) {\n      var eased,\n          hooks = Tween.propHooks[this.prop];\n\n      if (this.options.duration) {\n        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\n      } else {\n        this.pos = eased = percent;\n      }\n\n      this.now = (this.end - this.start) * eased + this.start;\n\n      if (this.options.step) {\n        this.options.step.call(this.elem, this.now, this);\n      }\n\n      if (hooks && hooks.set) {\n        hooks.set(this);\n      } else {\n        Tween.propHooks._default.set(this);\n      }\n\n      return this;\n    }\n  };\n  Tween.prototype.init.prototype = Tween.prototype;\n  Tween.propHooks = {\n    _default: {\n      get: function get(tween) {\n        var result; // Use a property on the element directly when it is not a DOM element,\n        // or when there is no matching style property that exists.\n\n        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {\n          return tween.elem[tween.prop];\n        } // Passing an empty string as a 3rd parameter to .css will automatically\n        // attempt a parseFloat and fallback to a string if the parse fails.\n        // Simple values such as \"10px\" are parsed to Float;\n        // complex values such as \"rotate(1rad)\" are returned as-is.\n\n\n        result = jQuery.css(tween.elem, tween.prop, \"\"); // Empty strings, null, undefined and \"auto\" are converted to 0.\n\n        return !result || result === \"auto\" ? 0 : result;\n      },\n      set: function set(tween) {\n        // Use step hook for back compat.\n        // Use cssHook if its there.\n        // Use .style if available and use plain properties where available.\n        if (jQuery.fx.step[tween.prop]) {\n          jQuery.fx.step[tween.prop](tween);\n        } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {\n          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\n        } else {\n          tween.elem[tween.prop] = tween.now;\n        }\n      }\n    }\n  }; // Support: IE <=9 only\n  // Panic based approach to setting things on disconnected nodes\n\n  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n    set: function set(tween) {\n      if (tween.elem.nodeType && tween.elem.parentNode) {\n        tween.elem[tween.prop] = tween.now;\n      }\n    }\n  };\n  jQuery.easing = {\n    linear: function linear(p) {\n      return p;\n    },\n    swing: function swing(p) {\n      return 0.5 - Math.cos(p * Math.PI) / 2;\n    },\n    _default: \"swing\"\n  };\n  jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point\n\n  jQuery.fx.step = {};\n  var fxNow,\n      inProgress,\n      rfxtypes = /^(?:toggle|show|hide)$/,\n      rrun = /queueHooks$/;\n\n  function schedule() {\n    if (inProgress) {\n      if (document.hidden === false && window.requestAnimationFrame) {\n        window.requestAnimationFrame(schedule);\n      } else {\n        window.setTimeout(schedule, jQuery.fx.interval);\n      }\n\n      jQuery.fx.tick();\n    }\n  } // Animations created synchronously will run synchronously\n\n\n  function createFxNow() {\n    window.setTimeout(function () {\n      fxNow = undefined;\n    });\n    return fxNow = Date.now();\n  } // Generate parameters to create a standard animation\n\n\n  function genFx(type, includeWidth) {\n    var which,\n        i = 0,\n        attrs = {\n      height: type\n    }; // If we include width, step value is 1 to do all cssExpand values,\n    // otherwise step value is 2 to skip over Left and Right\n\n    includeWidth = includeWidth ? 1 : 0;\n\n    for (; i < 4; i += 2 - includeWidth) {\n      which = cssExpand[i];\n      attrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\n    }\n\n    if (includeWidth) {\n      attrs.opacity = attrs.width = type;\n    }\n\n    return attrs;\n  }\n\n  function createTween(value, prop, animation) {\n    var tween,\n        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners[\"*\"]),\n        index = 0,\n        length = collection.length;\n\n    for (; index < length; index++) {\n      if (tween = collection[index].call(animation, prop, value)) {\n        // We're done with this property\n        return tween;\n      }\n    }\n  }\n\n  function defaultPrefilter(elem, props, opts) {\n    var prop,\n        value,\n        toggle,\n        hooks,\n        oldfire,\n        propTween,\n        restoreDisplay,\n        display,\n        isBox = \"width\" in props || \"height\" in props,\n        anim = this,\n        orig = {},\n        style = elem.style,\n        hidden = elem.nodeType && isHiddenWithinTree(elem),\n        dataShow = dataPriv.get(elem, \"fxshow\"); // Queue-skipping animations hijack the fx hooks\n\n    if (!opts.queue) {\n      hooks = jQuery._queueHooks(elem, \"fx\");\n\n      if (hooks.unqueued == null) {\n        hooks.unqueued = 0;\n        oldfire = hooks.empty.fire;\n\n        hooks.empty.fire = function () {\n          if (!hooks.unqueued) {\n            oldfire();\n          }\n        };\n      }\n\n      hooks.unqueued++;\n      anim.always(function () {\n        // Ensure the complete handler is called before this completes\n        anim.always(function () {\n          hooks.unqueued--;\n\n          if (!jQuery.queue(elem, \"fx\").length) {\n            hooks.empty.fire();\n          }\n        });\n      });\n    } // Detect show/hide animations\n\n\n    for (prop in props) {\n      value = props[prop];\n\n      if (rfxtypes.test(value)) {\n        delete props[prop];\n        toggle = toggle || value === \"toggle\";\n\n        if (value === (hidden ? \"hide\" : \"show\")) {\n          // Pretend to be hidden if this is a \"show\" and\n          // there is still data from a stopped show/hide\n          if (value === \"show\" && dataShow && dataShow[prop] !== undefined) {\n            hidden = true; // Ignore all other no-op show/hide data\n          } else {\n            continue;\n          }\n        }\n\n        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);\n      }\n    } // Bail out if this is a no-op like .hide().hide()\n\n\n    propTween = !jQuery.isEmptyObject(props);\n\n    if (!propTween && jQuery.isEmptyObject(orig)) {\n      return;\n    } // Restrict \"overflow\" and \"display\" styles during box animations\n\n\n    if (isBox && elem.nodeType === 1) {\n      // Support: IE <=9 - 11, Edge 12 - 15\n      // Record all 3 overflow attributes because IE does not infer the shorthand\n      // from identically-valued overflowX and overflowY and Edge just mirrors\n      // the overflowX value there.\n      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade\n\n      restoreDisplay = dataShow && dataShow.display;\n\n      if (restoreDisplay == null) {\n        restoreDisplay = dataPriv.get(elem, \"display\");\n      }\n\n      display = jQuery.css(elem, \"display\");\n\n      if (display === \"none\") {\n        if (restoreDisplay) {\n          display = restoreDisplay;\n        } else {\n          // Get nonempty value(s) by temporarily forcing visibility\n          showHide([elem], true);\n          restoreDisplay = elem.style.display || restoreDisplay;\n          display = jQuery.css(elem, \"display\");\n          showHide([elem]);\n        }\n      } // Animate inline elements as inline-block\n\n\n      if (display === \"inline\" || display === \"inline-block\" && restoreDisplay != null) {\n        if (jQuery.css(elem, \"float\") === \"none\") {\n          // Restore the original display value at the end of pure show/hide animations\n          if (!propTween) {\n            anim.done(function () {\n              style.display = restoreDisplay;\n            });\n\n            if (restoreDisplay == null) {\n              display = style.display;\n              restoreDisplay = display === \"none\" ? \"\" : display;\n            }\n          }\n\n          style.display = \"inline-block\";\n        }\n      }\n    }\n\n    if (opts.overflow) {\n      style.overflow = \"hidden\";\n      anim.always(function () {\n        style.overflow = opts.overflow[0];\n        style.overflowX = opts.overflow[1];\n        style.overflowY = opts.overflow[2];\n      });\n    } // Implement show/hide animations\n\n\n    propTween = false;\n\n    for (prop in orig) {\n      // General show/hide setup for this element animation\n      if (!propTween) {\n        if (dataShow) {\n          if (\"hidden\" in dataShow) {\n            hidden = dataShow.hidden;\n          }\n        } else {\n          dataShow = dataPriv.access(elem, \"fxshow\", {\n            display: restoreDisplay\n          });\n        } // Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\n\n        if (toggle) {\n          dataShow.hidden = !hidden;\n        } // Show elements before animating them\n\n\n        if (hidden) {\n          showHide([elem], true);\n        }\n        /* eslint-disable no-loop-func */\n\n\n        anim.done(function () {\n          /* eslint-enable no-loop-func */\n          // The final step of a \"hide\" animation is actually hiding the element\n          if (!hidden) {\n            showHide([elem]);\n          }\n\n          dataPriv.remove(elem, \"fxshow\");\n\n          for (prop in orig) {\n            jQuery.style(elem, prop, orig[prop]);\n          }\n        });\n      } // Per-property setup\n\n\n      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\n\n      if (!(prop in dataShow)) {\n        dataShow[prop] = propTween.start;\n\n        if (hidden) {\n          propTween.end = propTween.start;\n          propTween.start = 0;\n        }\n      }\n    }\n  }\n\n  function propFilter(props, specialEasing) {\n    var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass\n\n    for (index in props) {\n      name = camelCase(index);\n      easing = specialEasing[name];\n      value = props[index];\n\n      if (Array.isArray(value)) {\n        easing = value[1];\n        value = props[index] = value[0];\n      }\n\n      if (index !== name) {\n        props[name] = value;\n        delete props[index];\n      }\n\n      hooks = jQuery.cssHooks[name];\n\n      if (hooks && \"expand\" in hooks) {\n        value = hooks.expand(value);\n        delete props[name]; // Not quite $.extend, this won't overwrite existing keys.\n        // Reusing 'index' because we have the correct \"name\"\n\n        for (index in value) {\n          if (!(index in props)) {\n            props[index] = value[index];\n            specialEasing[index] = easing;\n          }\n        }\n      } else {\n        specialEasing[name] = easing;\n      }\n    }\n  }\n\n  function Animation(elem, properties, options) {\n    var result,\n        stopped,\n        index = 0,\n        length = Animation.prefilters.length,\n        deferred = jQuery.Deferred().always(function () {\n      // Don't match elem in the :animated selector\n      delete tick.elem;\n    }),\n        tick = function tick() {\n      if (stopped) {\n        return false;\n      }\n\n      var currentTime = fxNow || createFxNow(),\n          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\n          // Support: Android 2.3 only\n      // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n      temp = remaining / animation.duration || 0,\n          percent = 1 - temp,\n          index = 0,\n          length = animation.tweens.length;\n\n      for (; index < length; index++) {\n        animation.tweens[index].run(percent);\n      }\n\n      deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield\n\n      if (percent < 1 && length) {\n        return remaining;\n      } // If this was an empty animation, synthesize a final progress notification\n\n\n      if (!length) {\n        deferred.notifyWith(elem, [animation, 1, 0]);\n      } // Resolve the animation and report its conclusion\n\n\n      deferred.resolveWith(elem, [animation]);\n      return false;\n    },\n        animation = deferred.promise({\n      elem: elem,\n      props: jQuery.extend({}, properties),\n      opts: jQuery.extend(true, {\n        specialEasing: {},\n        easing: jQuery.easing._default\n      }, options),\n      originalProperties: properties,\n      originalOptions: options,\n      startTime: fxNow || createFxNow(),\n      duration: options.duration,\n      tweens: [],\n      createTween: function createTween(prop, end) {\n        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\n        animation.tweens.push(tween);\n        return tween;\n      },\n      stop: function stop(gotoEnd) {\n        var index = 0,\n            // If we are going to the end, we want to run all the tweens\n        // otherwise we skip this part\n        length = gotoEnd ? animation.tweens.length : 0;\n\n        if (stopped) {\n          return this;\n        }\n\n        stopped = true;\n\n        for (; index < length; index++) {\n          animation.tweens[index].run(1);\n        } // Resolve when we played the last frame; otherwise, reject\n\n\n        if (gotoEnd) {\n          deferred.notifyWith(elem, [animation, 1, 0]);\n          deferred.resolveWith(elem, [animation, gotoEnd]);\n        } else {\n          deferred.rejectWith(elem, [animation, gotoEnd]);\n        }\n\n        return this;\n      }\n    }),\n        props = animation.props;\n\n    propFilter(props, animation.opts.specialEasing);\n\n    for (; index < length; index++) {\n      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);\n\n      if (result) {\n        if (isFunction(result.stop)) {\n          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);\n        }\n\n        return result;\n      }\n    }\n\n    jQuery.map(props, createTween, animation);\n\n    if (isFunction(animation.opts.start)) {\n      animation.opts.start.call(elem, animation);\n    } // Attach callbacks from options\n\n\n    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);\n    jQuery.fx.timer(jQuery.extend(tick, {\n      elem: elem,\n      anim: animation,\n      queue: animation.opts.queue\n    }));\n    return animation;\n  }\n\n  jQuery.Animation = jQuery.extend(Animation, {\n    tweeners: {\n      \"*\": [function (prop, value) {\n        var tween = this.createTween(prop, value);\n        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);\n        return tween;\n      }]\n    },\n    tweener: function tweener(props, callback) {\n      if (isFunction(props)) {\n        callback = props;\n        props = [\"*\"];\n      } else {\n        props = props.match(rnothtmlwhite);\n      }\n\n      var prop,\n          index = 0,\n          length = props.length;\n\n      for (; index < length; index++) {\n        prop = props[index];\n        Animation.tweeners[prop] = Animation.tweeners[prop] || [];\n        Animation.tweeners[prop].unshift(callback);\n      }\n    },\n    prefilters: [defaultPrefilter],\n    prefilter: function prefilter(callback, prepend) {\n      if (prepend) {\n        Animation.prefilters.unshift(callback);\n      } else {\n        Animation.prefilters.push(callback);\n      }\n    }\n  });\n\n  jQuery.speed = function (speed, easing, fn) {\n    var opt = speed && _typeof(speed) === \"object\" ? jQuery.extend({}, speed) : {\n      complete: fn || !fn && easing || isFunction(speed) && speed,\n      duration: speed,\n      easing: fn && easing || easing && !isFunction(easing) && easing\n    }; // Go to the end state if fx are off\n\n    if (jQuery.fx.off) {\n      opt.duration = 0;\n    } else {\n      if (typeof opt.duration !== \"number\") {\n        if (opt.duration in jQuery.fx.speeds) {\n          opt.duration = jQuery.fx.speeds[opt.duration];\n        } else {\n          opt.duration = jQuery.fx.speeds._default;\n        }\n      }\n    } // Normalize opt.queue - true/undefined/null -> \"fx\"\n\n\n    if (opt.queue == null || opt.queue === true) {\n      opt.queue = \"fx\";\n    } // Queueing\n\n\n    opt.old = opt.complete;\n\n    opt.complete = function () {\n      if (isFunction(opt.old)) {\n        opt.old.call(this);\n      }\n\n      if (opt.queue) {\n        jQuery.dequeue(this, opt.queue);\n      }\n    };\n\n    return opt;\n  };\n\n  jQuery.fn.extend({\n    fadeTo: function fadeTo(speed, to, easing, callback) {\n      // Show any hidden elements after setting opacity to 0\n      return this.filter(isHiddenWithinTree).css(\"opacity\", 0).show() // Animate to the value specified\n      .end().animate({\n        opacity: to\n      }, speed, easing, callback);\n    },\n    animate: function animate(prop, speed, easing, callback) {\n      var empty = jQuery.isEmptyObject(prop),\n          optall = jQuery.speed(speed, easing, callback),\n          doAnimation = function doAnimation() {\n        // Operate on a copy of prop so per-property easing won't be lost\n        var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately\n\n        if (empty || dataPriv.get(this, \"finish\")) {\n          anim.stop(true);\n        }\n      };\n\n      doAnimation.finish = doAnimation;\n      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\n    },\n    stop: function stop(type, clearQueue, gotoEnd) {\n      var stopQueue = function stopQueue(hooks) {\n        var stop = hooks.stop;\n        delete hooks.stop;\n        stop(gotoEnd);\n      };\n\n      if (typeof type !== \"string\") {\n        gotoEnd = clearQueue;\n        clearQueue = type;\n        type = undefined;\n      }\n\n      if (clearQueue) {\n        this.queue(type || \"fx\", []);\n      }\n\n      return this.each(function () {\n        var dequeue = true,\n            index = type != null && type + \"queueHooks\",\n            timers = jQuery.timers,\n            data = dataPriv.get(this);\n\n        if (index) {\n          if (data[index] && data[index].stop) {\n            stopQueue(data[index]);\n          }\n        } else {\n          for (index in data) {\n            if (data[index] && data[index].stop && rrun.test(index)) {\n              stopQueue(data[index]);\n            }\n          }\n        }\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n            timers[index].anim.stop(gotoEnd);\n            dequeue = false;\n            timers.splice(index, 1);\n          }\n        } // Start the next in the queue if the last step wasn't forced.\n        // Timers currently will call their complete callbacks, which\n        // will dequeue but only if they were gotoEnd.\n\n\n        if (dequeue || !gotoEnd) {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    finish: function finish(type) {\n      if (type !== false) {\n        type = type || \"fx\";\n      }\n\n      return this.each(function () {\n        var index,\n            data = dataPriv.get(this),\n            queue = data[type + \"queue\"],\n            hooks = data[type + \"queueHooks\"],\n            timers = jQuery.timers,\n            length = queue ? queue.length : 0; // Enable finishing flag on private data\n\n        data.finish = true; // Empty the queue first\n\n        jQuery.queue(this, type, []);\n\n        if (hooks && hooks.stop) {\n          hooks.stop.call(this, true);\n        } // Look for any active animations, and finish them\n\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && timers[index].queue === type) {\n            timers[index].anim.stop(true);\n            timers.splice(index, 1);\n          }\n        } // Look for any animations in the old queue and finish them\n\n\n        for (index = 0; index < length; index++) {\n          if (queue[index] && queue[index].finish) {\n            queue[index].finish.call(this);\n          }\n        } // Turn off finishing flag\n\n\n        delete data.finish;\n      });\n    }\n  });\n  jQuery.each([\"toggle\", \"show\", \"hide\"], function (_i, name) {\n    var cssFn = jQuery.fn[name];\n\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return speed == null || typeof speed === \"boolean\" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);\n    };\n  }); // Generate shortcuts for custom animations\n\n  jQuery.each({\n    slideDown: genFx(\"show\"),\n    slideUp: genFx(\"hide\"),\n    slideToggle: genFx(\"toggle\"),\n    fadeIn: {\n      opacity: \"show\"\n    },\n    fadeOut: {\n      opacity: \"hide\"\n    },\n    fadeToggle: {\n      opacity: \"toggle\"\n    }\n  }, function (name, props) {\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return this.animate(props, speed, easing, callback);\n    };\n  });\n  jQuery.timers = [];\n\n  jQuery.fx.tick = function () {\n    var timer,\n        i = 0,\n        timers = jQuery.timers;\n    fxNow = Date.now();\n\n    for (; i < timers.length; i++) {\n      timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)\n\n      if (!timer() && timers[i] === timer) {\n        timers.splice(i--, 1);\n      }\n    }\n\n    if (!timers.length) {\n      jQuery.fx.stop();\n    }\n\n    fxNow = undefined;\n  };\n\n  jQuery.fx.timer = function (timer) {\n    jQuery.timers.push(timer);\n    jQuery.fx.start();\n  };\n\n  jQuery.fx.interval = 13;\n\n  jQuery.fx.start = function () {\n    if (inProgress) {\n      return;\n    }\n\n    inProgress = true;\n    schedule();\n  };\n\n  jQuery.fx.stop = function () {\n    inProgress = null;\n  };\n\n  jQuery.fx.speeds = {\n    slow: 600,\n    fast: 200,\n    // Default speed\n    _default: 400\n  }; // Based off of the plugin by Clint Helfers, with permission.\n  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\n\n  jQuery.fn.delay = function (time, type) {\n    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n    type = type || \"fx\";\n    return this.queue(type, function (next, hooks) {\n      var timeout = window.setTimeout(next, time);\n\n      hooks.stop = function () {\n        window.clearTimeout(timeout);\n      };\n    });\n  };\n\n  (function () {\n    var input = document.createElement(\"input\"),\n        select = document.createElement(\"select\"),\n        opt = select.appendChild(document.createElement(\"option\"));\n    input.type = \"checkbox\"; // Support: Android <=4.3 only\n    // Default value for a checkbox should be \"on\"\n\n    support.checkOn = input.value !== \"\"; // Support: IE <=11 only\n    // Must access selectedIndex to make default options select\n\n    support.optSelected = opt.selected; // Support: IE <=11 only\n    // An input loses its value after becoming a radio\n\n    input = document.createElement(\"input\");\n    input.value = \"t\";\n    input.type = \"radio\";\n    support.radioValue = input.value === \"t\";\n  })();\n\n  var boolHook,\n      attrHandle = jQuery.expr.attrHandle;\n  jQuery.fn.extend({\n    attr: function attr(name, value) {\n      return access(this, jQuery.attr, name, value, arguments.length > 1);\n    },\n    removeAttr: function removeAttr(name) {\n      return this.each(function () {\n        jQuery.removeAttr(this, name);\n      });\n    }\n  });\n  jQuery.extend({\n    attr: function attr(elem, name, value) {\n      var ret,\n          hooks,\n          nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes\n\n      if (nType === 3 || nType === 8 || nType === 2) {\n        return;\n      } // Fallback to prop when attributes are not supported\n\n\n      if (typeof elem.getAttribute === \"undefined\") {\n        return jQuery.prop(elem, name, value);\n      } // Attribute hooks are determined by the lowercase version\n      // Grab necessary hook if one is defined\n\n\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);\n      }\n\n      if (value !== undefined) {\n        if (value === null) {\n          jQuery.removeAttr(elem, name);\n          return;\n        }\n\n        if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        }\n\n        elem.setAttribute(name, value + \"\");\n        return value;\n      }\n\n      if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      }\n\n      ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined\n\n      return ret == null ? undefined : ret;\n    },\n    attrHooks: {\n      type: {\n        set: function set(elem, value) {\n          if (!support.radioValue && value === \"radio\" && nodeName(elem, \"input\")) {\n            var val = elem.value;\n            elem.setAttribute(\"type\", value);\n\n            if (val) {\n              elem.value = val;\n            }\n\n            return value;\n          }\n        }\n      }\n    },\n    removeAttr: function removeAttr(elem, value) {\n      var name,\n          i = 0,\n          // Attribute names can contain non-HTML whitespace characters\n      // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n      attrNames = value && value.match(rnothtmlwhite);\n\n      if (attrNames && elem.nodeType === 1) {\n        while (name = attrNames[i++]) {\n          elem.removeAttribute(name);\n        }\n      }\n    }\n  }); // Hooks for boolean attributes\n\n  boolHook = {\n    set: function set(elem, value, name) {\n      if (value === false) {\n        // Remove boolean attributes when set to false\n        jQuery.removeAttr(elem, name);\n      } else {\n        elem.setAttribute(name, name);\n      }\n\n      return name;\n    }\n  };\n  jQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function (_i, name) {\n    var getter = attrHandle[name] || jQuery.find.attr;\n\n    attrHandle[name] = function (elem, name, isXML) {\n      var ret,\n          handle,\n          lowercaseName = name.toLowerCase();\n\n      if (!isXML) {\n        // Avoid an infinite loop by temporarily removing this function from the getter\n        handle = attrHandle[lowercaseName];\n        attrHandle[lowercaseName] = ret;\n        ret = getter(elem, name, isXML) != null ? lowercaseName : null;\n        attrHandle[lowercaseName] = handle;\n      }\n\n      return ret;\n    };\n  });\n  var rfocusable = /^(?:input|select|textarea|button)$/i,\n      rclickable = /^(?:a|area)$/i;\n  jQuery.fn.extend({\n    prop: function prop(name, value) {\n      return access(this, jQuery.prop, name, value, arguments.length > 1);\n    },\n    removeProp: function removeProp(name) {\n      return this.each(function () {\n        delete this[jQuery.propFix[name] || name];\n      });\n    }\n  });\n  jQuery.extend({\n    prop: function prop(elem, name, value) {\n      var ret,\n          hooks,\n          nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes\n\n      if (nType === 3 || nType === 8 || nType === 2) {\n        return;\n      }\n\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n        // Fix name and attach hooks\n        name = jQuery.propFix[name] || name;\n        hooks = jQuery.propHooks[name];\n      }\n\n      if (value !== undefined) {\n        if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        }\n\n        return elem[name] = value;\n      }\n\n      if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      }\n\n      return elem[name];\n    },\n    propHooks: {\n      tabIndex: {\n        get: function get(elem) {\n          // Support: IE <=9 - 11 only\n          // elem.tabIndex doesn't always return the\n          // correct value when it hasn't been explicitly set\n          // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n          // Use proper attribute retrieval(#12072)\n          var tabindex = jQuery.find.attr(elem, \"tabindex\");\n\n          if (tabindex) {\n            return parseInt(tabindex, 10);\n          }\n\n          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {\n            return 0;\n          }\n\n          return -1;\n        }\n      }\n    },\n    propFix: {\n      \"for\": \"htmlFor\",\n      \"class\": \"className\"\n    }\n  }); // Support: IE <=11 only\n  // Accessing the selectedIndex property\n  // forces the browser to respect setting selected\n  // on the option\n  // The getter ensures a default option is selected\n  // when in an optgroup\n  // eslint rule \"no-unused-expressions\" is disabled for this code\n  // since it considers such accessions noop\n\n  if (!support.optSelected) {\n    jQuery.propHooks.selected = {\n      get: function get(elem) {\n        /* eslint no-unused-expressions: \"off\" */\n        var parent = elem.parentNode;\n\n        if (parent && parent.parentNode) {\n          parent.parentNode.selectedIndex;\n        }\n\n        return null;\n      },\n      set: function set(elem) {\n        /* eslint no-unused-expressions: \"off\" */\n        var parent = elem.parentNode;\n\n        if (parent) {\n          parent.selectedIndex;\n\n          if (parent.parentNode) {\n            parent.parentNode.selectedIndex;\n          }\n        }\n      }\n    };\n  }\n\n  jQuery.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n    jQuery.propFix[this.toLowerCase()] = this;\n  }); // Strip and collapse whitespace according to HTML spec\n  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\n  function stripAndCollapse(value) {\n    var tokens = value.match(rnothtmlwhite) || [];\n    return tokens.join(\" \");\n  }\n\n  function getClass(elem) {\n    return elem.getAttribute && elem.getAttribute(\"class\") || \"\";\n  }\n\n  function classesToArray(value) {\n    if (Array.isArray(value)) {\n      return value;\n    }\n\n    if (typeof value === \"string\") {\n      return value.match(rnothtmlwhite) || [];\n    }\n\n    return [];\n  }\n\n  jQuery.fn.extend({\n    addClass: function addClass(value) {\n      var classes,\n          elem,\n          cur,\n          curValue,\n          clazz,\n          j,\n          finalValue,\n          i = 0;\n\n      if (isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).addClass(value.call(this, j, getClass(this)));\n        });\n      }\n\n      classes = classesToArray(value);\n\n      if (classes.length) {\n        while (elem = this[i++]) {\n          curValue = getClass(elem);\n          cur = elem.nodeType === 1 && \" \" + stripAndCollapse(curValue) + \" \";\n\n          if (cur) {\n            j = 0;\n\n            while (clazz = classes[j++]) {\n              if (cur.indexOf(\" \" + clazz + \" \") < 0) {\n                cur += clazz + \" \";\n              }\n            } // Only assign if different to avoid unneeded rendering.\n\n\n            finalValue = stripAndCollapse(cur);\n\n            if (curValue !== finalValue) {\n              elem.setAttribute(\"class\", finalValue);\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n    removeClass: function removeClass(value) {\n      var classes,\n          elem,\n          cur,\n          curValue,\n          clazz,\n          j,\n          finalValue,\n          i = 0;\n\n      if (isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).removeClass(value.call(this, j, getClass(this)));\n        });\n      }\n\n      if (!arguments.length) {\n        return this.attr(\"class\", \"\");\n      }\n\n      classes = classesToArray(value);\n\n      if (classes.length) {\n        while (elem = this[i++]) {\n          curValue = getClass(elem); // This expression is here for better compressibility (see addClass)\n\n          cur = elem.nodeType === 1 && \" \" + stripAndCollapse(curValue) + \" \";\n\n          if (cur) {\n            j = 0;\n\n            while (clazz = classes[j++]) {\n              // Remove *all* instances\n              while (cur.indexOf(\" \" + clazz + \" \") > -1) {\n                cur = cur.replace(\" \" + clazz + \" \", \" \");\n              }\n            } // Only assign if different to avoid unneeded rendering.\n\n\n            finalValue = stripAndCollapse(cur);\n\n            if (curValue !== finalValue) {\n              elem.setAttribute(\"class\", finalValue);\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n    toggleClass: function toggleClass(value, stateVal) {\n      var type = _typeof(value),\n          isValidValue = type === \"string\" || Array.isArray(value);\n\n      if (typeof stateVal === \"boolean\" && isValidValue) {\n        return stateVal ? this.addClass(value) : this.removeClass(value);\n      }\n\n      if (isFunction(value)) {\n        return this.each(function (i) {\n          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);\n        });\n      }\n\n      return this.each(function () {\n        var className, i, self, classNames;\n\n        if (isValidValue) {\n          // Toggle individual class names\n          i = 0;\n          self = jQuery(this);\n          classNames = classesToArray(value);\n\n          while (className = classNames[i++]) {\n            // Check each className given, space separated list\n            if (self.hasClass(className)) {\n              self.removeClass(className);\n            } else {\n              self.addClass(className);\n            }\n          } // Toggle whole class name\n\n        } else if (value === undefined || type === \"boolean\") {\n          className = getClass(this);\n\n          if (className) {\n            // Store className if set\n            dataPriv.set(this, \"__className__\", className);\n          } // If the element has a class name or if we're passed `false`,\n          // then remove the whole classname (if there was one, the above saved it).\n          // Otherwise bring back whatever was previously saved (if anything),\n          // falling back to the empty string if nothing was stored.\n\n\n          if (this.setAttribute) {\n            this.setAttribute(\"class\", className || value === false ? \"\" : dataPriv.get(this, \"__className__\") || \"\");\n          }\n        }\n      });\n    },\n    hasClass: function hasClass(selector) {\n      var className,\n          elem,\n          i = 0;\n      className = \" \" + selector + \" \";\n\n      while (elem = this[i++]) {\n        if (elem.nodeType === 1 && (\" \" + stripAndCollapse(getClass(elem)) + \" \").indexOf(className) > -1) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  });\n  var rreturn = /\\r/g;\n  jQuery.fn.extend({\n    val: function val(value) {\n      var hooks,\n          ret,\n          valueIsFunction,\n          elem = this[0];\n\n      if (!arguments.length) {\n        if (elem) {\n          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\n\n          if (hooks && \"get\" in hooks && (ret = hooks.get(elem, \"value\")) !== undefined) {\n            return ret;\n          }\n\n          ret = elem.value; // Handle most common string cases\n\n          if (typeof ret === \"string\") {\n            return ret.replace(rreturn, \"\");\n          } // Handle cases where value is null/undef or number\n\n\n          return ret == null ? \"\" : ret;\n        }\n\n        return;\n      }\n\n      valueIsFunction = isFunction(value);\n      return this.each(function (i) {\n        var val;\n\n        if (this.nodeType !== 1) {\n          return;\n        }\n\n        if (valueIsFunction) {\n          val = value.call(this, i, jQuery(this).val());\n        } else {\n          val = value;\n        } // Treat null/undefined as \"\"; convert numbers to string\n\n\n        if (val == null) {\n          val = \"\";\n        } else if (typeof val === \"number\") {\n          val += \"\";\n        } else if (Array.isArray(val)) {\n          val = jQuery.map(val, function (value) {\n            return value == null ? \"\" : value + \"\";\n          });\n        }\n\n        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting\n\n        if (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\n          this.value = val;\n        }\n      });\n    }\n  });\n  jQuery.extend({\n    valHooks: {\n      option: {\n        get: function get(elem) {\n          var val = jQuery.find.attr(elem, \"value\");\n          return val != null ? val : // Support: IE <=10 - 11 only\n          // option.text throws exceptions (#14686, #14858)\n          // Strip and collapse whitespace\n          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n          stripAndCollapse(jQuery.text(elem));\n        }\n      },\n      select: {\n        get: function get(elem) {\n          var value,\n              option,\n              i,\n              options = elem.options,\n              index = elem.selectedIndex,\n              one = elem.type === \"select-one\",\n              values = one ? null : [],\n              max = one ? index + 1 : options.length;\n\n          if (index < 0) {\n            i = max;\n          } else {\n            i = one ? index : 0;\n          } // Loop through all the selected options\n\n\n          for (; i < max; i++) {\n            option = options[i]; // Support: IE <=9 only\n            // IE8-9 doesn't update selected after form reset (#2551)\n\n            if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup\n            !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, \"optgroup\"))) {\n              // Get the specific value for the option\n              value = jQuery(option).val(); // We don't need an array for one selects\n\n              if (one) {\n                return value;\n              } // Multi-Selects return an array\n\n\n              values.push(value);\n            }\n          }\n\n          return values;\n        },\n        set: function set(elem, value) {\n          var optionSet,\n              option,\n              options = elem.options,\n              values = jQuery.makeArray(value),\n              i = options.length;\n\n          while (i--) {\n            option = options[i];\n            /* eslint-disable no-cond-assign */\n\n            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {\n              optionSet = true;\n            }\n            /* eslint-enable no-cond-assign */\n\n          } // Force browsers to behave consistently when non-matching value is set\n\n\n          if (!optionSet) {\n            elem.selectedIndex = -1;\n          }\n\n          return values;\n        }\n      }\n    }\n  }); // Radios and checkboxes getter/setter\n\n  jQuery.each([\"radio\", \"checkbox\"], function () {\n    jQuery.valHooks[this] = {\n      set: function set(elem, value) {\n        if (Array.isArray(value)) {\n          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;\n        }\n      }\n    };\n\n    if (!support.checkOn) {\n      jQuery.valHooks[this].get = function (elem) {\n        return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n      };\n    }\n  }); // Return jQuery for attributes-only inclusion\n\n  support.focusin = \"onfocusin\" in window;\n\n  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n      stopPropagationCallback = function stopPropagationCallback(e) {\n    e.stopPropagation();\n  };\n\n  jQuery.extend(jQuery.event, {\n    trigger: function trigger(event, data, elem, onlyHandlers) {\n      var i,\n          cur,\n          tmp,\n          bubbleType,\n          ontype,\n          handle,\n          special,\n          lastElement,\n          eventPath = [elem || document],\n          type = hasOwn.call(event, \"type\") ? event.type : event,\n          namespaces = hasOwn.call(event, \"namespace\") ? event.namespace.split(\".\") : [];\n      cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes\n\n      if (elem.nodeType === 3 || elem.nodeType === 8) {\n        return;\n      } // focus/blur morphs to focusin/out; ensure we're not firing them right now\n\n\n      if (rfocusMorph.test(type + jQuery.event.triggered)) {\n        return;\n      }\n\n      if (type.indexOf(\".\") > -1) {\n        // Namespaced trigger; create a regexp to match event type in handle()\n        namespaces = type.split(\".\");\n        type = namespaces.shift();\n        namespaces.sort();\n      }\n\n      ontype = type.indexOf(\":\") < 0 && \"on\" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string\n\n      event = event[jQuery.expando] ? event : new jQuery.Event(type, _typeof(event) === \"object\" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\n      event.isTrigger = onlyHandlers ? 2 : 3;\n      event.namespace = namespaces.join(\".\");\n      event.rnamespace = event.namespace ? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null; // Clean up the event in case it is being reused\n\n      event.result = undefined;\n\n      if (!event.target) {\n        event.target = elem;\n      } // Clone any incoming data and prepend the event, creating the handler arg list\n\n\n      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines\n\n      special = jQuery.event.special[type] || {};\n\n      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n        return;\n      } // Determine event propagation path in advance, per W3C events spec (#9951)\n      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\n\n      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {\n        bubbleType = special.delegateType || type;\n\n        if (!rfocusMorph.test(bubbleType + type)) {\n          cur = cur.parentNode;\n        }\n\n        for (; cur; cur = cur.parentNode) {\n          eventPath.push(cur);\n          tmp = cur;\n        } // Only add window if we got to document (e.g., not plain obj or detached DOM)\n\n\n        if (tmp === (elem.ownerDocument || document)) {\n          eventPath.push(tmp.defaultView || tmp.parentWindow || window);\n        }\n      } // Fire handlers on the event path\n\n\n      i = 0;\n\n      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\n        lastElement = cur;\n        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler\n\n        handle = (dataPriv.get(cur, \"events\") || Object.create(null))[event.type] && dataPriv.get(cur, \"handle\");\n\n        if (handle) {\n          handle.apply(cur, data);\n        } // Native handler\n\n\n        handle = ontype && cur[ontype];\n\n        if (handle && handle.apply && acceptData(cur)) {\n          event.result = handle.apply(cur, data);\n\n          if (event.result === false) {\n            event.preventDefault();\n          }\n        }\n      }\n\n      event.type = type; // If nobody prevented the default action, do it now\n\n      if (!onlyHandlers && !event.isDefaultPrevented()) {\n        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {\n          // Call a native DOM method on the target with the same name as the event.\n          // Don't do default actions on window, that's where global variables be (#6170)\n          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {\n            // Don't re-trigger an onFOO event when we call its FOO() method\n            tmp = elem[ontype];\n\n            if (tmp) {\n              elem[ontype] = null;\n            } // Prevent re-triggering of the same event, since we already bubbled it above\n\n\n            jQuery.event.triggered = type;\n\n            if (event.isPropagationStopped()) {\n              lastElement.addEventListener(type, stopPropagationCallback);\n            }\n\n            elem[type]();\n\n            if (event.isPropagationStopped()) {\n              lastElement.removeEventListener(type, stopPropagationCallback);\n            }\n\n            jQuery.event.triggered = undefined;\n\n            if (tmp) {\n              elem[ontype] = tmp;\n            }\n          }\n        }\n      }\n\n      return event.result;\n    },\n    // Piggyback on a donor event to simulate a different one\n    // Used only for `focus(in | out)` events\n    simulate: function simulate(type, elem, event) {\n      var e = jQuery.extend(new jQuery.Event(), event, {\n        type: type,\n        isSimulated: true\n      });\n      jQuery.event.trigger(e, null, elem);\n    }\n  });\n  jQuery.fn.extend({\n    trigger: function trigger(type, data) {\n      return this.each(function () {\n        jQuery.event.trigger(type, data, this);\n      });\n    },\n    triggerHandler: function triggerHandler(type, data) {\n      var elem = this[0];\n\n      if (elem) {\n        return jQuery.event.trigger(type, data, elem, true);\n      }\n    }\n  }); // Support: Firefox <=44\n  // Firefox doesn't have focus(in | out) events\n  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n  //\n  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n  // focus(in | out) events fire after focus & blur events,\n  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n\n  if (!support.focusin) {\n    jQuery.each({\n      focus: \"focusin\",\n      blur: \"focusout\"\n    }, function (orig, fix) {\n      // Attach a single capturing handler on the document while someone wants focusin/focusout\n      var handler = function handler(event) {\n        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));\n      };\n\n      jQuery.event.special[fix] = {\n        setup: function setup() {\n          // Handle: regular nodes (via `this.ownerDocument`), window\n          // (via `this.document`) & document (via `this`).\n          var doc = this.ownerDocument || this.document || this,\n              attaches = dataPriv.access(doc, fix);\n\n          if (!attaches) {\n            doc.addEventListener(orig, handler, true);\n          }\n\n          dataPriv.access(doc, fix, (attaches || 0) + 1);\n        },\n        teardown: function teardown() {\n          var doc = this.ownerDocument || this.document || this,\n              attaches = dataPriv.access(doc, fix) - 1;\n\n          if (!attaches) {\n            doc.removeEventListener(orig, handler, true);\n            dataPriv.remove(doc, fix);\n          } else {\n            dataPriv.access(doc, fix, attaches);\n          }\n        }\n      };\n    });\n  }\n\n  var location = window.location;\n  var nonce = {\n    guid: Date.now()\n  };\n  var rquery = /\\?/; // Cross-browser xml parsing\n\n  jQuery.parseXML = function (data) {\n    var xml, parserErrorElem;\n\n    if (!data || typeof data !== \"string\") {\n      return null;\n    } // Support: IE 9 - 11 only\n    // IE throws on parseFromString with invalid input.\n\n\n    try {\n      xml = new window.DOMParser().parseFromString(data, \"text/xml\");\n    } catch (e) {}\n\n    parserErrorElem = xml && xml.getElementsByTagName(\"parsererror\")[0];\n\n    if (!xml || parserErrorElem) {\n      jQuery.error(\"Invalid XML: \" + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function (el) {\n        return el.textContent;\n      }).join(\"\\n\") : data));\n    }\n\n    return xml;\n  };\n\n  var rbracket = /\\[\\]$/,\n      rCRLF = /\\r?\\n/g,\n      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n      rsubmittable = /^(?:input|select|textarea|keygen)/i;\n\n  function buildParams(prefix, obj, traditional, add) {\n    var name;\n\n    if (Array.isArray(obj)) {\n      // Serialize array item.\n      jQuery.each(obj, function (i, v) {\n        if (traditional || rbracket.test(prefix)) {\n          // Treat each array item as a scalar.\n          add(prefix, v);\n        } else {\n          // Item is non-scalar (array or object), encode its numeric index.\n          buildParams(prefix + \"[\" + (_typeof(v) === \"object\" && v != null ? i : \"\") + \"]\", v, traditional, add);\n        }\n      });\n    } else if (!traditional && toType(obj) === \"object\") {\n      // Serialize object item.\n      for (name in obj) {\n        buildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\n      }\n    } else {\n      // Serialize scalar item.\n      add(prefix, obj);\n    }\n  } // Serialize an array of form elements or a set of\n  // key/values into a query string\n\n\n  jQuery.param = function (a, traditional) {\n    var prefix,\n        s = [],\n        add = function add(key, valueOrFunction) {\n      // If value is a function, invoke it and use its return value\n      var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;\n      s[s.length] = encodeURIComponent(key) + \"=\" + encodeURIComponent(value == null ? \"\" : value);\n    };\n\n    if (a == null) {\n      return \"\";\n    } // If an array was passed in, assume that it is an array of form elements.\n\n\n    if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n      // Serialize the form elements\n      jQuery.each(a, function () {\n        add(this.name, this.value);\n      });\n    } else {\n      // If traditional, encode the \"old\" way (the way 1.3.2 or older\n      // did it), otherwise encode params recursively.\n      for (prefix in a) {\n        buildParams(prefix, a[prefix], traditional, add);\n      }\n    } // Return the resulting serialization\n\n\n    return s.join(\"&\");\n  };\n\n  jQuery.fn.extend({\n    serialize: function serialize() {\n      return jQuery.param(this.serializeArray());\n    },\n    serializeArray: function serializeArray() {\n      return this.map(function () {\n        // Can add propHook for \"elements\" to filter or add form elements\n        var elements = jQuery.prop(this, \"elements\");\n        return elements ? jQuery.makeArray(elements) : this;\n      }).filter(function () {\n        var type = this.type; // Use .is( \":disabled\" ) so that fieldset[disabled] works\n\n        return this.name && !jQuery(this).is(\":disabled\") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));\n      }).map(function (_i, elem) {\n        var val = jQuery(this).val();\n\n        if (val == null) {\n          return null;\n        }\n\n        if (Array.isArray(val)) {\n          return jQuery.map(val, function (val) {\n            return {\n              name: elem.name,\n              value: val.replace(rCRLF, \"\\r\\n\")\n            };\n          });\n        }\n\n        return {\n          name: elem.name,\n          value: val.replace(rCRLF, \"\\r\\n\")\n        };\n      }).get();\n    }\n  });\n  var r20 = /%20/g,\n      rhash = /#.*$/,\n      rantiCache = /([?&])_=[^&]*/,\n      rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n      // #7653, #8125, #8152: local protocol detection\n  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n      rnoContent = /^(?:GET|HEAD)$/,\n      rprotocol = /^\\/\\//,\n\n  /* Prefilters\n  * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n  * 2) These are called:\n  *    - BEFORE asking for a transport\n  *    - AFTER param serialization (s.data is a string if s.processData is true)\n  * 3) key is the dataType\n  * 4) the catchall symbol \"*\" can be used\n  * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n  */\n  prefilters = {},\n\n  /* Transports bindings\n  * 1) key is the dataType\n  * 2) the catchall symbol \"*\" can be used\n  * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n  */\n  transports = {},\n      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n  allTypes = \"*/\".concat(\"*\"),\n      // Anchor tag for parsing the document origin\n  originAnchor = document.createElement(\"a\");\n  originAnchor.href = location.href; // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\n  function addToPrefiltersOrTransports(structure) {\n    // dataTypeExpression is optional and defaults to \"*\"\n    return function (dataTypeExpression, func) {\n      if (typeof dataTypeExpression !== \"string\") {\n        func = dataTypeExpression;\n        dataTypeExpression = \"*\";\n      }\n\n      var dataType,\n          i = 0,\n          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];\n\n      if (isFunction(func)) {\n        // For each dataType in the dataTypeExpression\n        while (dataType = dataTypes[i++]) {\n          // Prepend if requested\n          if (dataType[0] === \"+\") {\n            dataType = dataType.slice(1) || \"*\";\n            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append\n          } else {\n            (structure[dataType] = structure[dataType] || []).push(func);\n          }\n        }\n      }\n    };\n  } // Base inspection function for prefilters and transports\n\n\n  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n    var inspected = {},\n        seekingTransport = structure === transports;\n\n    function inspect(dataType) {\n      var selected;\n      inspected[dataType] = true;\n      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n\n        if (typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[dataTypeOrTransport]) {\n          options.dataTypes.unshift(dataTypeOrTransport);\n          inspect(dataTypeOrTransport);\n          return false;\n        } else if (seekingTransport) {\n          return !(selected = dataTypeOrTransport);\n        }\n      });\n      return selected;\n    }\n\n    return inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n  } // A special extend for ajax options\n  // that takes \"flat\" options (not to be deep extended)\n  // Fixes #9887\n\n\n  function ajaxExtend(target, src) {\n    var key,\n        deep,\n        flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n    for (key in src) {\n      if (src[key] !== undefined) {\n        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n      }\n    }\n\n    if (deep) {\n      jQuery.extend(true, target, deep);\n    }\n\n    return target;\n  }\n  /* Handles responses to an ajax request:\n  * - finds the right dataType (mediates between content-type and expected dataType)\n  * - returns the corresponding response\n  */\n\n\n  function ajaxHandleResponses(s, jqXHR, responses) {\n    var ct,\n        type,\n        finalDataType,\n        firstDataType,\n        contents = s.contents,\n        dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process\n\n    while (dataTypes[0] === \"*\") {\n      dataTypes.shift();\n\n      if (ct === undefined) {\n        ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n      }\n    } // Check if we're dealing with a known content-type\n\n\n    if (ct) {\n      for (type in contents) {\n        if (contents[type] && contents[type].test(ct)) {\n          dataTypes.unshift(type);\n          break;\n        }\n      }\n    } // Check to see if we have a response for the expected dataType\n\n\n    if (dataTypes[0] in responses) {\n      finalDataType = dataTypes[0];\n    } else {\n      // Try convertible dataTypes\n      for (type in responses) {\n        if (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n          finalDataType = type;\n          break;\n        }\n\n        if (!firstDataType) {\n          firstDataType = type;\n        }\n      } // Or just use first one\n\n\n      finalDataType = finalDataType || firstDataType;\n    } // If we found a dataType\n    // We add the dataType to the list if needed\n    // and return the corresponding response\n\n\n    if (finalDataType) {\n      if (finalDataType !== dataTypes[0]) {\n        dataTypes.unshift(finalDataType);\n      }\n\n      return responses[finalDataType];\n    }\n  }\n  /* Chain conversions given the request and the original response\n  * Also sets the responseXXX fields on the jqXHR instance\n  */\n\n\n  function ajaxConvert(s, response, jqXHR, isSuccess) {\n    var conv2,\n        current,\n        conv,\n        tmp,\n        prev,\n        converters = {},\n        // Work with a copy of dataTypes in case we need to modify it for conversion\n    dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys\n\n    if (dataTypes[1]) {\n      for (conv in s.converters) {\n        converters[conv.toLowerCase()] = s.converters[conv];\n      }\n    }\n\n    current = dataTypes.shift(); // Convert to each sequential dataType\n\n    while (current) {\n      if (s.responseFields[current]) {\n        jqXHR[s.responseFields[current]] = response;\n      } // Apply the dataFilter if provided\n\n\n      if (!prev && isSuccess && s.dataFilter) {\n        response = s.dataFilter(response, s.dataType);\n      }\n\n      prev = current;\n      current = dataTypes.shift();\n\n      if (current) {\n        // There's only work to do if current dataType is non-auto\n        if (current === \"*\") {\n          current = prev; // Convert response if prev dataType is non-auto and differs from current\n        } else if (prev !== \"*\" && prev !== current) {\n          // Seek a direct converter\n          conv = converters[prev + \" \" + current] || converters[\"* \" + current]; // If none found, seek a pair\n\n          if (!conv) {\n            for (conv2 in converters) {\n              // If conv2 outputs current\n              tmp = conv2.split(\" \");\n\n              if (tmp[1] === current) {\n                // If prev can be converted to accepted input\n                conv = converters[prev + \" \" + tmp[0]] || converters[\"* \" + tmp[0]];\n\n                if (conv) {\n                  // Condense equivalence converters\n                  if (conv === true) {\n                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType\n                  } else if (converters[conv2] !== true) {\n                    current = tmp[0];\n                    dataTypes.unshift(tmp[1]);\n                  }\n\n                  break;\n                }\n              }\n            }\n          } // Apply converter (if not an equivalence)\n\n\n          if (conv !== true) {\n            // Unless errors are allowed to bubble, catch and return them\n            if (conv && s[\"throws\"]) {\n              response = conv(response);\n            } else {\n              try {\n                response = conv(response);\n              } catch (e) {\n                return {\n                  state: \"parsererror\",\n                  error: conv ? e : \"No conversion from \" + prev + \" to \" + current\n                };\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      state: \"success\",\n      data: response\n    };\n  }\n\n  jQuery.extend({\n    // Counter for holding the number of active queries\n    active: 0,\n    // Last-Modified header cache for next request\n    lastModified: {},\n    etag: {},\n    ajaxSettings: {\n      url: location.href,\n      type: \"GET\",\n      isLocal: rlocalProtocol.test(location.protocol),\n      global: true,\n      processData: true,\n      async: true,\n      contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n      /*\n      timeout: 0,\n      data: null,\n      dataType: null,\n      username: null,\n      password: null,\n      cache: null,\n      throws: false,\n      traditional: false,\n      headers: {},\n      */\n      accepts: {\n        \"*\": allTypes,\n        text: \"text/plain\",\n        html: \"text/html\",\n        xml: \"application/xml, text/xml\",\n        json: \"application/json, text/javascript\"\n      },\n      contents: {\n        xml: /\\bxml\\b/,\n        html: /\\bhtml/,\n        json: /\\bjson\\b/\n      },\n      responseFields: {\n        xml: \"responseXML\",\n        text: \"responseText\",\n        json: \"responseJSON\"\n      },\n      // Data converters\n      // Keys separate source (or catchall \"*\") and destination types with a single space\n      converters: {\n        // Convert anything to text\n        \"* text\": String,\n        // Text to html (true = no transformation)\n        \"text html\": true,\n        // Evaluate text as a json expression\n        \"text json\": JSON.parse,\n        // Parse text as xml\n        \"text xml\": jQuery.parseXML\n      },\n      // For options that shouldn't be deep extended:\n      // you can add your own custom options here if\n      // and when you create one that shouldn't be\n      // deep extended (see ajaxExtend)\n      flatOptions: {\n        url: true,\n        context: true\n      }\n    },\n    // Creates a full fledged settings object into target\n    // with both ajaxSettings and settings fields.\n    // If target is omitted, writes into ajaxSettings.\n    ajaxSetup: function ajaxSetup(target, settings) {\n      return settings ? // Building a settings object\n      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings\n      ajaxExtend(jQuery.ajaxSettings, target);\n    },\n    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n    ajaxTransport: addToPrefiltersOrTransports(transports),\n    // Main method\n    ajax: function ajax(url, options) {\n      // If url is an object, simulate pre-1.5 signature\n      if (_typeof(url) === \"object\") {\n        options = url;\n        url = undefined;\n      } // Force options to be an object\n\n\n      options = options || {};\n\n      var transport,\n          // URL without anti-cache param\n      cacheURL,\n          // Response headers\n      responseHeadersString,\n          responseHeaders,\n          // timeout handle\n      timeoutTimer,\n          // Url cleanup var\n      urlAnchor,\n          // Request state (becomes false upon send and true upon completion)\n      completed,\n          // To know if global events are to be dispatched\n      fireGlobals,\n          // Loop variable\n      i,\n          // uncached part of the url\n      uncached,\n          // Create the final options object\n      s = jQuery.ajaxSetup({}, options),\n          // Callbacks context\n      callbackContext = s.context || s,\n          // Context for global events is callbackContext if it is a DOM node or jQuery collection\n      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\n          // Deferreds\n      deferred = jQuery.Deferred(),\n          completeDeferred = jQuery.Callbacks(\"once memory\"),\n          // Status-dependent callbacks\n      _statusCode = s.statusCode || {},\n          // Headers (they are sent all at once)\n      requestHeaders = {},\n          requestHeadersNames = {},\n          // Default abort message\n      strAbort = \"canceled\",\n          // Fake xhr\n      jqXHR = {\n        readyState: 0,\n        // Builds headers hashtable if needed\n        getResponseHeader: function getResponseHeader(key) {\n          var match;\n\n          if (completed) {\n            if (!responseHeaders) {\n              responseHeaders = {};\n\n              while (match = rheaders.exec(responseHeadersString)) {\n                responseHeaders[match[1].toLowerCase() + \" \"] = (responseHeaders[match[1].toLowerCase() + \" \"] || []).concat(match[2]);\n              }\n            }\n\n            match = responseHeaders[key.toLowerCase() + \" \"];\n          }\n\n          return match == null ? null : match.join(\", \");\n        },\n        // Raw string\n        getAllResponseHeaders: function getAllResponseHeaders() {\n          return completed ? responseHeadersString : null;\n        },\n        // Caches the header\n        setRequestHeader: function setRequestHeader(name, value) {\n          if (completed == null) {\n            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;\n            requestHeaders[name] = value;\n          }\n\n          return this;\n        },\n        // Overrides response content-type header\n        overrideMimeType: function overrideMimeType(type) {\n          if (completed == null) {\n            s.mimeType = type;\n          }\n\n          return this;\n        },\n        // Status-dependent callbacks\n        statusCode: function statusCode(map) {\n          var code;\n\n          if (map) {\n            if (completed) {\n              // Execute the appropriate callbacks\n              jqXHR.always(map[jqXHR.status]);\n            } else {\n              // Lazy-add the new callbacks in a way that preserves old ones\n              for (code in map) {\n                _statusCode[code] = [_statusCode[code], map[code]];\n              }\n            }\n          }\n\n          return this;\n        },\n        // Cancel the request\n        abort: function abort(statusText) {\n          var finalText = statusText || strAbort;\n\n          if (transport) {\n            transport.abort(finalText);\n          }\n\n          done(0, finalText);\n          return this;\n        }\n      }; // Attach deferreds\n\n\n      deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)\n      // Handle falsy url in the settings object (#10093: consistency with old signature)\n      // We also use the url parameter if available\n\n      s.url = ((url || s.url || location.href) + \"\").replace(rprotocol, location.protocol + \"//\"); // Alias method option to type as per ticket #12004\n\n      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list\n\n      s.dataTypes = (s.dataType || \"*\").toLowerCase().match(rnothtmlwhite) || [\"\"]; // A cross-domain request is in order when the origin doesn't match the current origin.\n\n      if (s.crossDomain == null) {\n        urlAnchor = document.createElement(\"a\"); // Support: IE <=8 - 11, Edge 12 - 15\n        // IE throws exception on accessing the href property if url is malformed,\n        // e.g. http://example.com:80x/\n\n        try {\n          urlAnchor.href = s.url; // Support: IE <=8 - 11 only\n          // Anchor's host property isn't correctly set when s.url is relative\n\n          urlAnchor.href = urlAnchor.href;\n          s.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !== urlAnchor.protocol + \"//\" + urlAnchor.host;\n        } catch (e) {\n          // If there is an error parsing the URL, assume it is crossDomain,\n          // it can be rejected by the transport if it is invalid\n          s.crossDomain = true;\n        }\n      } // Convert data if not already a string\n\n\n      if (s.data && s.processData && typeof s.data !== \"string\") {\n        s.data = jQuery.param(s.data, s.traditional);\n      } // Apply prefilters\n\n\n      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there\n\n      if (completed) {\n        return jqXHR;\n      } // We can fire global events as of now if asked to\n      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\n\n      fireGlobals = jQuery.event && s.global; // Watch for a new set of requests\n\n      if (fireGlobals && jQuery.active++ === 0) {\n        jQuery.event.trigger(\"ajaxStart\");\n      } // Uppercase the type\n\n\n      s.type = s.type.toUpperCase(); // Determine if request has content\n\n      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since\n      // and/or If-None-Match header later on\n      // Remove hash to simplify url manipulation\n\n      cacheURL = s.url.replace(rhash, \"\"); // More options handling for requests with no content\n\n      if (!s.hasContent) {\n        // Remember the hash so we can put it back\n        uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url\n\n        if (s.data && (s.processData || typeof s.data === \"string\")) {\n          cacheURL += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data; // #9682: remove data so that it's not used in an eventual retry\n\n          delete s.data;\n        } // Add or update anti-cache param if needed\n\n\n        if (s.cache === false) {\n          cacheURL = cacheURL.replace(rantiCache, \"$1\");\n          uncached = (rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + nonce.guid++ + uncached;\n        } // Put hash and anti-cache on the URL that will be requested (gh-1732)\n\n\n        s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)\n      } else if (s.data && s.processData && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0) {\n        s.data = s.data.replace(r20, \"+\");\n      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\n\n      if (s.ifModified) {\n        if (jQuery.lastModified[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\n        }\n\n        if (jQuery.etag[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\n        }\n      } // Set the correct header, if data is being sent\n\n\n      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n        jqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n      } // Set the Accepts header for the server, depending on the dataType\n\n\n      jqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]); // Check for headers option\n\n      for (i in s.headers) {\n        jqXHR.setRequestHeader(i, s.headers[i]);\n      } // Allow custom headers/mimetypes and early abort\n\n\n      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {\n        // Abort if not done already and return\n        return jqXHR.abort();\n      } // Aborting is no longer a cancellation\n\n\n      strAbort = \"abort\"; // Install callbacks on deferreds\n\n      completeDeferred.add(s.complete);\n      jqXHR.done(s.success);\n      jqXHR.fail(s.error); // Get transport\n\n      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort\n\n      if (!transport) {\n        done(-1, \"No Transport\");\n      } else {\n        jqXHR.readyState = 1; // Send global event\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\n        } // If request was aborted inside ajaxSend, stop there\n\n\n        if (completed) {\n          return jqXHR;\n        } // Timeout\n\n\n        if (s.async && s.timeout > 0) {\n          timeoutTimer = window.setTimeout(function () {\n            jqXHR.abort(\"timeout\");\n          }, s.timeout);\n        }\n\n        try {\n          completed = false;\n          transport.send(requestHeaders, done);\n        } catch (e) {\n          // Rethrow post-completion exceptions\n          if (completed) {\n            throw e;\n          } // Propagate others as results\n\n\n          done(-1, e);\n        }\n      } // Callback for when everything is done\n\n\n      function done(status, nativeStatusText, responses, headers) {\n        var isSuccess,\n            success,\n            error,\n            response,\n            modified,\n            statusText = nativeStatusText; // Ignore repeat invocations\n\n        if (completed) {\n          return;\n        }\n\n        completed = true; // Clear timeout if it exists\n\n        if (timeoutTimer) {\n          window.clearTimeout(timeoutTimer);\n        } // Dereference transport for early garbage collection\n        // (no matter how long the jqXHR object will be used)\n\n\n        transport = undefined; // Cache response headers\n\n        responseHeadersString = headers || \"\"; // Set readyState\n\n        jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful\n\n        isSuccess = status >= 200 && status < 300 || status === 304; // Get response data\n\n        if (responses) {\n          response = ajaxHandleResponses(s, jqXHR, responses);\n        } // Use a noop converter for missing script but not if jsonp\n\n\n        if (!isSuccess && jQuery.inArray(\"script\", s.dataTypes) > -1 && jQuery.inArray(\"json\", s.dataTypes) < 0) {\n          s.converters[\"text script\"] = function () {};\n        } // Convert no matter what (that way responseXXX fields are always set)\n\n\n        response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining\n\n        if (isSuccess) {\n          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n          if (s.ifModified) {\n            modified = jqXHR.getResponseHeader(\"Last-Modified\");\n\n            if (modified) {\n              jQuery.lastModified[cacheURL] = modified;\n            }\n\n            modified = jqXHR.getResponseHeader(\"etag\");\n\n            if (modified) {\n              jQuery.etag[cacheURL] = modified;\n            }\n          } // if no content\n\n\n          if (status === 204 || s.type === \"HEAD\") {\n            statusText = \"nocontent\"; // if not modified\n          } else if (status === 304) {\n            statusText = \"notmodified\"; // If we have data, let's convert it\n          } else {\n            statusText = response.state;\n            success = response.data;\n            error = response.error;\n            isSuccess = !error;\n          }\n        } else {\n          // Extract error from statusText and normalize for non-aborts\n          error = statusText;\n\n          if (status || !statusText) {\n            statusText = \"error\";\n\n            if (status < 0) {\n              status = 0;\n            }\n          }\n        } // Set data for the fake xhr object\n\n\n        jqXHR.status = status;\n        jqXHR.statusText = (nativeStatusText || statusText) + \"\"; // Success/Error\n\n        if (isSuccess) {\n          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n        } else {\n          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n        } // Status-dependent callbacks\n\n\n        jqXHR.statusCode(_statusCode);\n        _statusCode = undefined;\n\n        if (fireGlobals) {\n          globalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [jqXHR, s, isSuccess ? success : error]);\n        } // Complete\n\n\n        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]); // Handle the global AJAX counter\n\n          if (! --jQuery.active) {\n            jQuery.event.trigger(\"ajaxStop\");\n          }\n        }\n      }\n\n      return jqXHR;\n    },\n    getJSON: function getJSON(url, data, callback) {\n      return jQuery.get(url, data, callback, \"json\");\n    },\n    getScript: function getScript(url, callback) {\n      return jQuery.get(url, undefined, callback, \"script\");\n    }\n  });\n  jQuery.each([\"get\", \"post\"], function (_i, method) {\n    jQuery[method] = function (url, data, callback, type) {\n      // Shift arguments if data argument was omitted\n      if (isFunction(data)) {\n        type = type || callback;\n        callback = data;\n        data = undefined;\n      } // The url can be an options object (which then must have .url)\n\n\n      return jQuery.ajax(jQuery.extend({\n        url: url,\n        type: method,\n        dataType: type,\n        data: data,\n        success: callback\n      }, jQuery.isPlainObject(url) && url));\n    };\n  });\n  jQuery.ajaxPrefilter(function (s) {\n    var i;\n\n    for (i in s.headers) {\n      if (i.toLowerCase() === \"content-type\") {\n        s.contentType = s.headers[i] || \"\";\n      }\n    }\n  });\n\n  jQuery._evalUrl = function (url, options, doc) {\n    return jQuery.ajax({\n      url: url,\n      // Make this explicit, since user can override this through ajaxSetup (#11264)\n      type: \"GET\",\n      dataType: \"script\",\n      cache: true,\n      async: false,\n      global: false,\n      // Only evaluate the response if it is successful (gh-4126)\n      // dataFilter is not invoked for failure responses, so using it instead\n      // of the default converter is kludgy but it works.\n      converters: {\n        \"text script\": function textScript() {}\n      },\n      dataFilter: function dataFilter(response) {\n        jQuery.globalEval(response, options, doc);\n      }\n    });\n  };\n\n  jQuery.fn.extend({\n    wrapAll: function wrapAll(html) {\n      var wrap;\n\n      if (this[0]) {\n        if (isFunction(html)) {\n          html = html.call(this[0]);\n        } // The elements to wrap the target around\n\n\n        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n\n        if (this[0].parentNode) {\n          wrap.insertBefore(this[0]);\n        }\n\n        wrap.map(function () {\n          var elem = this;\n\n          while (elem.firstElementChild) {\n            elem = elem.firstElementChild;\n          }\n\n          return elem;\n        }).append(this);\n      }\n\n      return this;\n    },\n    wrapInner: function wrapInner(html) {\n      if (isFunction(html)) {\n        return this.each(function (i) {\n          jQuery(this).wrapInner(html.call(this, i));\n        });\n      }\n\n      return this.each(function () {\n        var self = jQuery(this),\n            contents = self.contents();\n\n        if (contents.length) {\n          contents.wrapAll(html);\n        } else {\n          self.append(html);\n        }\n      });\n    },\n    wrap: function wrap(html) {\n      var htmlIsFunction = isFunction(html);\n      return this.each(function (i) {\n        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);\n      });\n    },\n    unwrap: function unwrap(selector) {\n      this.parent(selector).not(\"body\").each(function () {\n        jQuery(this).replaceWith(this.childNodes);\n      });\n      return this;\n    }\n  });\n\n  jQuery.expr.pseudos.hidden = function (elem) {\n    return !jQuery.expr.pseudos.visible(elem);\n  };\n\n  jQuery.expr.pseudos.visible = function (elem) {\n    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);\n  };\n\n  jQuery.ajaxSettings.xhr = function () {\n    try {\n      return new window.XMLHttpRequest();\n    } catch (e) {}\n  };\n\n  var xhrSuccessStatus = {\n    // File protocol always yields status code 0, assume 200\n    0: 200,\n    // Support: IE <=9 only\n    // #1450: sometimes IE returns 1223 when it should be 204\n    1223: 204\n  },\n      xhrSupported = jQuery.ajaxSettings.xhr();\n  support.cors = !!xhrSupported && \"withCredentials\" in xhrSupported;\n  support.ajax = xhrSupported = !!xhrSupported;\n  jQuery.ajaxTransport(function (options) {\n    var _callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest\n\n\n    if (support.cors || xhrSupported && !options.crossDomain) {\n      return {\n        send: function send(headers, complete) {\n          var i,\n              xhr = options.xhr();\n          xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided\n\n          if (options.xhrFields) {\n            for (i in options.xhrFields) {\n              xhr[i] = options.xhrFields[i];\n            }\n          } // Override mime type if needed\n\n\n          if (options.mimeType && xhr.overrideMimeType) {\n            xhr.overrideMimeType(options.mimeType);\n          } // X-Requested-With header\n          // For cross-domain requests, seeing as conditions for a preflight are\n          // akin to a jigsaw puzzle, we simply never set it to be sure.\n          // (it can always be set on a per-request basis or even using ajaxSetup)\n          // For same-domain requests, won't change header if already provided.\n\n\n          if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n            headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n          } // Set headers\n\n\n          for (i in headers) {\n            xhr.setRequestHeader(i, headers[i]);\n          } // Callback\n\n\n          _callback = function callback(type) {\n            return function () {\n              if (_callback) {\n                _callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;\n\n                if (type === \"abort\") {\n                  xhr.abort();\n                } else if (type === \"error\") {\n                  // Support: IE <=9 only\n                  // On a manual native abort, IE9 throws\n                  // errors on any property access that is not readyState\n                  if (typeof xhr.status !== \"number\") {\n                    complete(0, \"error\");\n                  } else {\n                    complete( // File: protocol always yields status 0; see #8605, #14207\n                    xhr.status, xhr.statusText);\n                  }\n                } else {\n                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only\n                  // IE9 has no XHR2 but throws on binary (trac-11426)\n                  // For XHR2 non-text, let the caller handle it (gh-2498)\n                  (xhr.responseType || \"text\") !== \"text\" || typeof xhr.responseText !== \"string\" ? {\n                    binary: xhr.response\n                  } : {\n                    text: xhr.responseText\n                  }, xhr.getAllResponseHeaders());\n                }\n              }\n            };\n          }; // Listen to events\n\n\n          xhr.onload = _callback();\n          errorCallback = xhr.onerror = xhr.ontimeout = _callback(\"error\"); // Support: IE 9 only\n          // Use onreadystatechange to replace onabort\n          // to handle uncaught aborts\n\n          if (xhr.onabort !== undefined) {\n            xhr.onabort = errorCallback;\n          } else {\n            xhr.onreadystatechange = function () {\n              // Check readyState before timeout as it changes\n              if (xhr.readyState === 4) {\n                // Allow onerror to be called first,\n                // but that will not handle a native abort\n                // Also, save errorCallback to a variable\n                // as xhr.onerror cannot be accessed\n                window.setTimeout(function () {\n                  if (_callback) {\n                    errorCallback();\n                  }\n                });\n              }\n            };\n          } // Create the abort callback\n\n\n          _callback = _callback(\"abort\");\n\n          try {\n            // Do send the request (this may raise an exception)\n            xhr.send(options.hasContent && options.data || null);\n          } catch (e) {\n            // #14683: Only rethrow if this hasn't been notified as an error yet\n            if (_callback) {\n              throw e;\n            }\n          }\n        },\n        abort: function abort() {\n          if (_callback) {\n            _callback();\n          }\n        }\n      };\n    }\n  }); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n\n  jQuery.ajaxPrefilter(function (s) {\n    if (s.crossDomain) {\n      s.contents.script = false;\n    }\n  }); // Install script dataType\n\n  jQuery.ajaxSetup({\n    accepts: {\n      script: \"text/javascript, application/javascript, \" + \"application/ecmascript, application/x-ecmascript\"\n    },\n    contents: {\n      script: /\\b(?:java|ecma)script\\b/\n    },\n    converters: {\n      \"text script\": function textScript(text) {\n        jQuery.globalEval(text);\n        return text;\n      }\n    }\n  }); // Handle cache's special case and crossDomain\n\n  jQuery.ajaxPrefilter(\"script\", function (s) {\n    if (s.cache === undefined) {\n      s.cache = false;\n    }\n\n    if (s.crossDomain) {\n      s.type = \"GET\";\n    }\n  }); // Bind script tag hack transport\n\n  jQuery.ajaxTransport(\"script\", function (s) {\n    // This transport only deals with cross domain or forced-by-attrs requests\n    if (s.crossDomain || s.scriptAttrs) {\n      var script, _callback2;\n\n      return {\n        send: function send(_, complete) {\n          script = jQuery(\"<script>\").attr(s.scriptAttrs || {}).prop({\n            charset: s.scriptCharset,\n            src: s.url\n          }).on(\"load error\", _callback2 = function callback(evt) {\n            script.remove();\n            _callback2 = null;\n\n            if (evt) {\n              complete(evt.type === \"error\" ? 404 : 200, evt.type);\n            }\n          }); // Use native DOM manipulation to avoid our domManip AJAX trickery\n\n          document.head.appendChild(script[0]);\n        },\n        abort: function abort() {\n          if (_callback2) {\n            _callback2();\n          }\n        }\n      };\n    }\n  });\n  var oldCallbacks = [],\n      rjsonp = /(=)\\?(?=&|$)|\\?\\?/; // Default jsonp settings\n\n  jQuery.ajaxSetup({\n    jsonp: \"callback\",\n    jsonpCallback: function jsonpCallback() {\n      var callback = oldCallbacks.pop() || jQuery.expando + \"_\" + nonce.guid++;\n      this[callback] = true;\n      return callback;\n    }\n  }); // Detect, normalize options and install callbacks for jsonp requests\n\n  jQuery.ajaxPrefilter(\"json jsonp\", function (s, originalSettings, jqXHR) {\n    var callbackName,\n        overwritten,\n        responseContainer,\n        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? \"url\" : typeof s.data === \"string\" && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0 && rjsonp.test(s.data) && \"data\"); // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\n    if (jsonProp || s.dataTypes[0] === \"jsonp\") {\n      // Get callback name, remembering preexisting value associated with it\n      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data\n\n      if (jsonProp) {\n        s[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\n      } else if (s.jsonp !== false) {\n        s.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.jsonp + \"=\" + callbackName;\n      } // Use data converter to retrieve json after script execution\n\n\n      s.converters[\"script json\"] = function () {\n        if (!responseContainer) {\n          jQuery.error(callbackName + \" was not called\");\n        }\n\n        return responseContainer[0];\n      }; // Force json dataType\n\n\n      s.dataTypes[0] = \"json\"; // Install callback\n\n      overwritten = window[callbackName];\n\n      window[callbackName] = function () {\n        responseContainer = arguments;\n      }; // Clean-up function (fires after converters)\n\n\n      jqXHR.always(function () {\n        // If previous value didn't exist - remove it\n        if (overwritten === undefined) {\n          jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value\n        } else {\n          window[callbackName] = overwritten;\n        } // Save back as free\n\n\n        if (s[callbackName]) {\n          // Make sure that re-using the options doesn't screw things around\n          s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use\n\n          oldCallbacks.push(callbackName);\n        } // Call if it was a function and we have a response\n\n\n        if (responseContainer && isFunction(overwritten)) {\n          overwritten(responseContainer[0]);\n        }\n\n        responseContainer = overwritten = undefined;\n      }); // Delegate to script\n\n      return \"script\";\n    }\n  }); // Support: Safari 8 only\n  // In Safari 8 documents created via document.implementation.createHTMLDocument\n  // collapse sibling forms: the second one becomes a child of the first one.\n  // Because of that, this security measure has to be disabled in Safari 8.\n  // https://bugs.webkit.org/show_bug.cgi?id=137337\n\n  support.createHTMLDocument = function () {\n    var body = document.implementation.createHTMLDocument(\"\").body;\n    body.innerHTML = \"<form></form><form></form>\";\n    return body.childNodes.length === 2;\n  }(); // Argument \"data\" should be string of html\n  // context (optional): If specified, the fragment will be created in this context,\n  // defaults to document\n  // keepScripts (optional): If true, will include scripts passed in the html string\n\n\n  jQuery.parseHTML = function (data, context, keepScripts) {\n    if (typeof data !== \"string\") {\n      return [];\n    }\n\n    if (typeof context === \"boolean\") {\n      keepScripts = context;\n      context = false;\n    }\n\n    var base, parsed, scripts;\n\n    if (!context) {\n      // Stop scripts or inline event handlers from being executed immediately\n      // by using document.implementation\n      if (support.createHTMLDocument) {\n        context = document.implementation.createHTMLDocument(\"\"); // Set the base href for the created document\n        // so any parsed elements with URLs\n        // are based on the document's URL (gh-2965)\n\n        base = context.createElement(\"base\");\n        base.href = document.location.href;\n        context.head.appendChild(base);\n      } else {\n        context = document;\n      }\n    }\n\n    parsed = rsingleTag.exec(data);\n    scripts = !keepScripts && []; // Single tag\n\n    if (parsed) {\n      return [context.createElement(parsed[1])];\n    }\n\n    parsed = buildFragment([data], context, scripts);\n\n    if (scripts && scripts.length) {\n      jQuery(scripts).remove();\n    }\n\n    return jQuery.merge([], parsed.childNodes);\n  };\n  /**\n   * Load a url into a page\n   */\n\n\n  jQuery.fn.load = function (url, params, callback) {\n    var selector,\n        type,\n        response,\n        self = this,\n        off = url.indexOf(\" \");\n\n    if (off > -1) {\n      selector = stripAndCollapse(url.slice(off));\n      url = url.slice(0, off);\n    } // If it's a function\n\n\n    if (isFunction(params)) {\n      // We assume that it's the callback\n      callback = params;\n      params = undefined; // Otherwise, build a param string\n    } else if (params && _typeof(params) === \"object\") {\n      type = \"POST\";\n    } // If we have elements to modify, make the request\n\n\n    if (self.length > 0) {\n      jQuery.ajax({\n        url: url,\n        // If \"type\" variable is undefined, then \"GET\" method will be used.\n        // Make value of this field explicit since\n        // user can override it through ajaxSetup method\n        type: type || \"GET\",\n        dataType: \"html\",\n        data: params\n      }).done(function (responseText) {\n        // Save response for use in complete callback\n        response = arguments;\n        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div\n        // Exclude scripts to avoid IE 'Permission Denied' errors\n        jQuery(\"<div>\").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result\n        responseText); // If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n        // but they are ignored because response was set above.\n        // If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n      }).always(callback && function (jqXHR, status) {\n        self.each(function () {\n          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);\n        });\n      });\n    }\n\n    return this;\n  };\n\n  jQuery.expr.pseudos.animated = function (elem) {\n    return jQuery.grep(jQuery.timers, function (fn) {\n      return elem === fn.elem;\n    }).length;\n  };\n\n  jQuery.offset = {\n    setOffset: function setOffset(elem, options, i) {\n      var curPosition,\n          curLeft,\n          curCSSTop,\n          curTop,\n          curOffset,\n          curCSSLeft,\n          calculatePosition,\n          position = jQuery.css(elem, \"position\"),\n          curElem = jQuery(elem),\n          props = {}; // Set position first, in-case top/left are set even on static elem\n\n      if (position === \"static\") {\n        elem.style.position = \"relative\";\n      }\n\n      curOffset = curElem.offset();\n      curCSSTop = jQuery.css(elem, \"top\");\n      curCSSLeft = jQuery.css(elem, \"left\");\n      calculatePosition = (position === \"absolute\" || position === \"fixed\") && (curCSSTop + curCSSLeft).indexOf(\"auto\") > -1; // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n\n      if (calculatePosition) {\n        curPosition = curElem.position();\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (isFunction(options)) {\n        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n        options = options.call(elem, i, jQuery.extend({}, curOffset));\n      }\n\n      if (options.top != null) {\n        props.top = options.top - curOffset.top + curTop;\n      }\n\n      if (options.left != null) {\n        props.left = options.left - curOffset.left + curLeft;\n      }\n\n      if (\"using\" in options) {\n        options.using.call(elem, props);\n      } else {\n        curElem.css(props);\n      }\n    }\n  };\n  jQuery.fn.extend({\n    // offset() relates an element's border box to the document origin\n    offset: function offset(options) {\n      // Preserve chaining for setter\n      if (arguments.length) {\n        return options === undefined ? this : this.each(function (i) {\n          jQuery.offset.setOffset(this, options, i);\n        });\n      }\n\n      var rect,\n          win,\n          elem = this[0];\n\n      if (!elem) {\n        return;\n      } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n      // Support: IE <=11 only\n      // Running getBoundingClientRect on a\n      // disconnected node in IE throws an error\n\n\n      if (!elem.getClientRects().length) {\n        return {\n          top: 0,\n          left: 0\n        };\n      } // Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\n\n      rect = elem.getBoundingClientRect();\n      win = elem.ownerDocument.defaultView;\n      return {\n        top: rect.top + win.pageYOffset,\n        left: rect.left + win.pageXOffset\n      };\n    },\n    // position() relates an element's margin box to its offset parent's padding box\n    // This corresponds to the behavior of CSS absolute positioning\n    position: function position() {\n      if (!this[0]) {\n        return;\n      }\n\n      var offsetParent,\n          offset,\n          doc,\n          elem = this[0],\n          parentOffset = {\n        top: 0,\n        left: 0\n      }; // position:fixed elements are offset from the viewport, which itself always has zero offset\n\n      if (jQuery.css(elem, \"position\") === \"fixed\") {\n        // Assume position:fixed implies availability of getBoundingClientRect\n        offset = elem.getBoundingClientRect();\n      } else {\n        offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element\n        // when a statically positioned element is identified\n\n        doc = elem.ownerDocument;\n        offsetParent = elem.offsetParent || doc.documentElement;\n\n        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, \"position\") === \"static\") {\n          offsetParent = offsetParent.parentNode;\n        }\n\n        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {\n          // Incorporate borders into its offset, since they are outside its content origin\n          parentOffset = jQuery(offsetParent).offset();\n          parentOffset.top += jQuery.css(offsetParent, \"borderTopWidth\", true);\n          parentOffset.left += jQuery.css(offsetParent, \"borderLeftWidth\", true);\n        }\n      } // Subtract parent offsets and element margins\n\n\n      return {\n        top: offset.top - parentOffset.top - jQuery.css(elem, \"marginTop\", true),\n        left: offset.left - parentOffset.left - jQuery.css(elem, \"marginLeft\", true)\n      };\n    },\n    // This method will return documentElement in the following cases:\n    // 1) For the element inside the iframe without offsetParent, this method will return\n    //    documentElement of the parent window\n    // 2) For the hidden or detached element\n    // 3) For body or html element, i.e. in case of the html node - it will return itself\n    //\n    // but those exceptions were never presented as a real life use-cases\n    // and might be considered as more preferable results.\n    //\n    // This logic, however, is not guaranteed and can change at any point in the future\n    offsetParent: function offsetParent() {\n      return this.map(function () {\n        var offsetParent = this.offsetParent;\n\n        while (offsetParent && jQuery.css(offsetParent, \"position\") === \"static\") {\n          offsetParent = offsetParent.offsetParent;\n        }\n\n        return offsetParent || documentElement;\n      });\n    }\n  }); // Create scrollLeft and scrollTop methods\n\n  jQuery.each({\n    scrollLeft: \"pageXOffset\",\n    scrollTop: \"pageYOffset\"\n  }, function (method, prop) {\n    var top = \"pageYOffset\" === prop;\n\n    jQuery.fn[method] = function (val) {\n      return access(this, function (elem, method, val) {\n        // Coalesce documents and windows\n        var win;\n\n        if (isWindow(elem)) {\n          win = elem;\n        } else if (elem.nodeType === 9) {\n          win = elem.defaultView;\n        }\n\n        if (val === undefined) {\n          return win ? win[prop] : elem[method];\n        }\n\n        if (win) {\n          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);\n        } else {\n          elem[method] = val;\n        }\n      }, method, val, arguments.length);\n    };\n  }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49\n  // Add the top/left cssHooks using jQuery.fn.position\n  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n  // getComputedStyle returns percent when specified for top/left/bottom/right;\n  // rather than make the css module depend on the offset module, just check for it here\n\n  jQuery.each([\"top\", \"left\"], function (_i, prop) {\n    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\n      if (computed) {\n        computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset\n\n        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + \"px\" : computed;\n      }\n    });\n  }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\n  jQuery.each({\n    Height: \"height\",\n    Width: \"width\"\n  }, function (name, type) {\n    jQuery.each({\n      padding: \"inner\" + name,\n      content: type,\n      \"\": \"outer\" + name\n    }, function (defaultExtra, funcName) {\n      // Margin is only for outerHeight, outerWidth\n      jQuery.fn[funcName] = function (margin, value) {\n        var chainable = arguments.length && (defaultExtra || typeof margin !== \"boolean\"),\n            extra = defaultExtra || (margin === true || value === true ? \"margin\" : \"border\");\n        return access(this, function (elem, type, value) {\n          var doc;\n\n          if (isWindow(elem)) {\n            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n            return funcName.indexOf(\"outer\") === 0 ? elem[\"inner\" + name] : elem.document.documentElement[\"client\" + name];\n          } // Get document width or height\n\n\n          if (elem.nodeType === 9) {\n            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n            // whichever is greatest\n\n            return Math.max(elem.body[\"scroll\" + name], doc[\"scroll\" + name], elem.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n          }\n\n          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat\n          jQuery.css(elem, type, extra) : // Set width or height on the element\n          jQuery.style(elem, type, value, extra);\n        }, type, chainable ? margin : undefined, chainable);\n      };\n    });\n  });\n  jQuery.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (_i, type) {\n    jQuery.fn[type] = function (fn) {\n      return this.on(type, fn);\n    };\n  });\n  jQuery.fn.extend({\n    bind: function bind(types, data, fn) {\n      return this.on(types, null, data, fn);\n    },\n    unbind: function unbind(types, fn) {\n      return this.off(types, null, fn);\n    },\n    delegate: function delegate(selector, types, data, fn) {\n      return this.on(types, selector, data, fn);\n    },\n    undelegate: function undelegate(selector, types, fn) {\n      // ( namespace ) or ( selector, types [, fn] )\n      return arguments.length === 1 ? this.off(selector, \"**\") : this.off(types, selector || \"**\", fn);\n    },\n    hover: function hover(fnOver, fnOut) {\n      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\n    }\n  });\n  jQuery.each((\"blur focus focusin focusout resize scroll click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup contextmenu\").split(\" \"), function (_i, name) {\n    // Handle event binding\n    jQuery.fn[name] = function (data, fn) {\n      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\n    };\n  }); // Support: Android <=4.0 only\n  // Make sure we trim BOM and NBSP\n\n  var rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g; // Bind a function to a context, optionally partially applying any\n  // arguments.\n  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n  // However, it is not slated for removal any time soon\n\n  jQuery.proxy = function (fn, context) {\n    var tmp, args, proxy;\n\n    if (typeof context === \"string\") {\n      tmp = fn[context];\n      context = fn;\n      fn = tmp;\n    } // Quick check to determine if target is callable, in the spec\n    // this throws a TypeError, but we will just return undefined.\n\n\n    if (!isFunction(fn)) {\n      return undefined;\n    } // Simulated bind\n\n\n    args = _slice.call(arguments, 2);\n\n    proxy = function proxy() {\n      return fn.apply(context || this, args.concat(_slice.call(arguments)));\n    }; // Set the guid of unique handler to the same of original handler, so it can be removed\n\n\n    proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n    return proxy;\n  };\n\n  jQuery.holdReady = function (hold) {\n    if (hold) {\n      jQuery.readyWait++;\n    } else {\n      jQuery.ready(true);\n    }\n  };\n\n  jQuery.isArray = Array.isArray;\n  jQuery.parseJSON = JSON.parse;\n  jQuery.nodeName = nodeName;\n  jQuery.isFunction = isFunction;\n  jQuery.isWindow = isWindow;\n  jQuery.camelCase = camelCase;\n  jQuery.type = toType;\n  jQuery.now = Date.now;\n\n  jQuery.isNumeric = function (obj) {\n    // As of jQuery 3.0, isNumeric is limited to\n    // strings and numbers (primitives or objects)\n    // that can be coerced to finite numbers (gh-2662)\n    var type = jQuery.type(obj);\n    return (type === \"number\" || type === \"string\") && // parseFloat NaNs numeric-cast false positives (\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    !isNaN(obj - parseFloat(obj));\n  };\n\n  jQuery.trim = function (text) {\n    return text == null ? \"\" : (text + \"\").replace(rtrim, \"\");\n  }; // Register as a named AMD module, since jQuery can be concatenated with other\n  // files that may use define, but not via a proper concatenation script that\n  // understands anonymous AMD modules. A named AMD is safest and most robust\n  // way to register. Lowercase jquery is used because AMD module names are\n  // derived from file names, and jQuery is normally delivered in a lowercase\n  // file name. Do this after creating the global so that if an AMD module wants\n  // to call noConflict to hide this version of jQuery, it will work.\n  // Note that for maximum portability, libraries that are not jQuery should\n  // declare themselves as anonymous modules, and avoid setting a global if an\n  // AMD loader is present. jQuery is a special case. For more information, see\n  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return jQuery;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n\n  var // Map over jQuery in case of overwrite\n  _jQuery = window.jQuery,\n      // Map over the $ in case of overwrite\n  _$ = window.$;\n\n  jQuery.noConflict = function (deep) {\n    if (window.$ === jQuery) {\n      window.$ = _$;\n    }\n\n    if (deep && window.jQuery === jQuery) {\n      window.jQuery = _jQuery;\n    }\n\n    return jQuery;\n  }; // Expose jQuery and $ identifiers, even in AMD\n  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n  // and CommonJS for browser emulators (#13566)\n\n\n  if (typeof noGlobal === \"undefined\") {\n    window.jQuery = window.$ = jQuery;\n  }\n\n  return jQuery;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQ2dELE1BSHJCO0FBQUEsTUFLSTtBQUNBcW5DLEVBQUFBLEVBQUUsR0FBR3JxQyxNQUFNLENBQUNzcUMsQ0FOaEI7O0FBUUF0bkMsRUFBQUEsTUFBTSxDQUFDdW5DLFVBQVAsR0FBb0IsVUFBVTlrQyxJQUFWLEVBQWlCO0FBQ2pDLFFBQUt6RixNQUFNLENBQUNzcUMsQ0FBUCxLQUFhdG5DLE1BQWxCLEVBQTJCO0FBQ3ZCaEQsTUFBQUEsTUFBTSxDQUFDc3FDLENBQVAsR0FBV0QsRUFBWDtBQUNIOztBQUVELFFBQUs1a0MsSUFBSSxJQUFJekYsTUFBTSxDQUFDZ0QsTUFBUCxLQUFrQkEsTUFBL0IsRUFBd0M7QUFDcENoRCxNQUFBQSxNQUFNLENBQUNnRCxNQUFQLEdBQWdCb25DLE9BQWhCO0FBQ0g7O0FBRUQsV0FBT3BuQyxNQUFQO0FBQ0gsR0FWRCxDQWxrVjZFLENBOGtWakY7QUFDQTtBQUNBOzs7QUFDSSxNQUFLLE9BQU8vQyxRQUFQLEtBQW9CLFdBQXpCLEVBQXVDO0FBQ25DRCxJQUFBQSxNQUFNLENBQUNnRCxNQUFQLEdBQWdCaEQsTUFBTSxDQUFDc3FDLENBQVAsR0FBV3RuQyxNQUEzQjtBQUNIOztBQUtELFNBQU9BLE1BQVA7QUFDSCxDQW5uVkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvanF1ZXJ5LmpzPzlmZmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjYuMFxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDIxLTAzLTAyVDE3OjA4WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cbiAgICAgICAgLy8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuICAgICAgICAvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuICAgICAgICAvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuICAgICAgICAvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cbiAgICAgICAgLy8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cbiAgICAgICAgLy8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuICAgICAgICAvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG4gICAgICAgICAgICBmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG4gICAgICAgICAgICBmdW5jdGlvbiggdyApIHtcbiAgICAgICAgICAgICAgICBpZiAoICF3LmRvY3VtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KCB3ICk7XG4gICAgICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3RvcnkoIGdsb2JhbCApO1xuICAgIH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGFyciA9IFtdO1xuXG4gICAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG4gICAgdmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG4gICAgdmFyIGZsYXQgPSBhcnIuZmxhdCA/IGZ1bmN0aW9uKCBhcnJheSApIHtcbiAgICAgICAgcmV0dXJuIGFyci5mbGF0LmNhbGwoIGFycmF5ICk7XG4gICAgfSA6IGZ1bmN0aW9uKCBhcnJheSApIHtcbiAgICAgICAgcmV0dXJuIGFyci5jb25jYXQuYXBwbHkoIFtdLCBhcnJheSApO1xuICAgIH07XG5cblxuICAgIHZhciBwdXNoID0gYXJyLnB1c2g7XG5cbiAgICB2YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG4gICAgdmFyIGNsYXNzMnR5cGUgPSB7fTtcblxuICAgIHZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbiAgICB2YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIHZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG4gICAgdmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxuICAgIHZhciBzdXBwb3J0ID0ge307XG5cbiAgICB2YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcblxuICAgICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG4gICAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMsIHR5cGVvZiByZXR1cm5zIFwiZnVuY3Rpb25cIiBmb3IgSFRNTCA8b2JqZWN0PiBlbGVtZW50c1xuICAgICAgICAvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxuICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG4gICAgICAgIC8vIFN1cHBvcnQ6IFF0V2ViIDw9My44LjUsIFdlYktpdCA8PTUzNC4zNCwgd2todG1sdG9wZGYgdG9vbCA8PTAuMTIuNVxuICAgICAgICAvLyBQbHVzIGZvciBvbGQgV2ViS2l0LCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgY29sbGVjdGlvbnNcbiAgICAgICAgLy8gKGUuZy4sIGB0eXBlb2YgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkaXZcIikgPT09IFwiZnVuY3Rpb25cImApLiAoZ2gtNDc1NilcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLml0ZW0gIT09IFwiZnVuY3Rpb25cIjtcbiAgICB9O1xuXG5cbiAgICB2YXIgaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyggb2JqICkge1xuICAgICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuICAgIH07XG5cblxuICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuXG5cbiAgICB2YXIgcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyA9IHtcbiAgICAgICAgdHlwZTogdHJ1ZSxcbiAgICAgICAgc3JjOiB0cnVlLFxuICAgICAgICBub25jZTogdHJ1ZSxcbiAgICAgICAgbm9Nb2R1bGU6IHRydWVcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgbm9kZSwgZG9jICkge1xuICAgICAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cbiAgICAgICAgdmFyIGksIHZhbCxcbiAgICAgICAgICAgIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cbiAgICAgICAgc2NyaXB0LnRleHQgPSBjb2RlO1xuICAgICAgICBpZiAoIG5vZGUgKSB7XG4gICAgICAgICAgICBmb3IgKCBpIGluIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDY0KywgRWRnZSAxOCtcbiAgICAgICAgICAgICAgICAvLyBTb21lIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIFwibm9uY2VcIiBwcm9wZXJ0eSBvbiBzY3JpcHRzLlxuICAgICAgICAgICAgICAgIC8vIE9uIHRoZSBvdGhlciBoYW5kLCBqdXN0IHVzaW5nIGBnZXRBdHRyaWJ1dGVgIGlzIG5vdCBlbm91Z2ggYXNcbiAgICAgICAgICAgICAgICAvLyB0aGUgYG5vbmNlYCBhdHRyaWJ1dGUgaXMgcmVzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHdoZW5ldmVyIGl0XG4gICAgICAgICAgICAgICAgLy8gYmVjb21lcyBicm93c2luZy1jb250ZXh0IGNvbm5lY3RlZC5cbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9odG1sL2lzc3Vlcy8yMzY5XG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI25vbmNlLWF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAvLyBUaGUgYG5vZGUuZ2V0QXR0cmlidXRlYCBjaGVjayB3YXMgYWRkZWQgZm9yIHRoZSBzYWtlIG9mXG4gICAgICAgICAgICAgICAgLy8gYGpRdWVyeS5nbG9iYWxFdmFsYCBzbyB0aGF0IGl0IGNhbiBmYWtlIGEgbm9uY2UtY29udGFpbmluZyBub2RlXG4gICAgICAgICAgICAgICAgLy8gdmlhIGFuIG9iamVjdC5cbiAgICAgICAgICAgICAgICB2YWwgPSBub2RlWyBpIF0gfHwgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoIGkgKTtcbiAgICAgICAgICAgICAgICBpZiAoIHZhbCApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnNldEF0dHJpYnV0ZSggaSwgdmFsICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuICAgICAgICBpZiAoIG9iaiA9PSBudWxsICkge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiArIFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cbiAgICAgICAgICAgIGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG4gICAgICAgICAgICB0eXBlb2Ygb2JqO1xuICAgIH1cbiAgICAvKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbiAgICB2YXJcbiAgICAgICAgdmVyc2lvbiA9IFwiMy42LjBcIixcblxuICAgICAgICAvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuICAgICAgICBqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cbiAgICAgICAgICAgIC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuICAgICAgICAgICAgLy8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcbiAgICAgICAgICAgIHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG4gICAgICAgIH07XG5cbiAgICBqUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG4gICAgICAgIC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcbiAgICAgICAganF1ZXJ5OiB2ZXJzaW9uLFxuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cbiAgICAgICAgLy8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG4gICAgICAgIGxlbmd0aDogMCxcblxuICAgICAgICB0b0FycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuICAgICAgICAvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcbiAgICAgICAgICAgIGlmICggbnVtID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuICAgICAgICAgICAgcmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuICAgICAgICAvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcbiAgICAgICAgcHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cbiAgICAgICAgICAgIC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG4gICAgICAgICAgICB2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG4gICAgICAgICAgICByZXQucHJldk9iamVjdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcbiAgICAgICAgICAgIH0gKSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNsaWNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlyc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXEoIDAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBsYXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKCAtMSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV2ZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkuZ3JlcCggdGhpcywgZnVuY3Rpb24oIF9lbGVtLCBpICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoIGkgKyAxICkgJSAyO1xuICAgICAgICAgICAgfSApICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb2RkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LmdyZXAoIHRoaXMsIGZ1bmN0aW9uKCBfZWxlbSwgaSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSAlIDI7XG4gICAgICAgICAgICB9ICkgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlcTogZnVuY3Rpb24oIGkgKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuICAgICAgICAvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cbiAgICAgICAgcHVzaDogcHVzaCxcbiAgICAgICAgc29ydDogYXJyLnNvcnQsXG4gICAgICAgIHNwbGljZTogYXJyLnNwbGljZVxuICAgIH07XG5cbiAgICBqUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG4gICAgICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcbiAgICAgICAgICAgIGkgPSAxLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlZXAgPSBmYWxzZTtcblxuICAgICAgICAvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG4gICAgICAgIGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG4gICAgICAgICAgICBkZWVwID0gdGFyZ2V0O1xuXG4gICAgICAgICAgICAvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG4gICAgICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuICAgICAgICBpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuICAgICAgICAgICAgdGFyZ2V0ID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcbiAgICAgICAgaWYgKCBpID09PSBsZW5ndGggKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICAgIGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuICAgICAgICAgICAgICAgIGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHByb3BlciB0eXBlIGZvciB0aGUgc291cmNlIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvcHlJc0FycmF5ICYmICFBcnJheS5pc0FycmF5KCBzcmMgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggIWNvcHlJc0FycmF5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICBqUXVlcnkuZXh0ZW5kKCB7XG5cbiAgICAgICAgLy8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG4gICAgICAgIGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cbiAgICAgICAgLy8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcbiAgICAgICAgaXNSZWFkeTogdHJ1ZSxcblxuICAgICAgICBlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggbXNnICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbm9vcDogZnVuY3Rpb24oKSB7fSxcblxuICAgICAgICBpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICAgICAgdmFyIHByb3RvLCBDdG9yO1xuXG4gICAgICAgICAgICAvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcbiAgICAgICAgICAgIC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuICAgICAgICAgICAgaWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cbiAgICAgICAgICAgIC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cbiAgICAgICAgICAgIGlmICggIXByb3RvICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuICAgICAgICAgICAgQ3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgICAgIHZhciBuYW1lO1xuXG4gICAgICAgICAgICBmb3IgKCBuYW1lIGluIG9iaiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBwcm92aWRlZCBjb250ZXh0OyBmYWxscyBiYWNrIHRvIHRoZSBnbG9iYWwgb25lXG4gICAgICAgIC8vIGlmIG5vdCBzcGVjaWZpZWQuXG4gICAgICAgIGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlLCBvcHRpb25zLCBkb2MgKSB7XG4gICAgICAgICAgICBET01FdmFsKCBjb2RlLCB7IG5vbmNlOiBvcHRpb25zICYmIG9wdGlvbnMubm9uY2UgfSwgZG9jICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoLCBpID0gMDtcblxuICAgICAgICAgICAgaWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICggaSBpbiBvYmogKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAgICBtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuICAgICAgICAgICAgaWYgKCBhcnIgIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZSggcmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBhcnIgXSA6IGFyclxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2guY2FsbCggcmV0LCBhcnIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcbiAgICAgICAgLy8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuICAgICAgICBtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgICAgICAgaSA9IGZpcnN0Lmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpcnN0Lmxlbmd0aCA9IGk7XG5cbiAgICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgICAgfSxcblxuICAgICAgICBncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tJbnZlcnNlLFxuICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG4gICAgICAgICAgICAvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG4gICAgICAgICAgICAvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG4gICAgICAgICAgICAgICAgaWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAgICBtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGgsIHZhbHVlLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIHJldCA9IFtdO1xuXG4gICAgICAgICAgICAvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuICAgICAgICAgICAgaWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggdmFsdWUgIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICggaSBpbiBlbGVtcyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSAhPSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcbiAgICAgICAgICAgIHJldHVybiBmbGF0KCByZXQgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcbiAgICAgICAgZ3VpZDogMSxcblxuICAgICAgICAvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcbiAgICAgICAgLy8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cbiAgICAgICAgc3VwcG9ydDogc3VwcG9ydFxuICAgIH0gKTtcblxuICAgIGlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgICBqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbiAgICB9XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxuICAgIGpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG4gICAgICAgIGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcbiAgICAgICAgICAgIGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9ICk7XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcbiAgICAgICAgLy8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuICAgICAgICAvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcbiAgICAgICAgLy8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuICAgICAgICB2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcbiAgICAgICAgICAgIHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG4gICAgICAgIGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgIHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG4gICAgfVxuICAgIHZhciBTaXp6bGUgPVxuICAgICAgICAvKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuNlxuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pzLmZvdW5kYXRpb24vXG4gKlxuICogRGF0ZTogMjAyMS0wMi0xNlxuICovXG4gICAgICAgICggZnVuY3Rpb24oIHdpbmRvdyApIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIHN1cHBvcnQsXG4gICAgICAgICAgICAgICAgRXhwcixcbiAgICAgICAgICAgICAgICBnZXRUZXh0LFxuICAgICAgICAgICAgICAgIGlzWE1MLFxuICAgICAgICAgICAgICAgIHRva2VuaXplLFxuICAgICAgICAgICAgICAgIGNvbXBpbGUsXG4gICAgICAgICAgICAgICAgc2VsZWN0LFxuICAgICAgICAgICAgICAgIG91dGVybW9zdENvbnRleHQsXG4gICAgICAgICAgICAgICAgc29ydElucHV0LFxuICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSxcblxuICAgICAgICAgICAgICAgIC8vIExvY2FsIGRvY3VtZW50IHZhcnNcbiAgICAgICAgICAgICAgICBzZXREb2N1bWVudCxcbiAgICAgICAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICAgICAgICBkb2NFbGVtLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50SXNIVE1MLFxuICAgICAgICAgICAgICAgIHJidWdneVFTQSxcbiAgICAgICAgICAgICAgICByYnVnZ3lNYXRjaGVzLFxuICAgICAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICAgICAgY29udGFpbnMsXG5cbiAgICAgICAgICAgICAgICAvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG4gICAgICAgICAgICAgICAgZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgZGlycnVucyA9IDAsXG4gICAgICAgICAgICAgICAgZG9uZSA9IDAsXG4gICAgICAgICAgICAgICAgY2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgICAgICAgICAgICAgdG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgICAgICAgICAgICAgY29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgICAgICAgICAgICAgbm9ubmF0aXZlU2VsZWN0b3JDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgICAgICAgICAgICAgc29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggYSA9PT0gYiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIEluc3RhbmNlIG1ldGhvZHNcbiAgICAgICAgICAgICAgICBoYXNPd24gPSAoIHt9ICkuaGFzT3duUHJvcGVydHksXG4gICAgICAgICAgICAgICAgYXJyID0gW10sXG4gICAgICAgICAgICAgICAgcG9wID0gYXJyLnBvcCxcbiAgICAgICAgICAgICAgICBwdXNoTmF0aXZlID0gYXJyLnB1c2gsXG4gICAgICAgICAgICAgICAgcHVzaCA9IGFyci5wdXNoLFxuICAgICAgICAgICAgICAgIHNsaWNlID0gYXJyLnNsaWNlLFxuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuICAgICAgICAgICAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBsaXN0WyBpIF0gPT09IGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cbiAgICAgICAgICAgICAgICAvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXN5bnRheC0zLyNpZGVudC10b2tlbi1kaWFncmFtXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICAgICAgICBcIj98XFxcXFxcXFxbXlxcXFxyXFxcXG5cXFxcZl18W1xcXFx3LV18W15cXDAtXFxcXHg3Zl0pK1wiLFxuXG4gICAgICAgICAgICAgICAgLy8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuICAgICAgICAgICAgICAgICAgICBcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XVxuICAgICAgICAgICAgICAgICAgICAvLyBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG4gICAgICAgICAgICAgICAgICAgIFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgK1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIixcblxuICAgICAgICAgICAgICAgIHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuICAgICAgICAgICAgICAgICAgICBcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblxuICAgICAgICAgICAgICAgICAgICAvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcbiAgICAgICAgICAgICAgICAgICAgXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcbiAgICAgICAgICAgICAgICAgICAgXCIuKlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIpXFxcXCl8KVwiLFxuXG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuICAgICAgICAgICAgICAgIHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuICAgICAgICAgICAgICAgIHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuICAgICAgICAgICAgICAgIHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuICAgICAgICAgICAgICAgIHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICAgICAgICBcIipcIiApLFxuICAgICAgICAgICAgICAgIHJkZXNjZW5kID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwifD5cIiApLFxuXG4gICAgICAgICAgICAgICAgcnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcbiAgICAgICAgICAgICAgICByaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cbiAgICAgICAgICAgICAgICBtYXRjaEV4cHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuICAgICAgICAgICAgICAgICAgICBcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG4gICAgICAgICAgICAgICAgICAgIFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcbiAgICAgICAgICAgICAgICAgICAgXCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuICAgICAgICAgICAgICAgICAgICBcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcbiAgICAgICAgICAgICAgICAgICAgXCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpdGVzcGFjZSArIFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgKyBcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcbiAgICAgICAgICAgICAgICAgICAgXCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcbiAgICAgICAgICAgICAgICAgICAgXCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgcmh0bWwgPSAvSFRNTCQvaSxcbiAgICAgICAgICAgICAgICByaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcbiAgICAgICAgICAgICAgICByaGVhZGVyID0gL15oXFxkJC9pLFxuXG4gICAgICAgICAgICAgICAgcm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cbiAgICAgICAgICAgICAgICAvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcbiAgICAgICAgICAgICAgICBycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cbiAgICAgICAgICAgICAgICByc2libGluZyA9IC9bK35dLyxcblxuICAgICAgICAgICAgICAgIC8vIENTUyBlc2NhcGVzXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgIHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98XFxcXFxcXFwoW15cXFxcclxcXFxuXFxcXGZdKVwiLCBcImdcIiApLFxuICAgICAgICAgICAgICAgIGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBlc2NhcGUsIG5vbkhleCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGUuc2xpY2UoIDEgKSAtIDB4MTAwMDA7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vbkhleCA/XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmlwIHRoZSBiYWNrc2xhc2ggcHJlZml4IGZyb20gYSBub24taGV4IGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9uSGV4IDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBhIGhleGFkZWNpbWFsIGVzY2FwZSBzZXF1ZW5jZSB3aXRoIHRoZSBlbmNvZGVkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMStcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciB2YWx1ZXMgb3V0c2lkZSB0aGUgQmFzaWMgTXVsdGlsaW5ndWFsIFBsYW5lIChCTVApLCBtYW51YWxseSBjb25zdHJ1Y3QgYVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2ggPCAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcbiAgICAgICAgICAgICAgICByY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG4gICAgICAgICAgICAgICAgZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggYXNDb2RlUG9pbnQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcXHVGRkZEXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFxcIiArIGNoO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBVc2VkIGZvciBpZnJhbWVzXG4gICAgICAgICAgICAgICAgLy8gU2VlIHNldERvY3VtZW50KClcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcbiAgICAgICAgICAgICAgICAvLyBlcnJvciBpbiBJRVxuICAgICAgICAgICAgICAgIHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgaW5EaXNhYmxlZEZpZWxkc2V0ID0gYWRkQ29tYmluYXRvcihcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZmllbGRzZXRcIjtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cbiAgICAgICAgICAgICAgICApO1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICAoIGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkgKSxcbiAgICAgICAgICAgICAgICAgICAgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZDw0LjBcbiAgICAgICAgICAgICAgICAvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgIGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG4gICAgICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgICAgICBwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaE5hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKCBlbHMgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoIHRhcmdldFsgaisrIF0gPSBlbHNbIGkrKyBdICkgKSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5sZW5ndGggPSBqIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuICAgICAgICAgICAgICAgIHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICBub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgbm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcbiAgICAgICAgICAgICAgICBpZiAoICFzZWVkICkge1xuICAgICAgICAgICAgICAgICAgICBzZXREb2N1bWVudCggY29udGV4dCApO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKCBtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggbSA9IG1hdGNoWyAxIF0gKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb2N1bWVudCBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbGVtZW50IGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5ld0NvbnRleHQgJiYgKCBlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5pZCA9PT0gbSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHlwZSBzZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1hdGNoWyAyIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xhc3Mgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCAoIG0gPSBtYXRjaFsgMyBdICkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3VwcG9ydC5xc2EgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCAhcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSApICYmXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA4IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggbm9kZVR5cGUgIT09IDEgfHwgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcVNBIGNvbnNpZGVycyBlbGVtZW50cyBvdXRzaWRlIGEgc2NvcGluZyByb290IHdoZW4gZXZhbHVhdGluZyBjaGlsZCBvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlc2NlbmRhbnQgY29tYmluYXRvcnMsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gc3VjaCBjYXNlcywgd2Ugd29yayBhcm91bmQgdGhlIGJlaGF2aW9yIGJ5IHByZWZpeGluZyBldmVyeSBzZWxlY3RvciBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsaXN0IHdpdGggYW4gSUQgc2VsZWN0b3IgcmVmZXJlbmNpbmcgdGhlIHNjb3BlIGNvbnRleHQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRlY2huaXF1ZSBoYXMgdG8gYmUgdXNlZCBhcyB3ZWxsIHdoZW4gYSBsZWFkaW5nIGNvbWJpbmF0b3IgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzIHN1Y2ggc2VsZWN0b3JzIGFyZSBub3QgcmVjb2duaXplZCBieSBxdWVyeVNlbGVjdG9yQWxsLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHRlY2huaXF1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggcmRlc2NlbmQudGVzdCggc2VsZWN0b3IgKSB8fCByY29tYmluYXRvcnMudGVzdCggc2VsZWN0b3IgKSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIHVzZSA6c2NvcGUgaW5zdGVhZCBvZiB0aGUgSUQgaGFjayBpZiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdXBwb3J0cyBpdCAmIGlmIHdlJ3JlIG5vdCBjaGFuZ2luZyB0aGUgY29udGV4dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuZXdDb250ZXh0ICE9PSBjb250ZXh0IHx8ICFzdXBwb3J0LnNjb3BlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsICggbmlkID0gZXhwYW5kbyApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBncm91cHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3Vwc1sgaSBdID0gKCBuaWQgPyBcIiNcIiArIG5pZCA6IFwiOnNjb3BlXCIgKSArIFwiIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1NlbGVjdG9yKCBncm91cHNbIGkgXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseSggcmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICggcXNhRXJyb3IgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIHNlbGVjdG9yLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBbGwgb3RoZXJzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gICAgICAgICAgICAgKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAgICAgICAgICAgICAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gW107XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuICAgICAgICAgICAgICAgICAgICBpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCBjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcbiAgICAgICAgICAgICAgICBmblsgZXhwYW5kbyBdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImZpZWxkc2V0XCIgKTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWZuKCBlbCApO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKCBlICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbC5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG4gICAgICAgICAgICAgICAgICAgIGVsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyciA9IGF0dHJzLnNwbGl0KCBcInxcIiApLFxuICAgICAgICAgICAgICAgICAgICBpID0gYXJyLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICBFeHByLmF0dHJIYW5kbGVbIGFyclsgaSBdIF0gPSBoYW5kbGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICAgICAgICAgICAgICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyID0gYiAmJiBhLFxuICAgICAgICAgICAgICAgICAgICBkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcbiAgICAgICAgICAgICAgICBpZiAoIGRpZmYgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG4gICAgICAgICAgICAgICAgaWYgKCBjdXIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggKCBjdXIgPSBjdXIubmV4dFNpYmxpbmcgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY3VyID09PSBiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBhID8gMSA6IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggbmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIgKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxuICAgICAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA2IC0gMTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoganNoaW50IC1XMDE4ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluRGlzYWJsZWRGaWVsZHNldCggZWxlbSApID09PSBkaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQgPSArYXJndW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZWRbICggaiA9IG1hdGNoSW5kZXhlc1sgaSBdICkgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlZFsgaiBdID0gISggbWF0Y2hlc1sgaiBdID0gc2VlZFsgaiBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbiAgICAgICAgICAgIH1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbiAgICAgICAgICAgIHN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERldGVjdHMgWE1MIG5vZGVzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICAgICAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBlbGVtICYmIGVsZW0ubmFtZXNwYWNlVVJJLFxuICAgICAgICAgICAgICAgICAgICBkb2NFbGVtID0gZWxlbSAmJiAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD04XG4gICAgICAgICAgICAgICAgLy8gQXNzdW1lIEhUTUwgd2hlbiBkb2N1bWVudEVsZW1lbnQgZG9lc24ndCB5ZXQgZXhpc3QsIHN1Y2ggYXMgaW5zaWRlIGxvYWRpbmcgaWZyYW1lc1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC80ODMzXG4gICAgICAgICAgICAgICAgcmV0dXJuICFyaHRtbC50ZXN0KCBuYW1lc3BhY2UgfHwgZG9jRWxlbSAmJiBkb2NFbGVtLm5vZGVOYW1lIHx8IFwiSFRNTFwiICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuICAgICAgICAgICAgICAgICAgICBkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuICAgICAgICAgICAgICAgIC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuICAgICAgICAgICAgICAgIC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgICAgICAgICAgaWYgKCBkb2MgPT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcbiAgICAgICAgICAgICAgICBkb2N1bWVudCA9IGRvYztcbiAgICAgICAgICAgICAgICBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuICAgICAgICAgICAgICAgIC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcbiAgICAgICAgICAgICAgICAvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcbiAgICAgICAgICAgICAgICAvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgICAgICAgIGlmICggcHJlZmVycmVkRG9jICE9IGRvY3VtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICggc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcgKSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTEsIEVkZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgOCAtIDExKywgRWRnZSAxMiAtIDE4KywgQ2hyb21lIDw9MTYgLSAyNSBvbmx5LCBGaXJlZm94IDw9My42IC0gMzEgb25seSxcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgNCAtIDUgb25seSwgT3BlcmEgPD0xMS42IC0gMTIueCBvbmx5XG4gICAgICAgICAgICAgICAgLy8gSUUvRWRnZSAmIG9sZGVyIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIDpzY29wZSBwc2V1ZG8tY2xhc3MuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogU2FmYXJpIDYuMCBvbmx5XG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDYuMCBzdXBwb3J0cyA6c2NvcGUgYnV0IGl0J3MgYW4gYWxpYXMgb2YgOnJvb3QgdGhlcmUuXG4gICAgICAgICAgICAgICAgc3VwcG9ydC5zY29wZSA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhZWwucXVlcnlTZWxlY3RvckFsbCggXCI6c2NvcGUgZmllbGRzZXQgZGl2XCIgKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgLyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTw4XG4gICAgICAgICAgICAgICAgLy8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgLy8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG4gICAgICAgICAgICAgICAgc3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWVsLmdldEF0dHJpYnV0ZSggXCJjbGFzc05hbWVcIiApO1xuICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgIC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoIFwiXCIgKSApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcIipcIiApLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTw5XG4gICAgICAgICAgICAgICAgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTwxMFxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuICAgICAgICAgICAgICAgIC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuICAgICAgICAgICAgICAgIHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgLy8gSUQgZmlsdGVyIGFuZCBmaW5kXG4gICAgICAgICAgICAgICAgaWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIEV4cHIuZmlsdGVyWyBcIklEXCIgXSA9IGZ1bmN0aW9uKCBpZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJpZFwiICkgPT09IGF0dHJJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIEV4cHIuZmluZFsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgRXhwci5maWx0ZXJbIFwiSURcIiBdID0gIGZ1bmN0aW9uKCBpZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuICAgICAgICAgICAgICAgICAgICAvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG4gICAgICAgICAgICAgICAgICAgIEV4cHIuZmluZFsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlLCBpLCBlbGVtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIGVsZW0gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICggZWxlbSA9IGVsZW1zWyBpKysgXSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgZWxlbSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRhZ1xuICAgICAgICAgICAgICAgIEV4cHIuZmluZFsgXCJUQUdcIiBdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gOlxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMCxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGFnID09PSBcIipcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBDbGFzc1xuICAgICAgICAgICAgICAgIEV4cHIuZmluZFsgXCJDTEFTU1wiIF0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAgICAgICAgICAgICAvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cbiAgICAgICAgICAgICAgICAvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuICAgICAgICAgICAgICAgIHJidWdneU1hdGNoZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG4gICAgICAgICAgICAgICAgLy8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuICAgICAgICAgICAgICAgIC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuICAgICAgICAgICAgICAgIHJidWdneVFTQSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCAoIHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBCdWlsZCBRU0EgcmVnZXhcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIiApLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRThcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW3NlbGVjdGVkXVwiICkubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaCggXCJ+PVwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNSAtIDE4K1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUgMTEvRWRnZSBkb24ndCBmaW5kIGVsZW1lbnRzIG9uIGEgYFtuYW1lPScnXWAgcXVlcnkgaW4gc29tZSBjYXNlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZGluZyBhIHRlbXBvcmFyeSBhdHRyaWJ1dGUgdG8gdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgc2VsZWN0aW9uIHdvcmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcm91bmQgdGhlIGlzc3VlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJlc3RpbmdseSwgSUUgMTAgJiBvbGRlciBkb24ndCBzZWVtIHRvIGhhdmUgdGhlIGlzc3VlLlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKCBpbnB1dCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbbmFtZT0nJ11cIiApLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIio9XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCI6Y2hlY2tlZFwiICkubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKCBcIjpjaGVja2VkXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goIFwiLiMuK1srfl1cIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDw9My42IC0gNSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbGQgRmlyZWZveCBkb2Vzbid0IHRocm93IG9uIGEgYmFkbHktZXNjYXBlZCBpZGVudGlmaWVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgZWwucXVlcnlTZWxlY3RvckFsbCggXCJcXFxcXFxmXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKCBcIltcXFxcclxcXFxuXFxcXGZdXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU4XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCJbbmFtZT1kXVwiICkubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmVuYWJsZWRcIiApLmxlbmd0aCAhPT0gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOS0xMStcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmRpc2FibGVkXCIgKS5sZW5ndGggIT09IDIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBPcGVyYSAxMCAtIDExIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIiosOnhcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goIFwiLC4qOlwiICk7XG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoICggbWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvciApICkgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKCBcInxcIiApICk7XG4gICAgICAgICAgICAgICAgcmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbiggXCJ8XCIgKSApO1xuXG4gICAgICAgICAgICAgICAgLyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICAgICAgICAgICAgICAgIGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuICAgICAgICAgICAgICAgIC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuICAgICAgICAgICAgICAgIC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuICAgICAgICAgICAgICAgIC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG4gICAgICAgICAgICAgICAgY29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIGEsIGIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRvd24uY29udGFpbnMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZG93bi5jb250YWlucyggYnVwICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcbiAgICAgICAgICAgICAgICAgICAgICAgICkgKTtcbiAgICAgICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCBhLCBiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKCBiID0gYi5wYXJlbnROb2RlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYiA9PT0gYSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAgICAgICAgICAgICAvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG4gICAgICAgICAgICAgICAgc29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCBhLCBiICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBhID09PSBiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29tcGFyZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzY29ubmVjdGVkIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbXBhcmUgJiAxIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCAhc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYSA9PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zKCBwcmVmZXJyZWREb2MsIGEgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBiID09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PSBwcmVmZXJyZWREb2MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnMoIHByZWZlcnJlZERvYywgYiApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3J0SW5wdXQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCBhLCBiICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGEgPT09IGIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXAgPSBhLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVwID0gYi5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwID0gWyBhIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnAgPSBbIGIgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWF1cCB8fCAhYnVwICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhID09IGRvY3VtZW50ID8gLTEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID09IGRvY3VtZW50ID8gMSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVwID8gLTEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1cCA/IDEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0SW5wdXQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoIGN1ciA9IGN1ci5wYXJlbnROb2RlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXAudW5zaGlmdCggY3VyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoIGN1ciA9IGN1ci5wYXJlbnROb2RlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnAudW5zaGlmdCggY3VyICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGFwWyBpIF0gPT09IGJwWyBpIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSA/XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nQ2hlY2soIGFwWyBpIF0sIGJwWyBpIF0gKSA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBbIGkgXSA9PSBwcmVmZXJyZWREb2MgPyAtMSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJwWyBpIF0gPT0gcHJlZmVycmVkRG9jID8gMSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBTaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG4gICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQoIGVsZW0gKTtcblxuICAgICAgICAgICAgICAgIGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcbiAgICAgICAgICAgICAgICAgICAgIW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG4gICAgICAgICAgICAgICAgICAgICggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJhZ21lbnQgaW4gSUUgOVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub25uYXRpdmVTZWxlY3RvckNhY2hlKCBleHByLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcbiAgICAgICAgICAgICAgICAvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcbiAgICAgICAgICAgICAgICAvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgICAgICAgIGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9IGRvY3VtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICBzZXREb2N1bWVudCggY29udGV4dCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcbiAgICAgICAgICAgICAgICAvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcbiAgICAgICAgICAgICAgICAvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgICAgICAgIGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9IGRvY3VtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICBzZXREb2N1bWVudCggZWxlbSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICB2YWwgOlxuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgKCB2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSApICYmIHZhbC5zcGVjaWZpZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC52YWx1ZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoIHNlbCArIFwiXCIgKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBTaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgICAgICAgICBkdXBsaWNhdGVzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGogPSAwLFxuICAgICAgICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgICAgIC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2VcbiAgICAgICAgICAgICAgICBoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuICAgICAgICAgICAgICAgIHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGhhc0R1cGxpY2F0ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoIGVsZW0gPSByZXN1bHRzWyBpKysgXSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggai0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcbiAgICAgICAgICAgICAgICBzb3J0SW5wdXQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgICAgICBub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoICFub2RlVHlwZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICggbm9kZSA9IGVsZW1bIGkrKyBdICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1MylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG4gICAgICAgICAgICAgICAgLy8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG4gICAgICAgICAgICAgICAgY2FjaGVMZW5ndGg6IDUwLFxuXG4gICAgICAgICAgICAgICAgY3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cbiAgICAgICAgICAgICAgICBtYXRjaDogbWF0Y2hFeHByLFxuXG4gICAgICAgICAgICAgICAgYXR0ckhhbmRsZToge30sXG5cbiAgICAgICAgICAgICAgICBmaW5kOiB7fSxcblxuICAgICAgICAgICAgICAgIHJlbGF0aXZlOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgXCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgICAgICBcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBwcmVGaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWyAxIF0gPSBtYXRjaFsgMSBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsgMyBdID0gKCBtYXRjaFsgMyBdIHx8IG1hdGNoWyA0IF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsgNSBdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoWyAyIF0gPT09IFwifj1cIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsgMyBdID0gXCIgXCIgKyBtYXRjaFsgMyBdICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaFsgMSBdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIW1hdGNoWyAzIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvciggbWF0Y2hbIDAgXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsgNCBdID0gKyggbWF0Y2hbIDQgXSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWyA1IF0gKyAoIG1hdGNoWyA2IF0gfHwgMSApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMiAqICggbWF0Y2hbIDMgXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbIDMgXSA9PT0gXCJvZGRcIiApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbIDUgXSA9ICsoICggbWF0Y2hbIDcgXSArIG1hdGNoWyA4IF0gKSB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1hdGNoWyAzIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKCBtYXRjaFsgMCBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICBcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhjZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVucXVvdGVkID0gIW1hdGNoWyA2IF0gJiYgbWF0Y2hbIDIgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaEV4cHJbIFwiQ0hJTERcIiBdLnRlc3QoIG1hdGNoWyAwIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hbIDMgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsgMiBdID0gbWF0Y2hbIDQgXSB8fCBtYXRjaFsgNSBdIHx8IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkgKSAmJlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGggKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWyAyIF0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgZmlsdGVyOiB7XG5cbiAgICAgICAgICAgICAgICAgICAgXCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggcGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkgKSAmJiBjbGFzc0NhY2hlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhb3BlcmF0b3IgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIF9hcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiggZWxlbSwgX2NvbnRleHQsIHhtbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZiA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcGFyZW50ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNpbXBsZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGRpciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKCBub2RlID0gbm9kZVsgZGlyIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb2ZUeXBlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGRpZmYgPSBub2RlSW5kZXggPSAwICkgfHwgc3RhcnQucG9wKCkgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB1c2VDYWNoZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8ICggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmID0gbm9kZUluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkaWZmID09PSBmYWxzZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggb2ZUeXBlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrZGlmZiApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHVzZUNhY2hlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPDkgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBub2RlID09PSBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmIC09IGxhc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3NcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZm5bIGV4cGFuZG8gXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBmbi5sZW5ndGggPiAxICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IG1hdGNoZWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFsgaSBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbIGkgXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgcHNldWRvczoge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuICAgICAgICAgICAgICAgICAgICBcIm5vdFwiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIF9jb250ZXh0LCB4bWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHNlZWQubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICggZWxlbSA9IHVubWF0Y2hlZFsgaSBdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlZFsgaSBdID0gISggbWF0Y2hlc1sgaSBdID0gZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiggZWxlbSwgX2NvbnRleHQsIHhtbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRbIDAgXSA9IGVsZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFsgMCBdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gKSxcblxuICAgICAgICAgICAgICAgICAgICBcImhhc1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9ICksXG5cbiAgICAgICAgICAgICAgICAgICAgXCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCB0ZXh0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSApLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuICAgICAgICAgICAgICAgICAgICAvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG4gICAgICAgICAgICAgICAgICAgIFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFyaWRlbnRpZmllci50ZXN0KCBsYW5nIHx8IFwiXCIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1MYW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5sYW5nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uZ2V0QXR0cmlidXRlKCBcInhtbDpsYW5nXCIgKSB8fCBlbGVtLmdldEF0dHJpYnV0ZSggXCJsYW5nXCIgKSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICggKCBlbGVtID0gZWxlbS5wYXJlbnROb2RlICkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gKSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBNaXNjZWxsYW5lb3VzXG4gICAgICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCAhZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgISEoIGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXggKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBCb29sZWFuIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgXCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuICAgICAgICAgICAgICAgICAgICBcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cbiAgICAgICAgICAgICAgICAgICAgXCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkICkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCApO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGVudHNcbiAgICAgICAgICAgICAgICAgICAgXCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIUV4cHIucHNldWRvc1sgXCJlbXB0eVwiIF0oIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBFbGVtZW50L2lucHV0IHR5cGVzXG4gICAgICAgICAgICAgICAgICAgIFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTw4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoICggYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICkgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICBcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgMCBdO1xuICAgICAgICAgICAgICAgICAgICB9ICksXG5cbiAgICAgICAgICAgICAgICAgICAgXCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBfbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBsZW5ndGggLSAxIF07XG4gICAgICAgICAgICAgICAgICAgIH0gKSxcblxuICAgICAgICAgICAgICAgICAgICBcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBfbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuICAgICAgICAgICAgICAgICAgICB9ICksXG5cbiAgICAgICAgICAgICAgICAgICAgXCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xuICAgICAgICAgICAgICAgICAgICB9ICksXG5cbiAgICAgICAgICAgICAgICAgICAgXCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaEluZGV4ZXM7XG4gICAgICAgICAgICAgICAgICAgIH0gKSxcblxuICAgICAgICAgICAgICAgICAgICBcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50IDwgMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQgKyBsZW5ndGggOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50ID4gbGVuZ3RoID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IC0taSA+PSAwOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgICAgICAgICAgICAgICAgfSApLFxuXG4gICAgICAgICAgICAgICAgICAgIFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgICAgICAgICAgICAgICAgfSApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgRXhwci5wc2V1ZG9zWyBcIm50aFwiIF0gPSBFeHByLnBzZXVkb3NbIFwiZXFcIiBdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuICAgICAgICAgICAgZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG4gICAgICAgICAgICAgICAgRXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcbiAgICAgICAgICAgICAgICBFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xuICAgICAgICAgICAgfVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuICAgICAgICAgICAgc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG4gICAgICAgICAgICBFeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG4gICAgICAgICAgICB0b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIGNhY2hlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzb0ZhciA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIGdyb3VwcyA9IFtdO1xuICAgICAgICAgICAgICAgIHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuICAgICAgICAgICAgICAgIHdoaWxlICggc29GYXIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuICAgICAgICAgICAgICAgICAgICBpZiAoICFtYXRjaGVkIHx8ICggbWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbIDAgXS5sZW5ndGggKSB8fCBzb0ZhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3Vwcy5wdXNoKCAoIHRva2VucyA9IFtdICkgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb21iaW5hdG9yc1xuICAgICAgICAgICAgICAgICAgICBpZiAoICggbWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCgge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtYXRjaGVkLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbWF0Y2hbIDAgXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlcnNcbiAgICAgICAgICAgICAgICAgICAgZm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCBtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkgKSAmJiAoICFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApICkgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCgge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWF0Y2hlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlczogbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIW1hdGNoZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZU9ubHkgP1xuICAgICAgICAgICAgICAgICAgICBzb0Zhci5sZW5ndGggOlxuICAgICAgICAgICAgICAgICAgICBzb0ZhciA/XG4gICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgdG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHRva2Vucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gXCJcIjtcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgKz0gdG9rZW5zWyBpIF0udmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG4gICAgICAgICAgICAgICAgICAgIHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHNraXAgfHwgZGlyLFxuICAgICAgICAgICAgICAgICAgICBjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuICAgICAgICAgICAgICAgICAgICBkb25lTmFtZSA9IGRvbmUrKztcblxuICAgICAgICAgICAgICAgIHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSA6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggeG1sICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoIGVsZW1bIGV4cGFuZG8gXSA9IHt9ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCAoIG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCBuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCBuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFtYXRjaGVyc1sgaSBdKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IDpcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcnNbIDAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1sgaSBdLCByZXN1bHRzICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgICAgICAgICBuZXdVbm1hdGNoZWQgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggKCBlbGVtID0gdW5tYXRjaGVkWyBpIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXBwZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5wdXNoKCBpICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1VubWF0Y2hlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuICAgICAgICAgICAgICAgIGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuICAgICAgICAgICAgICAgICAgICBwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCwgaSwgZWxlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZU1hcCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdE1hcCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yIHx8IFwiKlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW11cbiAgICAgICAgICAgICAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1zLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW10gOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVySW47XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCBwcmltYXJ5IG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaGVyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBvc3RGaWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBwb3N0RmlsdGVyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSB0ZW1wLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCBlbGVtID0gdGVtcFsgaSBdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXRbIHBvc3RNYXBbIGkgXSBdID0gISggbWF0Y2hlckluWyBwb3N0TWFwWyBpIF0gXSA9IGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNlZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcG9zdEZpbmRlciApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gbWF0Y2hlck91dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC5wdXNoKCAoIG1hdGNoZXJJblsgaSBdID0gZWxlbSApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdEZpbmRlciggbnVsbCwgKCBtYXRjaGVyT3V0ID0gW10gKSwgdGVtcCwgeG1sICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gbWF0Y2hlck91dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCBlbGVtID0gbWF0Y2hlck91dFsgaSBdICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggdGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbIGkgXSApID4gLTEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZWRbIHRlbXAgXSA9ICEoIHJlc3VsdHNbIHRlbXAgXSA9IGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHBvc3RGaW5kZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuICAgICAgICAgICAgICAgICAgICBsZW4gPSB0b2tlbnMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDAgXS50eXBlIF0sXG4gICAgICAgICAgICAgICAgICAgIGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVsgXCIgXCIgXSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuICAgICAgICAgICAgICAgICAgICB9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBjaGVja0NvbnRleHQgPSBjb250ZXh0ICkubm9kZVR5cGUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9IF07XG5cbiAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIGkgXS50eXBlIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKCBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlciApIF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1sgaSBdLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zWyBpIF0ubWF0Y2hlcyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gKytpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgaiBdLnR5cGUgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRNYXRjaGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA+IDEgJiYgdG9TZWxlY3RvcihcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSggMCwgaSAtIDEgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCggeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICggdG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkgKSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuICAgICAgICAgICAgICAgIHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgICAgICAgIGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgICAgICBzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSwgaiwgbWF0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkQ291bnQgPSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBcIjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE1hdGNoZWQgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFsgXCJUQUdcIiBdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcnJ1bnNVbmlxdWUgPSAoIGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gZWxlbXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG91dGVybW9zdCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpICE9PSBsZW4gJiYgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPSBkb2N1bWVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldERvY3VtZW50KCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoIG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbIGorKyBdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb3V0ZXJtb3N0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBieVNldCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCBlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZENvdW50LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc2VlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkQ291bnQgKz0gaTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bWVyaWNhbGx5IHplcm8uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICggbWF0Y2hlciA9IHNldE1hdGNoZXJzWyBqKysgXSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc2VlZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggISggdW5tYXRjaGVkWyBpIF0gfHwgc2V0TWF0Y2hlZFsgaSBdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE1hdGNoZWRbIGkgXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG91dGVybW9zdCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVubWF0Y2hlZDtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBieVNldCA/XG4gICAgICAgICAgICAgICAgICAgIG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuICAgICAgICAgICAgICAgICAgICBzdXBlck1hdGNoZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG4gICAgICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgICAgIHNldE1hdGNoZXJzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoICFjYWNoZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmICggIW1hdGNoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpID0gbWF0Y2gubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFsgaSBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gY29tcGlsZXJDYWNoZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzIClcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAgICAgICAgICAgICAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gICAgICAgICAgICAgKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoICggc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvciApICk7XG5cbiAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG4gICAgICAgICAgICAgICAgLy8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuICAgICAgICAgICAgICAgIGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG4gICAgICAgICAgICAgICAgICAgIHRva2VucyA9IG1hdGNoWyAwIF0gPSBtYXRjaFsgMCBdLnNsaWNlKCAwICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKCB0b2tlbiA9IHRva2Vuc1sgMCBdICkudHlwZSA9PT0gXCJJRFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgMSBdLnR5cGUgXSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9ICggRXhwci5maW5kWyBcIklEXCIgXSggdG9rZW4ubWF0Y2hlc1sgMCBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksIGNvbnRleHQgKSB8fCBbXSApWyAwIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFjb250ZXh0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG4gICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaEV4cHJbIFwibmVlZHNDb250ZXh0XCIgXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbIGkgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBFeHByLnJlbGF0aXZlWyAoIHR5cGUgPSB0b2tlbi50eXBlICkgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCBmaW5kID0gRXhwci5maW5kWyB0eXBlIF0gKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCBzZWVkID0gZmluZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4ubWF0Y2hlc1sgMCBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJzaWJsaW5nLnRlc3QoIHRva2Vuc1sgMCBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnNwbGljZSggaSwgMSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFzZWxlY3RvciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgLy8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuICAgICAgICAgICAgICAgICggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcbiAgICAgICAgICAgICAgICAgICAgc2VlZCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgIWRvY3VtZW50SXNIVE1MLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLFxuICAgICAgICAgICAgICAgICAgICAhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG4gICAgICAgICAgICBzdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KCBcIlwiICkuc29ydCggc29ydE9yZGVyICkuam9pbiggXCJcIiApID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG4gICAgICAgICAgICBzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG4gICAgICAgICAgICBzZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG4gICAgICAgICAgICBzdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImZpZWxkc2V0XCIgKSApICYgMTtcbiAgICAgICAgICAgIH0gKTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG4gICAgICAgICAgICBpZiAoICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcbiAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwiaHJlZlwiICkgPT09IFwiI1wiO1xuICAgICAgICAgICAgfSApICkge1xuICAgICAgICAgICAgICAgIGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhaXNYTUwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgfVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG4gICAgICAgICAgICBpZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcbiAgICAgICAgICAgICAgICBlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbiAgICAgICAgICAgIH0gKSApIHtcbiAgICAgICAgICAgICAgICBhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIF9uYW1lLCBpc1hNTCApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbiAgICAgICAgICAgIGlmICggIWFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoIFwiZGlzYWJsZWRcIiApID09IG51bGw7XG4gICAgICAgICAgICB9ICkgKSB7XG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFpc1hNTCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggdmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkgKSAmJiB2YWwuc3BlY2lmaWVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsLnZhbHVlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFNpenpsZTtcblxuICAgICAgICB9ICkoIHdpbmRvdyApO1xuXG5cblxuICAgIGpRdWVyeS5maW5kID0gU2l6emxlO1xuICAgIGpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxuICAgIGpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbiAgICBqUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbiAgICBqUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xuICAgIGpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbiAgICBqUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG4gICAgalF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxuICAgIHZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBbXSxcbiAgICAgICAgICAgIHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuICAgICAgICB3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcbiAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF0Y2hlZC5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgfTtcblxuXG4gICAgdmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gW107XG5cbiAgICAgICAgZm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcbiAgICAgICAgICAgIGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaCggbiApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgfTtcblxuXG4gICAgdmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cblxuXG4gICAgZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICB9XG4gICAgdmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuICAgIGZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuICAgICAgICBpZiAoIGlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2luZ2xlIGVsZW1lbnRcbiAgICAgICAgaWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG4gICAgICAgIGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaWx0ZXJlZCBkaXJlY3RseSBmb3IgYm90aCBzaW1wbGUgYW5kIGNvbXBsZXggc2VsZWN0b3JzXG4gICAgICAgIHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcbiAgICB9XG5cbiAgICBqUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG4gICAgICAgIHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuICAgICAgICBpZiAoIG5vdCApIHtcbiAgICAgICAgICAgIGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG4gICAgICAgIH0gKSApO1xuICAgIH07XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgIHZhciBpLCByZXQsXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcbiAgICAgICAgfSxcbiAgICAgICAgbm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuICAgICAgICB9LFxuICAgICAgICBpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgcmV0dXJuICEhd2lubm93KFxuICAgICAgICAgICAgICAgIHRoaXMsXG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG4gICAgICAgICAgICAgICAgLy8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuICAgICAgICAgICAgICAgIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHNlbGVjdG9yICkgOlxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciB8fCBbXSxcbiAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbiAgICB2YXIgcm9vdGpRdWVyeSxcblxuICAgICAgICAvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuICAgICAgICAvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG4gICAgICAgIC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuICAgICAgICAvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG4gICAgICAgIHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuICAgICAgICBpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2gsIGVsZW07XG5cbiAgICAgICAgICAgIC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuICAgICAgICAgICAgaWYgKCAhc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuICAgICAgICAgICAgLy8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuICAgICAgICAgICAgcm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuICAgICAgICAgICAgaWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcbiAgICAgICAgICAgICAgICBpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoWyAxIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsgMSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgKSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoI2lkKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1sgMCBdID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG4gICAgICAgICAgICAgICAgICAgIC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuICAgICAgICAgICAgICAgIHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChmdW5jdGlvbilcbiAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IoIGpRdWVyeSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcbiAgICAgICAgfTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuICAgIGluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG4gICAgcm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG4gICAgdmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG4gICAgICAgIC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG4gICAgICAgIGd1YXJhbnRlZWRVbmlxdWUgPSB7XG4gICAgICAgICAgICBjaGlsZHJlbjogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRlbnRzOiB0cnVlLFxuICAgICAgICAgICAgbmV4dDogdHJ1ZSxcbiAgICAgICAgICAgIHByZXY6IHRydWVcbiAgICAgICAgfTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICAgICAgaGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuICAgICAgICAgICAgdmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuICAgICAgICAgICAgICAgIGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuICAgICAgICAgICAgdmFyIGN1cixcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBsID0gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IFtdLFxuICAgICAgICAgICAgICAgIHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cbiAgICAgICAgICAgIC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcbiAgICAgICAgICAgIGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZC5wdXNoKCBjdXIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuICAgICAgICBpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cbiAgICAgICAgICAgIC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG4gICAgICAgICAgICBpZiAoICFlbGVtICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5kZXggaW4gc2VsZWN0b3JcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcbiAgICAgICAgICAgIHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cbiAgICAgICAgICAgICAgICAvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcbiAgICAgICAgICAgICAgICBlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soXG4gICAgICAgICAgICAgICAgalF1ZXJ5LnVuaXF1ZVNvcnQoXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuICAgICAgICB3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG4gICAgICAgIHJldHVybiBjdXI7XG4gICAgfVxuXG4gICAgalF1ZXJ5LmVhY2goIHtcbiAgICAgICAgcGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcbiAgICAgICAgICAgIHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuICAgICAgICB9LFxuICAgICAgICBwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuICAgICAgICAgICAgcmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuICAgICAgICB9LFxuICAgICAgICBwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuICAgICAgICB9LFxuICAgICAgICBzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuICAgICAgICB9LFxuICAgICAgICBjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICBpZiAoIGVsZW0uY29udGVudERvY3VtZW50ICE9IG51bGwgJiZcblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExK1xuICAgICAgICAgICAgICAgIC8vIDxvYmplY3Q+IGVsZW1lbnRzIHdpdGggbm8gYGRhdGFgIGF0dHJpYnV0ZSBoYXMgYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gYGNvbnRlbnREb2N1bWVudGAgd2l0aCBhIGBudWxsYCBwcm90b3R5cGUuXG4gICAgICAgICAgICAgICAgZ2V0UHJvdG8oIGVsZW0uY29udGVudERvY3VtZW50ICkgKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxuICAgICAgICAgICAgLy8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG4gICAgICAgICAgICAvLyBkb24ndCBzdXBwb3J0IGl0LlxuICAgICAgICAgICAgaWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0ZW1wbGF0ZVwiICkgKSB7XG4gICAgICAgICAgICAgICAgZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG4gICAgICAgIGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cbiAgICAgICAgICAgIGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdW50aWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBkdXBsaWNhdGVzXG4gICAgICAgICAgICAgICAgaWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG4gICAgICAgICAgICAgICAgaWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuICAgICAgICB9O1xuICAgIH0gKTtcbiAgICB2YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgalF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG4gICAgICAgICAgICBvYmplY3RbIGZsYWcgXSA9IHRydWU7XG4gICAgICAgIH0gKTtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xuICAgIGpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuICAgICAgICAvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG4gICAgICAgIC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcbiAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cbiAgICAgICAgICAgIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG4gICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG4gICAgICAgIHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG4gICAgICAgICAgICBmaXJpbmcsXG5cbiAgICAgICAgICAgIC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG4gICAgICAgICAgICBtZW1vcnksXG5cbiAgICAgICAgICAgIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG4gICAgICAgICAgICBmaXJlZCxcblxuICAgICAgICAgICAgLy8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuICAgICAgICAgICAgbG9ja2VkLFxuXG4gICAgICAgICAgICAvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuICAgICAgICAgICAgbGlzdCA9IFtdLFxuXG4gICAgICAgICAgICAvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuICAgICAgICAgICAgcXVldWUgPSBbXSxcblxuICAgICAgICAgICAgLy8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG4gICAgICAgICAgICBmaXJpbmdJbmRleCA9IC0xLFxuXG4gICAgICAgICAgICAvLyBGaXJlIGNhbGxiYWNrc1xuICAgICAgICAgICAgZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgLy8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG4gICAgICAgICAgICAgICAgbG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcblxuICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcbiAgICAgICAgICAgICAgICBmaXJlZCA9IGZpcmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVtb3J5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG4gICAgICAgICAgICAgICAgaWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9yeSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZpcmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2RcbiAgICAgICAgICAgICAgICBpZiAoIGxvY2tlZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG4gICAgICAgICAgICAgICAgICAgIGlmICggbWVtb3J5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG4gICAgICAgICAgICBzZWxmID0ge1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIGFkZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggbGlzdCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaCggbWVtb3J5ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGlzRnVuY3Rpb24oIGFyZyApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goIGFyZyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0b1R5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGQoIGFyZyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSApKCBhcmd1bWVudHMgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJpbmdJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgICAgICAvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cbiAgICAgICAgICAgICAgICBoYXM6IGZ1bmN0aW9uKCBmbiApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgZW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGxpc3QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcbiAgICAgICAgICAgICAgICAvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcbiAgICAgICAgICAgICAgICAvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBkaXNhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9ja2VkID0gcXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IG1lbW9yeSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWxpc3Q7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIERpc2FibGUgLmZpcmVcbiAgICAgICAgICAgICAgICAvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuICAgICAgICAgICAgICAgIC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcbiAgICAgICAgICAgICAgICBsb2NrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9ja2VkID0gcXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gbWVtb3J5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxvY2tlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWxvY2tlZDtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhbG9ja2VkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3MgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaCggYXJncyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhZmlyaW5nICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICBmaXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2VcbiAgICAgICAgICAgICAgICBmaXJlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWZpcmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuXG4gICAgZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcbiAgICAgICAgdGhyb3cgZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcbiAgICAgICAgdmFyIG1ldGhvZDtcblxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG4gICAgICAgICAgICBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXIgdGhlbmFibGVzXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuICAgICAgICAgICAgICAgIG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cbiAgICAgICAgICAgICAgICAvLyBPdGhlciBub24tdGhlbmFibGVzXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxuICAgICAgICAgICAgICAgIC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcbiAgICAgICAgICAgICAgICAvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuICAgICAgICAgICAgICAgIHJlc29sdmUuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdLnNsaWNlKCBub1ZhbHVlICkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG4gICAgICAgICAgICAvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG4gICAgICAgICAgICAvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuICAgICAgICB9IGNhdGNoICggdmFsdWUgKSB7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcbiAgICAgICAgICAgIC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcbiAgICAgICAgICAgIHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGpRdWVyeS5leHRlbmQoIHtcblxuICAgICAgICBEZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG4gICAgICAgICAgICB2YXIgdHVwbGVzID0gW1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cbiAgICAgICAgICAgICAgICAgICAgWyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuICAgICAgICAgICAgICAgICAgICBbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG4gICAgICAgICAgICAgICAgICAgIFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IFwicGVuZGluZ1wiLFxuICAgICAgICAgICAgICAgIHByb21pc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG4gICAgICAgICAgICAgICAgICAgIHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbnMgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggX2ksIHR1cGxlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJldHVybmVkICYmIGlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZC5wcm9taXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm5zID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKS5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhEZXB0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5lZCwgdGhlbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiA9IHJldHVybmVkICYmXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQudGhlbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNwZWNpYWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RGVwdGgrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbi5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnlXaXRoIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gWyByZXR1cm5lZCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgdmFsdWUocylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MgPSBzcGVjaWFsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaWdodFRocm93IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pZ2h0VGhyb3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Muc3RhY2tUcmFjZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBbIGUgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Vic2VxdWVudCBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkZXB0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblByb2dyZXNzIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLm5vdGlmeVdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25GdWxmaWxsZWQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElkZW50aXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlamVjdGVkIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaHJvd2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSApLnByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSB7fTtcblxuICAgICAgICAgICAgLy8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuICAgICAgICAgICAgalF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG4gICAgICAgICAgICAgICAgLy8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG4gICAgICAgICAgICAgICAgLy8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcbiAgICAgICAgICAgICAgICAvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuICAgICAgICAgICAgICAgIHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHN0YXRlXG4gICAgICAgICAgICAgICAgaWYgKCBzdGF0ZVN0cmluZyApIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhdGUgPSBcInJlamVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnVsZmlsbGVkX2hhbmRsZXJzLmRpc2FibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICB0dXBsZXNbIDAgXVsgMiBdLmxvY2ssXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcbiAgICAgICAgICAgICAgICAvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuICAgICAgICAgICAgICAgIC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcbiAgICAgICAgICAgICAgICBsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cbiAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cbiAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuICAgICAgICAgICAgICAgIGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcbiAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcbiAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuICAgICAgICAgICAgICAgIGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuICAgICAgICAgICAgcHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG4gICAgICAgICAgICAvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG4gICAgICAgICAgICBpZiAoIGZ1bmMgKSB7XG4gICAgICAgICAgICAgICAgZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWxsIGRvbmUhXG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRGVmZXJyZWQgaGVscGVyXG4gICAgICAgIHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcbiAgICAgICAgICAgIHZhclxuXG4gICAgICAgICAgICAgICAgLy8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuICAgICAgICAgICAgICAgIC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIGkgPSByZW1haW5pbmcsXG5cbiAgICAgICAgICAgICAgICAvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcbiAgICAgICAgICAgICAgICByZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cbiAgICAgICAgICAgICAgICAvLyB0aGUgcHJpbWFyeSBEZWZlcnJlZFxuICAgICAgICAgICAgICAgIHByaW1hcnkgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuICAgICAgICAgICAgICAgIC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3RvcnlcbiAgICAgICAgICAgICAgICB1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeS5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG4gICAgICAgICAgICBpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuICAgICAgICAgICAgICAgIGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBwcmltYXJ5LmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIHByaW1hcnkucmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAhcmVtYWluaW5nICk7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG4gICAgICAgICAgICAgICAgaWYgKCBwcmltYXJ5LnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmltYXJ5LnRoZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG4gICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICBhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgcHJpbWFyeS5yZWplY3QgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHByaW1hcnkucHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgfSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG4gICAgdmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbiAgICBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuICAgICAgICAvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuICAgICAgICBpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuICAgICAgICAgICAgd2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cblxuICAgIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0gKTtcbiAgICB9O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbiAgICB2YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbiAgICBqUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cbiAgICAgICAgcmVhZHlMaXN0XG4gICAgICAgICAgICAudGhlbiggZm4gKVxuXG4gICAgICAgICAgICAvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuICAgICAgICAgICAgLy8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG4gICAgICAgICAgICAvLyByZWdpc3RyYXRpb24uXG4gICAgICAgICAgICAuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGpRdWVyeS5leHRlbmQoIHtcblxuICAgICAgICAvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuICAgICAgICBpc1JlYWR5OiBmYWxzZSxcblxuICAgICAgICAvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG4gICAgICAgIC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG4gICAgICAgIHJlYWR5V2FpdDogMSxcblxuICAgICAgICAvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG4gICAgICAgIHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuICAgICAgICAgICAgLy8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuICAgICAgICAgICAgaWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcbiAgICAgICAgICAgIGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcbiAgICAgICAgICAgIGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuICAgICAgICAgICAgcmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuICAgICAgICB9XG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbiAgICBmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbiAgICAgICAgalF1ZXJ5LnJlYWR5KCk7XG4gICAgfVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbiAgICBpZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuICAgICAgICAoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuICAgICAgICAvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuICAgICAgICAvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuICAgIH1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbiAgICB2YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBsZW4gPSBlbGVtcy5sZW5ndGgsXG4gICAgICAgICAgICBidWxrID0ga2V5ID09IG51bGw7XG5cbiAgICAgICAgLy8gU2V0cyBtYW55IHZhbHVlc1xuICAgICAgICBpZiAoIHRvVHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG4gICAgICAgICAgICBjaGFpbmFibGUgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICggaSBpbiBrZXkgKSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldHMgb25lIHZhbHVlXG4gICAgICAgIH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBjaGFpbmFibGUgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoICFpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuICAgICAgICAgICAgICAgIHJhdyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggYnVsayApIHtcblxuICAgICAgICAgICAgICAgIC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuICAgICAgICAgICAgICAgIGlmICggcmF3ICkge1xuICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICAgICAgZm4gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWxrID0gZm47XG4gICAgICAgICAgICAgICAgICAgIGZuID0gZnVuY3Rpb24oIGVsZW0sIF9rZXksIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGZuICkge1xuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBmbihcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGNoYWluYWJsZSApIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldHNcbiAgICAgICAgaWYgKCBidWxrICkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG4gICAgfTtcblxuXG4vLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbiAgICB2YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcbiAgICAgICAgcmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nO1xuXG4vLyBVc2VkIGJ5IGNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcbiAgICBmdW5jdGlvbiBmY2FtZWxDYXNlKCBfYWxsLCBsZXR0ZXIgKSB7XG4gICAgICAgIHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbi8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcbi8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3MilcbiAgICBmdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG4gICAgfVxuICAgIHZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG4gICAgICAgIC8vIEFjY2VwdHMgb25seTpcbiAgICAgICAgLy8gIC0gTm9kZVxuICAgICAgICAvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG4gICAgICAgIC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG4gICAgICAgIC8vICAtIE9iamVjdFxuICAgICAgICAvLyAgICAtIEFueVxuICAgICAgICByZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG4gICAgfTtcblxuXG5cblxuICAgIGZ1bmN0aW9uIERhdGEoKSB7XG4gICAgICAgIHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbiAgICB9XG5cbiAgICBEYXRhLnVpZCA9IDE7XG5cbiAgICBEYXRhLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuICAgICAgICAgICAgLy8gSWYgbm90LCBjcmVhdGUgb25lXG4gICAgICAgICAgICBpZiAoICF2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cbiAgICAgICAgICAgICAgICBpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG4gICAgICAgICAgICB2YXIgcHJvcCxcbiAgICAgICAgICAgICAgICBjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3NcbiAgICAgICAgICAgIC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1NylcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVbIGNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3RcbiAgICAgICAgICAgICAgICBmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlWyBjYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcbiAgICAgICAgICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZSggb3duZXIgKSA6XG5cbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG4gICAgICAgICAgICAgICAgb3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuICAgICAgICB9LFxuICAgICAgICBhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuICAgICAgICAgICAgLy8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcbiAgICAgICAgICAgIC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuICAgICAgICAgICAgLy8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3RcbiAgICAgICAgICAgIC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgKCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG4gICAgICAgICAgICAvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG4gICAgICAgICAgICBpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcbiAgICAgICAgICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIGtleSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXkubWFwKCBjYW1lbENhc2UgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBjYW1lbENhc2UoIGtleSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5IGluIGNhY2hlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFsga2V5IF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgKCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGkgPSBrZXkubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKCBpLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuICAgICAgICAgICAgaWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcbiAgICAgICAgICAgICAgICAvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuICAgICAgICAgICAgICAgIGlmICggb3duZXIubm9kZVR5cGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG4gICAgdmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxuICAgIHZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG4gICAgICAgIHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuICAgIGZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XG4gICAgICAgIGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcbiAgICAgICAgaWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG4gICAgICAgICAgICByZXR1cm4gK2RhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcbiAgICAgICAgdmFyIG5hbWU7XG5cbiAgICAgICAgLy8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuICAgICAgICAvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcbiAgICAgICAgaWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcbiAgICAgICAgICAgIG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKCBlICkge31cblxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuICAgICAgICAgICAgICAgIGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgalF1ZXJ5LmV4dGVuZCgge1xuICAgICAgICBoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuICAgICAgICAgICAgZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcbiAgICAgICAgLy8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG4gICAgICAgIF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG4gICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICAgICAgZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG4gICAgICAgICAgICB2YXIgaSwgbmFtZSwgZGF0YSxcbiAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1sgMCBdLFxuICAgICAgICAgICAgICAgIGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIC8vIEdldHMgYWxsIHZhbHVlc1xuICAgICAgICAgICAgaWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBhdHRycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGF0dHJzWyBpIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YTtcblxuICAgICAgICAgICAgICAgIC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG4gICAgICAgICAgICAgICAgLy8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuICAgICAgICAgICAgICAgIGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuICAgICAgICAgICAgICAgICAgICAvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGRhdGEuLi5cbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgfSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cblxuICAgIGpRdWVyeS5leHRlbmQoIHtcbiAgICAgICAgcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuICAgICAgICAgICAgdmFyIHF1ZXVlO1xuXG4gICAgICAgICAgICBpZiAoIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG4gICAgICAgICAgICAgICAgLy8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuICAgICAgICAgICAgICAgIGlmICggZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaCggZGF0YSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBxdWV1ZSB8fCBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuICAgICAgICAgICAgdmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG4gICAgICAgICAgICAgICAgc3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgZm4gPSBxdWV1ZS5zaGlmdCgpLFxuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG4gICAgICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcbiAgICAgICAgICAgIGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuICAgICAgICAgICAgICAgIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBzdGFydExlbmd0aC0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGZuICkge1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgZGVsZXRlIGhvb2tzLnN0b3A7XG4gICAgICAgICAgICAgICAgZm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG4gICAgICAgICAgICAgICAgaG9va3MuZW1wdHkuZmlyZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG4gICAgICAgIF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuICAgICAgICAgICAgICAgIGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcbiAgICAgICAgICAgICAgICB9IClcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICAgICAgcXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuICAgICAgICAgICAgdmFyIHNldHRlciA9IDI7XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgdHlwZSA9IFwiZnhcIjtcbiAgICAgICAgICAgICAgICBzZXR0ZXItLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB0aGlzIDpcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuICAgICAgICAvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcbiAgICAgICAgcHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcbiAgICAgICAgICAgIHZhciB0bXAsXG4gICAgICAgICAgICAgICAgY291bnQgPSAxLFxuICAgICAgICAgICAgICAgIGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGkgPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICByZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggISggLS1jb3VudCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gdHlwZTtcbiAgICAgICAgICAgICAgICB0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG4gICAgICAgICAgICB3aGlsZSAoIGktLSApIHtcbiAgICAgICAgICAgICAgICB0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuICAgICAgICAgICAgICAgIGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgdG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcbiAgICAgICAgfVxuICAgIH0gKTtcbiAgICB2YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbiAgICB2YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxuICAgIHZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxuICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG4gICAgdmFyIGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuICAgICAgICB9LFxuICAgICAgICBjb21wb3NlZCA9IHsgY29tcG9zZWQ6IHRydWUgfTtcblxuICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCssIGlPUyAxMC4wIC0gMTAuMiBvbmx5XG4gICAgLy8gQ2hlY2sgYXR0YWNobWVudCBhY3Jvc3Mgc2hhZG93IERPTSBib3VuZGFyaWVzIHdoZW4gcG9zc2libGUgKGdoLTM1MDQpXG4gICAgLy8gU3VwcG9ydDogaU9TIDEwLjAtMTAuMiBvbmx5XG4gICAgLy8gRWFybHkgaU9TIDEwIHZlcnNpb25zIHN1cHBvcnQgYGF0dGFjaFNoYWRvd2AgYnV0IG5vdCBgZ2V0Um9vdE5vZGVgLFxuICAgIC8vIGxlYWRpbmcgdG8gZXJyb3JzLiBXZSBuZWVkIHRvIGNoZWNrIGZvciBgZ2V0Um9vdE5vZGVgLlxuICAgIGlmICggZG9jdW1lbnRFbGVtZW50LmdldFJvb3ROb2RlICkge1xuICAgICAgICBpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSB8fFxuICAgICAgICAgICAgICAgIGVsZW0uZ2V0Um9vdE5vZGUoIGNvbXBvc2VkICkgPT09IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuICAgICAgICAvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcbiAgICAgICAgLy8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG4gICAgICAgIGVsZW0gPSBlbCB8fCBlbGVtO1xuXG4gICAgICAgIC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG4gICAgICAgIHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG4gICAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuICAgICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcbiAgICAgICAgICAgIC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuICAgICAgICAgICAgLy8gaW4gdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgaXNBdHRhY2hlZCggZWxlbSApICYmXG5cbiAgICAgICAgICAgIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuICAgIH07XG5cblxuXG4gICAgZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcbiAgICAgICAgdmFyIGFkanVzdGVkLCBzY2FsZSxcbiAgICAgICAgICAgIG1heEl0ZXJhdGlvbnMgPSAyMCxcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR3ZWVuLmN1cigpO1xuICAgICAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG4gICAgICAgICAgICB1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cbiAgICAgICAgICAgIC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG4gICAgICAgICAgICBpbml0aWFsSW5Vbml0ID0gZWxlbS5ub2RlVHlwZSAmJlxuICAgICAgICAgICAgICAgICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG4gICAgICAgICAgICAgICAgcmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuICAgICAgICBpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcbiAgICAgICAgICAgIC8vIEhhbHZlIHRoZSBpdGVyYXRpb24gdGFyZ2V0IHZhbHVlIHRvIHByZXZlbnQgaW50ZXJmZXJlbmNlIGZyb20gQ1NTIHVwcGVyIGJvdW5kcyAoZ2gtMjE0NClcbiAgICAgICAgICAgIGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuICAgICAgICAgICAgLy8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuICAgICAgICAgICAgdW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG4gICAgICAgICAgICAvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuICAgICAgICAgICAgaW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cbiAgICAgICAgICAgIHdoaWxlICggbWF4SXRlcmF0aW9ucy0tICkge1xuXG4gICAgICAgICAgICAgICAgLy8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cbiAgICAgICAgICAgICAgICAvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG4gICAgICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuICAgICAgICAgICAgICAgIGlmICggKCAxIC0gc2NhbGUgKSAqICggMSAtICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgfHwgMC41ICkgKSA8PSAwICkge1xuICAgICAgICAgICAgICAgICAgICBtYXhJdGVyYXRpb25zID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAqIDI7XG4gICAgICAgICAgICBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cbiAgICAgICAgICAgIHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB2YWx1ZVBhcnRzICkge1xuICAgICAgICAgICAgaW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuICAgICAgICAgICAgYWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuICAgICAgICAgICAgICAgIGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG4gICAgICAgICAgICAgICAgK3ZhbHVlUGFydHNbIDIgXTtcbiAgICAgICAgICAgIGlmICggdHdlZW4gKSB7XG4gICAgICAgICAgICAgICAgdHdlZW4udW5pdCA9IHVuaXQ7XG4gICAgICAgICAgICAgICAgdHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuICAgICAgICAgICAgICAgIHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGp1c3RlZDtcbiAgICB9XG5cblxuICAgIHZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XG4gICAgICAgIHZhciB0ZW1wLFxuICAgICAgICAgICAgZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuICAgICAgICAgICAgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuICAgICAgICAgICAgZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG4gICAgICAgIGlmICggZGlzcGxheSApIHtcbiAgICAgICAgICAgIHJldHVybiBkaXNwbGF5O1xuICAgICAgICB9XG5cbiAgICAgICAgdGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuICAgICAgICBkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuICAgICAgICB0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuICAgICAgICBpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuICAgICAgICAgICAgZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cbiAgICAgICAgcmV0dXJuIGRpc3BsYXk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuICAgICAgICB2YXIgZGlzcGxheSwgZWxlbSxcbiAgICAgICAgICAgIHZhbHVlcyA9IFtdLFxuICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG4gICAgICAgIC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuICAgICAgICBmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuICAgICAgICAgICAgZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuICAgICAgICAgICAgaWYgKCAhZWxlbS5zdHlsZSApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcbiAgICAgICAgICAgIGlmICggc2hvdyApIHtcblxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcbiAgICAgICAgICAgICAgICAvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG4gICAgICAgICAgICAgICAgaWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG4gICAgICAgIGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG4gICAgICAgICAgICBpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuICAgICAgICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuICAgICAgICB9LFxuICAgICAgICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuICAgICAgICB9LFxuICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcbiAgICAgICAgICAgIGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgIH0gKTtcbiAgICB2YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbiAgICB2YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSApO1xuXG4gICAgdmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4gICAgKCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICAgICAgZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuICAgICAgICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG4gICAgICAgIC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG4gICAgICAgIC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcbiAgICAgICAgLy8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcbiAgICAgICAgLy8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG4gICAgICAgIHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcbiAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuICAgICAgICBzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgICAgICAvLyBJRSA8PTkgcmVwbGFjZXMgPG9wdGlvbj4gdGFncyB3aXRoIHRoZWlyIGNvbnRlbnRzIHdoZW4gaW5zZXJ0ZWQgb3V0c2lkZSBvZlxuICAgICAgICAvLyB0aGUgc2VsZWN0IGVsZW1lbnQuXG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjxvcHRpb24+PC9vcHRpb24+XCI7XG4gICAgICAgIHN1cHBvcnQub3B0aW9uID0gISFkaXYubGFzdENoaWxkO1xuICAgIH0gKSgpO1xuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG4gICAgdmFyIHdyYXBNYXAgPSB7XG5cbiAgICAgICAgLy8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcbiAgICAgICAgLy8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuICAgICAgICAvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG4gICAgICAgIHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcbiAgICAgICAgY29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcbiAgICAgICAgdHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuICAgICAgICB0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cbiAgICAgICAgX2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG4gICAgfTtcblxuICAgIHdyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG4gICAgd3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgaWYgKCAhc3VwcG9ydC5vcHRpb24gKSB7XG4gICAgICAgIHdyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbiA9IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcbiAgICAgICAgLy8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuICAgICAgICB2YXIgcmV0O1xuXG4gICAgICAgIGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgICAgICAgICByZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgICAgICAgcmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbiAgICBmdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGwgPSBlbGVtcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICggOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgICAgZGF0YVByaXYuc2V0KFxuICAgICAgICAgICAgICAgIGVsZW1zWyBpIF0sXG4gICAgICAgICAgICAgICAgXCJnbG9iYWxFdmFsXCIsXG4gICAgICAgICAgICAgICAgIXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgdmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG4gICAgZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcbiAgICAgICAgdmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcbiAgICAgICAgICAgIGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgICAgICBub2RlcyA9IFtdLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBsID0gZWxlbXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoIDsgaSA8IGw7IGkrKyApIHtcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtc1sgaSBdO1xuXG4gICAgICAgICAgICBpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBub2RlcyBkaXJlY3RseVxuICAgICAgICAgICAgICAgIGlmICggdG9UeXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgdG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIGogPSB3cmFwWyAwIF07XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggai0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gdG1wLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG4gICAgICAgICAgICAgICAgICAgIHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuICAgICAgICBmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cbiAgICAgICAgaSA9IDA7XG4gICAgICAgIHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cbiAgICAgICAgICAgIC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG4gICAgICAgICAgICBpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGlnbm9yZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZWQucHVzaCggZWxlbSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXR0YWNoZWQgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cbiAgICAgICAgICAgIC8vIEFwcGVuZCB0byBmcmFnbWVudFxuICAgICAgICAgICAgdG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cbiAgICAgICAgICAgIC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3RvcnlcbiAgICAgICAgICAgIGlmICggYXR0YWNoZWQgKSB7XG4gICAgICAgICAgICAgICAgc2V0R2xvYmFsRXZhbCggdG1wICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcbiAgICAgICAgICAgIGlmICggc2NyaXB0cyApIHtcbiAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0cy5wdXNoKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfVxuXG5cbiAgICB2YXIgcnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG4gICAgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuLy8gZm9jdXMoKSBhbmQgYmx1cigpIGFyZSBhc3luY2hyb25vdXMsIGV4Y2VwdCB3aGVuIHRoZXkgYXJlIG5vLW9wLlxuLy8gU28gZXhwZWN0IGZvY3VzIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBhY3RpdmUsXG4vLyBhbmQgYmx1ciB0byBiZSBzeW5jaHJvbm91cyB3aGVuIHRoZSBlbGVtZW50IGlzIG5vdCBhbHJlYWR5IGFjdGl2ZS5cbi8vIChmb2N1cyBhbmQgYmx1ciBhcmUgYWx3YXlzIHN5bmNocm9ub3VzIGluIG90aGVyIHN1cHBvcnRlZCBicm93c2Vycyxcbi8vIHRoaXMganVzdCBkZWZpbmVzIHdoZW4gd2UgY2FuIGNvdW50IG9uIGl0KS5cbiAgICBmdW5jdGlvbiBleHBlY3RTeW5jKCBlbGVtLCB0eXBlICkge1xuICAgICAgICByZXR1cm4gKCBlbGVtID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICkgPT09ICggdHlwZSA9PT0gXCJmb2N1c1wiICk7XG4gICAgfVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gQWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHRocm93IHVuZXhwZWN0ZWRseVxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXG4gICAgZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgfSBjYXRjaCAoIGVyciApIHsgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG4gICAgICAgIHZhciBvcmlnRm4sIHR5cGU7XG5cbiAgICAgICAgLy8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG4gICAgICAgIGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG4gICAgICAgICAgICAvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuICAgICAgICAgICAgaWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuICAgICAgICAgICAgICAgIG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIC8vICggdHlwZXMsIGZuIClcbiAgICAgICAgICAgIGZuID0gc2VsZWN0b3I7XG4gICAgICAgICAgICBkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuICAgICAgICAgICAgICAgIC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG4gICAgICAgICAgICAgICAgZm4gPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gKCB0eXBlcywgZGF0YSwgZm4gKVxuICAgICAgICAgICAgICAgIGZuID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkYXRhID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBmbiA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICBmbiA9IHJldHVybkZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCAhZm4gKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggb25lID09PSAxICkge1xuICAgICAgICAgICAgb3JpZ0ZuID0gZm47XG4gICAgICAgICAgICBmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuICAgICAgICAgICAgICAgIC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuICAgICAgICAgICAgICAgIGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG4gICAgICAgICAgICBmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcbiAgICAgICAgfSApO1xuICAgIH1cblxuICAgIC8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG4gICAgalF1ZXJ5LmV2ZW50ID0ge1xuXG4gICAgICAgIGdsb2JhbDoge30sXG5cbiAgICAgICAgYWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG4gICAgICAgICAgICB2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG4gICAgICAgICAgICAgICAgZXZlbnRzLCB0LCBoYW5kbGVPYmosXG4gICAgICAgICAgICAgICAgc3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuICAgICAgICAgICAgICAgIGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgYXR0YWNoIGV2ZW50cyB0byBvYmplY3RzIHRoYXQgYWNjZXB0IGRhdGFcbiAgICAgICAgICAgIGlmICggIWFjY2VwdERhdGEoIGVsZW0gKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuICAgICAgICAgICAgaWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcbiAgICAgICAgICAgIC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuICAgICAgICAgICAgaWYgKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG4gICAgICAgICAgICBpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAgICAgaWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcbiAgICAgICAgICAgICAgICBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSBPYmplY3QuY3JlYXRlKCBudWxsICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2VcbiAgICAgICAgICAgIHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcbiAgICAgICAgICAgIHQgPSB0eXBlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIHQtLSApIHtcbiAgICAgICAgICAgICAgICB0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG4gICAgICAgICAgICAgICAgdHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuICAgICAgICAgICAgICAgIC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuICAgICAgICAgICAgICAgIGlmICggIXR5cGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG4gICAgICAgICAgICAgICAgdHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdUeXBlOiBvcmlnVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgZ3VpZDogaGFuZGxlci5ndWlkLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG4gICAgICAgICAgICAgICAgfSwgaGFuZGxlT2JqSW4gKTtcblxuICAgICAgICAgICAgICAgIC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgaWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXNwZWNpYWwuc2V0dXAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggc3BlY2lhbC5hZGQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcbiAgICAgICAgICAgICAgICBpZiAoIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuICAgICAgICAgICAgdmFyIGosIG9yaWdDb3VudCwgdG1wLFxuICAgICAgICAgICAgICAgIGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuICAgICAgICAgICAgICAgIHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcbiAgICAgICAgICAgICAgICBlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuICAgICAgICAgICAgaWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG4gICAgICAgICAgICB0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG4gICAgICAgICAgICB0ID0gdHlwZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCB0LS0gKSB7XG4gICAgICAgICAgICAgICAgdG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoICF0eXBlICkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuICAgICAgICAgICAgICAgIHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcbiAgICAgICAgICAgICAgICBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRtcCA9IHRtcFsgMiBdICYmXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuICAgICAgICAgICAgICAgIG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCBqLS0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG4gICAgICAgICAgICAgICAgLy8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG4gICAgICAgICAgICAgICAgaWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnRzWyB0eXBlIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuICAgICAgICAgICAgaWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG4gICAgICAgICAgICAgICAgZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cbiAgICAgICAgICAgIHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblxuICAgICAgICAgICAgICAgIC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgICAgIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKSxcblxuICAgICAgICAgICAgICAgIGhhbmRsZXJzID0gKFxuICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCBPYmplY3QuY3JlYXRlKCBudWxsIClcbiAgICAgICAgICAgICAgICApWyBldmVudC50eXBlIF0gfHwgW10sXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cbiAgICAgICAgICAgIC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG4gICAgICAgICAgICBhcmdzWyAwIF0gPSBldmVudDtcblxuICAgICAgICAgICAgZm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgYXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuICAgICAgICAgICAgaWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaGFuZGxlcnNcbiAgICAgICAgICAgIGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuICAgICAgICAgICAgLy8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG4gICAgICAgICAgICAgICAgIWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGV2ZW50IGlzIG5hbWVzcGFjZWQsIHRoZW4gZWFjaCBoYW5kbGVyIGlzIG9ubHkgaW52b2tlZCBpZiBpdCBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWFsbHkgdW5pdmVyc2FsIG9yIGl0cyBuYW1lc3BhY2VzIGFyZSBhIHN1cGVyc2V0IG9mIHRoZSBldmVudCdzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGhhbmRsZU9iai5uYW1lc3BhY2UgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG4gICAgICAgICAgICBpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuICAgICAgICAgICAgICAgIHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBldmVudC5yZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG4gICAgICAgICAgICB2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcbiAgICAgICAgICAgICAgICBoYW5kbGVyUXVldWUgPSBbXSxcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcbiAgICAgICAgICAgICAgICBjdXIgPSBldmVudC50YXJnZXQ7XG5cbiAgICAgICAgICAgIC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcbiAgICAgICAgICAgIGlmICggZGVsZWdhdGVDb3VudCAmJlxuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05XG4gICAgICAgICAgICAgICAgLy8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG4gICAgICAgICAgICAgICAgY3VyLm5vZGVUeXBlICYmXG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcbiAgICAgICAgICAgICAgICAvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcbiAgICAgICAgICAgICAgICAvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG4gICAgICAgICAgICAgICAgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG4gICAgICAgICAgICAgICAgICAgIGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuICAgICAgICAgICAgY3VyID0gdGhpcztcbiAgICAgICAgICAgIGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJRdWV1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG4gICAgICAgICAgICAgICAgZ2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50IDpcbiAgICAgICAgICAgICAgICBuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3BlY2lhbDoge1xuICAgICAgICAgICAgbG9hZDoge1xuXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuICAgICAgICAgICAgICAgIG5vQnViYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xpY2s6IHtcblxuICAgICAgICAgICAgICAgIC8vIFV0aWxpemUgbmF0aXZlIGV2ZW50IHRvIGVuc3VyZSBjb3JyZWN0IHN0YXRlIGZvciBjaGVja2FibGUgaW5wdXRzXG4gICAgICAgICAgICAgICAgc2V0dXA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuICAgICAgICAgICAgICAgICAgICAvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhdGFQcml2LnNldCggZWwsIFwiY2xpY2tcIiwgLi4uIClcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiLCByZXR1cm5UcnVlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiggZGF0YSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cbiAgICAgICAgICAgICAgICAgICAgLy8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpcyB8fCBkYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyaW5nIGEgY2xpY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgc3VwcHJlc3MgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG4gICAgICAgICAgICAgICAgX2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJjaGVja2FibGVUeXBlLnRlc3QoIHRhcmdldC50eXBlICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5jbGljayAmJiBub2RlTmFtZSggdGFyZ2V0LCBcImlucHV0XCIgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuZ2V0KCB0YXJnZXQsIFwiY2xpY2tcIiApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlTmFtZSggdGFyZ2V0LCBcImFcIiApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGJlZm9yZXVubG9hZDoge1xuICAgICAgICAgICAgICAgIHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbi8vIEVuc3VyZSB0aGUgcHJlc2VuY2Ugb2YgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBoYW5kbGVzIG1hbnVhbGx5LXRyaWdnZXJlZFxuLy8gc3ludGhldGljIGV2ZW50cyBieSBpbnRlcnJ1cHRpbmcgcHJvZ3Jlc3MgdW50aWwgcmVpbnZva2VkIGluIHJlc3BvbnNlIHRvXG4vLyAqbmF0aXZlKiBldmVudHMgdGhhdCBpdCBmaXJlcyBkaXJlY3RseSwgZW5zdXJpbmcgdGhhdCBzdGF0ZSBjaGFuZ2VzIGhhdmVcbi8vIGFscmVhZHkgb2NjdXJyZWQgYmVmb3JlIG90aGVyIGxpc3RlbmVycyBhcmUgaW52b2tlZC5cbiAgICBmdW5jdGlvbiBsZXZlcmFnZU5hdGl2ZSggZWwsIHR5cGUsIGV4cGVjdFN5bmMgKSB7XG5cbiAgICAgICAgLy8gTWlzc2luZyBleHBlY3RTeW5jIGluZGljYXRlcyBhIHRyaWdnZXIgY2FsbCwgd2hpY2ggbXVzdCBmb3JjZSBzZXR1cCB0aHJvdWdoIGpRdWVyeS5ldmVudC5hZGRcbiAgICAgICAgaWYgKCAhZXhwZWN0U3luYyApIHtcbiAgICAgICAgICAgIGlmICggZGF0YVByaXYuZ2V0KCBlbCwgdHlwZSApID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHJldHVyblRydWUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcbiAgICAgICAgZGF0YVByaXYuc2V0KCBlbCwgdHlwZSwgZmFsc2UgKTtcbiAgICAgICAgalF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZTogZmFsc2UsXG4gICAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vdEFzeW5jLCByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIHNhdmVkID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoICggZXZlbnQuaXNUcmlnZ2VyICYgMSApICYmIHRoaXNbIHR5cGUgXSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBvZiB0aGUgb3V0ZXIgc3ludGhldGljIC50cmlnZ2VyKCllZCBldmVudFxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlZCBkYXRhIHNob3VsZCBiZSBmYWxzZSBpbiBzdWNoIGNhc2VzLCBidXQgbWlnaHQgYmUgYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIGFuIGFzeW5jIG5hdGl2ZSBoYW5kbGVyIChnaC00MzUwKVxuICAgICAgICAgICAgICAgICAgICBpZiAoICFzYXZlZC5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIGFyZ3VtZW50cyBmb3IgdXNlIHdoZW4gaGFuZGxpbmcgdGhlIGlubmVyIG5hdGl2ZSBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgd2lsbCBhbHdheXMgYmUgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IChhbiBldmVudCBvYmplY3QpLCBzbyB0aGlzIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlZCA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBzYXZlZCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91c1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90QXN5bmMgPSBleHBlY3RTeW5jKCB0aGlzLCB0eXBlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzWyB0eXBlIF0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzYXZlZCAhPT0gcmVzdWx0IHx8IG5vdEFzeW5jICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgZmFsc2UgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNhdmVkICE9PSByZXN1bHQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgODYrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gQ2hyb21lLCBpZiBhbiBlbGVtZW50IGhhdmluZyBhIGZvY3Vzb3V0IGhhbmRsZXIgaXMgYmx1cnJlZCBieVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsaWNraW5nIG91dHNpZGUgb2YgaXQsIGl0IGludm9rZXMgdGhlIGhhbmRsZXIgc3luY2hyb25vdXNseS4gSWZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGhhbmRsZXIgY2FsbHMgYC5yZW1vdmUoKWAgb24gdGhlIGVsZW1lbnQsIHRoZSBkYXRhIGlzIGNsZWFyZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGVhdmluZyBgcmVzdWx0YCB1bmRlZmluZWQuIFdlIG5lZWQgdG8gZ3VhcmQgYWdhaW5zdCB0aGlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgJiYgcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCBmb3IgYW4gZXZlbnQgd2l0aCBhIGJ1YmJsaW5nIHN1cnJvZ2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmcgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuYXRpdmUgZXZlbnQgYW5kIHByZXZlbnQgdGhhdCBmcm9tIGhhcHBlbmluZyBhZ2FpbiBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB0ZWNobmljYWxseSBnZXRzIHRoZSBvcmRlcmluZyB3cm9uZyB3LnIudC4gdG8gYC50cmlnZ2VyKClgIChpbiB3aGljaCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxlc3MgYmFkIHRoYW4gZHVwbGljYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fSApLmRlbGVnYXRlVHlwZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG5hdGl2ZSBldmVudCB0cmlnZ2VyZWQgYWJvdmUsIGV2ZXJ5dGhpbmcgaXMgbm93IGluIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IHdpdGggdGhlIG9yaWdpbmFsIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHNhdmVkLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyAuLi5hbmQgY2FwdHVyZSB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGpRdWVyeS5ldmVudC50cmlnZ2VyKFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5kIHdpdGggdGhlIHByb3RvdHlwZSB0byByZXNldCB0aGUgYWJvdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKCBzYXZlZFsgMCBdLCBqUXVlcnkuRXZlbnQucHJvdG90eXBlICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZWQuc2xpY2UoIDEgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBYm9ydCBoYW5kbGluZyBvZiB0aGUgbmF0aXZlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSApO1xuICAgIH1cblxuICAgIGpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cbiAgICAgICAgLy8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG4gICAgICAgIGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuICAgICAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBqUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuICAgICAgICAvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcbiAgICAgICAgaWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXZlbnQgb2JqZWN0XG4gICAgICAgIGlmICggc3JjICYmIHNyYy50eXBlICkge1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gc3JjLnR5cGU7XG5cbiAgICAgICAgICAgIC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG4gICAgICAgICAgICAvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICAgICAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcbiAgICAgICAgICAgIHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG4gICAgICAgICAgICBzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cbiAgICAgICAgICAgICAgICByZXR1cm5UcnVlIDpcbiAgICAgICAgICAgICAgICByZXR1cm5GYWxzZTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG4gICAgICAgICAgICAvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cbiAgICAgICAgICAgICAgICBzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuICAgICAgICAgICAgICAgIHNyYy50YXJnZXQ7XG5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICAgICAgICAgIC8vIEV2ZW50IHR5cGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHNyYztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG4gICAgICAgIGlmICggcHJvcHMgKSB7XG4gICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcbiAgICAgICAgdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuXG4gICAgICAgIC8vIE1hcmsgaXQgYXMgZml4ZWRcbiAgICAgICAgdGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG4gICAgfTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG4gICAgalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcbiAgICAgICAgaXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcbiAgICAgICAgaXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuICAgICAgICBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gICAgICAgIGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuICAgICAgICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgICAgICAgICBpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cbiAgICAgICAgICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgICAgICAgICBpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICAgICAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuICAgICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xuICAgIGpRdWVyeS5lYWNoKCB7XG4gICAgICAgIGFsdEtleTogdHJ1ZSxcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgY2hhbmdlZFRvdWNoZXM6IHRydWUsXG4gICAgICAgIGN0cmxLZXk6IHRydWUsXG4gICAgICAgIGRldGFpbDogdHJ1ZSxcbiAgICAgICAgZXZlbnRQaGFzZTogdHJ1ZSxcbiAgICAgICAgbWV0YUtleTogdHJ1ZSxcbiAgICAgICAgcGFnZVg6IHRydWUsXG4gICAgICAgIHBhZ2VZOiB0cnVlLFxuICAgICAgICBzaGlmdEtleTogdHJ1ZSxcbiAgICAgICAgdmlldzogdHJ1ZSxcbiAgICAgICAgXCJjaGFyXCI6IHRydWUsXG4gICAgICAgIGNvZGU6IHRydWUsXG4gICAgICAgIGNoYXJDb2RlOiB0cnVlLFxuICAgICAgICBrZXk6IHRydWUsXG4gICAgICAgIGtleUNvZGU6IHRydWUsXG4gICAgICAgIGJ1dHRvbjogdHJ1ZSxcbiAgICAgICAgYnV0dG9uczogdHJ1ZSxcbiAgICAgICAgY2xpZW50WDogdHJ1ZSxcbiAgICAgICAgY2xpZW50WTogdHJ1ZSxcbiAgICAgICAgb2Zmc2V0WDogdHJ1ZSxcbiAgICAgICAgb2Zmc2V0WTogdHJ1ZSxcbiAgICAgICAgcG9pbnRlcklkOiB0cnVlLFxuICAgICAgICBwb2ludGVyVHlwZTogdHJ1ZSxcbiAgICAgICAgc2NyZWVuWDogdHJ1ZSxcbiAgICAgICAgc2NyZWVuWTogdHJ1ZSxcbiAgICAgICAgdGFyZ2V0VG91Y2hlczogdHJ1ZSxcbiAgICAgICAgdG9FbGVtZW50OiB0cnVlLFxuICAgICAgICB0b3VjaGVzOiB0cnVlLFxuICAgICAgICB3aGljaDogdHJ1ZVxuICAgIH0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbiAgICBqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggdHlwZSwgZGVsZWdhdGVUeXBlICkge1xuICAgICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdID0ge1xuXG4gICAgICAgICAgICAvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3RcbiAgICAgICAgICAgIHNldHVwOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG4gICAgICAgICAgICAgICAgLy8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImZvY3VzXCIsIC4uLiApXG4gICAgICAgICAgICAgICAgLy8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImJsdXJcIiwgLi4uIClcbiAgICAgICAgICAgICAgICBsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSwgZXhwZWN0U3luYyApO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlclxuICAgICAgICAgICAgICAgIGxldmVyYWdlTmF0aXZlKCB0aGlzLCB0eXBlICk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBTdXBwcmVzcyBuYXRpdmUgZm9jdXMgb3IgYmx1ciBhcyBpdCdzIGFscmVhZHkgYmVpbmcgZmlyZWRcbiAgICAgICAgICAgIC8vIGluIGxldmVyYWdlTmF0aXZlLlxuICAgICAgICAgICAgX2RlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGVsZWdhdGVUeXBlOiBkZWxlZ2F0ZVR5cGVcbiAgICAgICAgfTtcbiAgICB9ICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG4gICAgalF1ZXJ5LmVhY2goIHtcbiAgICAgICAgbW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcbiAgICAgICAgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuICAgICAgICBwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcbiAgICAgICAgcG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxuICAgIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG4gICAgICAgIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG4gICAgICAgICAgICBkZWxlZ2F0ZVR5cGU6IGZpeCxcbiAgICAgICAgICAgIGJpbmRUeXBlOiBmaXgsXG5cbiAgICAgICAgICAgIGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuICAgICAgICAgICAgICAgIHZhciByZXQsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuICAgICAgICAgICAgICAgIC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG4gICAgICAgICAgICAgICAgaWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBmaXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuXG4gICAgICAgIG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcbiAgICAgICAgICAgIHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuICAgICAgICB9LFxuICAgICAgICBvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuICAgICAgICAgICAgcmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG4gICAgICAgIH0sXG4gICAgICAgIG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlT2JqLCB0eXBlO1xuICAgICAgICAgICAgaWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cbiAgICAgICAgICAgICAgICAvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG4gICAgICAgICAgICAgICAgaGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuICAgICAgICAgICAgICAgIGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5vcmlnVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmouaGFuZGxlclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuICAgICAgICAgICAgICAgIC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG4gICAgICAgICAgICAgICAgZm9yICggdHlwZSBpbiB0eXBlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyAoIHR5cGVzIFssIGZuXSApXG4gICAgICAgICAgICAgICAgZm4gPSBzZWxlY3RvcjtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggZm4gPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIGZuID0gcmV0dXJuRmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cblxuICAgIHZhclxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzIG9ubHlcbiAgICAgICAgLy8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cbiAgICAgICAgcm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cbiAgICAgICAgLy8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG4gICAgICAgIHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcbiAgICAgICAgcmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4vLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbiAgICBmdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG4gICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG4gICAgICAgICAgICBub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeSggZWxlbSApLmNoaWxkcmVuKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICB9XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbiAgICBmdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuICAgICAgICBlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG4gICAgICAgIGlmICggKCBlbGVtLnR5cGUgfHwgXCJcIiApLnNsaWNlKCAwLCA1ICkgPT09IFwidHJ1ZS9cIiApIHtcbiAgICAgICAgICAgIGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuICAgICAgICB2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG4gICAgICAgIGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG4gICAgICAgIGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG4gICAgICAgICAgICBwZGF0YU9sZCA9IGRhdGFQcml2LmdldCggc3JjICk7XG4gICAgICAgICAgICBldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cbiAgICAgICAgICAgIGlmICggZXZlbnRzICkge1xuICAgICAgICAgICAgICAgIGRhdGFQcml2LnJlbW92ZSggZGVzdCwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblxuICAgICAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIENvcHkgdXNlciBkYXRhXG4gICAgICAgIGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG4gICAgICAgICAgICB1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG4gICAgICAgICAgICB1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG4gICAgICAgICAgICBkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG4gICAgICAgIH1cbiAgICB9XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuICAgIGZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG4gICAgICAgIHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cbiAgICAgICAgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG4gICAgICAgICAgICBkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuICAgICAgICAgICAgLy8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcbiAgICAgICAgfSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuICAgICAgICAgICAgZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG4gICAgICAgIC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcbiAgICAgICAgYXJncyA9IGZsYXQoIGFyZ3MgKTtcblxuICAgICAgICB2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgICAgIGlOb0Nsb25lID0gbCAtIDEsXG4gICAgICAgICAgICB2YWx1ZSA9IGFyZ3NbIDAgXSxcbiAgICAgICAgICAgIHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cbiAgICAgICAgLy8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG4gICAgICAgIGlmICggdmFsdWVJc0Z1bmN0aW9uIHx8XG4gICAgICAgICAgICAoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgICFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcbiAgICAgICAgICAgICAgICBpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBsICkge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcbiAgICAgICAgICAgIGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuICAgICAgICAgICAgaWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGZpcnN0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcbiAgICAgICAgICAgICAgICBzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG4gICAgICAgICAgICAgICAgaGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuICAgICAgICAgICAgICAgIC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuICAgICAgICAgICAgICAgIC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG4gICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gZnJhZ21lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpICE9PSBpTm9DbG9uZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBoYXNTY3JpcHRzICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggaGFzU2NyaXB0cyApIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZWVuYWJsZSBzY3JpcHRzXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHNjcmlwdHNbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uY2U6IG5vZGUubm9uY2UgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoIFwibm9uY2VcIiApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBkb2MgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIG5vZGUsIGRvYyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuICAgICAgICB2YXIgbm9kZSxcbiAgICAgICAgICAgIG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcbiAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgIGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcbiAgICAgICAgICAgIGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBrZWVwRGF0YSAmJiBpc0F0dGFjaGVkKCBub2RlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuXG4gICAgalF1ZXJ5LmV4dGVuZCgge1xuICAgICAgICBodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG4gICAgICAgICAgICB2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcbiAgICAgICAgICAgICAgICBjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG4gICAgICAgICAgICAgICAgaW5QYWdlID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG4gICAgICAgICAgICAvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcbiAgICAgICAgICAgIGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcbiAgICAgICAgICAgICAgICAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcbiAgICAgICAgICAgICAgICBkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG4gICAgICAgICAgICAgICAgc3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcbiAgICAgICAgICAgIGlmICggZGF0YUFuZEV2ZW50cyApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuICAgICAgICAgICAgICAgICAgICBzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICBkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3RvcnlcbiAgICAgICAgICAgIGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcbiAgICAgICAgICAgIGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgc2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuICAgICAgICAgICAgdmFyIGRhdGEsIGVsZW0sIHR5cGUsXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGEuZXZlbnRzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgIHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXBwZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJlcGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmVmb3JlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuICAgICAgICAgICAgICAgICAgICBlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG4gICAgICAgICAgICBkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuICAgICAgICAgICAgZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbCA9IHRoaXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG4gICAgICAgICAgICAgICAgICAgICF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKCBlICkge31cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaWdub3JlZCA9IFtdO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcbiAgICAgICAgICAgIHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBwYXJlbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG4gICAgICAgICAgICB9LCBpZ25vcmVkICk7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbiAgICBqUXVlcnkuZWFjaCgge1xuICAgICAgICBhcHBlbmRUbzogXCJhcHBlbmRcIixcbiAgICAgICAgcHJlcGVuZFRvOiBcInByZXBlbmRcIixcbiAgICAgICAgaW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuICAgICAgICBpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuICAgICAgICByZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbiAgICB9LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG4gICAgICAgIGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuICAgICAgICAgICAgdmFyIGVsZW1zLFxuICAgICAgICAgICAgICAgIHJldCA9IFtdLFxuICAgICAgICAgICAgICAgIGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcbiAgICAgICAgICAgICAgICBsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG4gICAgICAgICAgICAgICAgZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcbiAgICAgICAgICAgICAgICBqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcbiAgICAgICAgICAgICAgICAvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG4gICAgICAgICAgICAgICAgcHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuICAgICAgICB9O1xuICAgIH0gKTtcbiAgICB2YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbiAgICB2YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuICAgICAgICAvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcbiAgICAgICAgLy8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG4gICAgICAgIHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG4gICAgICAgIGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuICAgICAgICAgICAgdmlldyA9IHdpbmRvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcbiAgICB9O1xuXG4gICAgdmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XG4gICAgICAgIHZhciByZXQsIG5hbWUsXG4gICAgICAgICAgICBvbGQgPSB7fTtcblxuICAgICAgICAvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcbiAgICAgICAgZm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuICAgICAgICAgICAgb2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG4gICAgICAgICAgICBlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBjYWxsYmFjay5jYWxsKCBlbGVtICk7XG5cbiAgICAgICAgLy8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG4gICAgICAgIGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcbiAgICAgICAgICAgIGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG5cbiAgICB2YXIgcmJveFN0eWxlID0gbmV3IFJlZ0V4cCggY3NzRXhwYW5kLmpvaW4oIFwifFwiICksIFwiaVwiICk7XG5cblxuXG4gICAgKCBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcbiAgICAgICAgLy8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2VcbiAgICAgICAgICAgIGlmICggIWRpdiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7XCIgK1xuICAgICAgICAgICAgICAgIFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG4gICAgICAgICAgICBkaXYuc3R5bGUuY3NzVGV4dCA9XG4gICAgICAgICAgICAgICAgXCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuICAgICAgICAgICAgICAgIFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG4gICAgICAgICAgICAgICAgXCJ3aWR0aDo2MCU7dG9wOjElXCI7XG4gICAgICAgICAgICBkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuICAgICAgICAgICAgdmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuICAgICAgICAgICAgcGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG4gICAgICAgICAgICByZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xuICAgICAgICAgICAgLy8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG4gICAgICAgICAgICBkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuICAgICAgICAgICAgcGl4ZWxCb3hTdHlsZXNWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLnJpZ2h0ICkgPT09IDM2O1xuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuICAgICAgICAgICAgLy8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuICAgICAgICAgICAgYm94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLndpZHRoICkgPT09IDM2O1xuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IG9ubHlcbiAgICAgICAgICAgIC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTY0XG4gICAgICAgICAgICAvLyBEb24ndCBnZXQgdHJpY2tlZCB3aGVuIHpvb20gYWZmZWN0cyBvZmZzZXRXaWR0aCAoZ2gtNDAyOSlcbiAgICAgICAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgIHNjcm9sbGJveFNpemVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdi5vZmZzZXRXaWR0aCAvIDMgKSA9PT0gMTI7XG5cbiAgICAgICAgICAgIGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cbiAgICAgICAgICAgIC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcbiAgICAgICAgICAgIC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcbiAgICAgICAgICAgIGRpdiA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByb3VuZFBpeGVsTWVhc3VyZXMoIG1lYXN1cmUgKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuICAgICAgICAgICAgcmVsaWFibGVUckRpbWVuc2lvbnNWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcbiAgICAgICAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuICAgICAgICAvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuICAgICAgICBpZiAoICFkaXYuc3R5bGUgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG4gICAgICAgIC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcbiAgICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuICAgICAgICBkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuICAgICAgICBzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG4gICAgICAgIGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcbiAgICAgICAgICAgIGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlU3R5bGVUZXN0cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwaXhlbEJveFN0eWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVN0eWxlVGVzdHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVN0eWxlVGVzdHMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY3JvbGxib3hTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlU3R5bGVUZXN0cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxNSAtIDE4K1xuICAgICAgICAgICAgLy8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcbiAgICAgICAgICAgIC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuICAgICAgICAgICAgLy8gQmVoYXZpb3IgaW4gSUUgOSBpcyBtb3JlIHN1YnRsZSB0aGFuIGluIG5ld2VyIHZlcnNpb25zICYgaXQgcGFzc2VzXG4gICAgICAgICAgICAvLyBzb21lIHZlcnNpb25zIG9mIHRoaXMgdGVzdDsgbWFrZSBzdXJlIG5vdCB0byBtYWtlIGl0IHBhc3MgdGhlcmUhXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCA3MCtcbiAgICAgICAgICAgIC8vIE9ubHkgRmlyZWZveCBpbmNsdWRlcyBib3JkZXIgd2lkdGhzXG4gICAgICAgICAgICAvLyBpbiBjb21wdXRlZCBkaW1lbnNpb25zLiAoZ2gtNDUyOSlcbiAgICAgICAgICAgIHJlbGlhYmxlVHJEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFibGUsIHRyLCB0ckNoaWxkLCB0clN0eWxlO1xuICAgICAgICAgICAgICAgIGlmICggcmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRhYmxlXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgdHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRyXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgdHJDaGlsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuICAgICAgICAgICAgICAgICAgICB0YWJsZS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O2JvcmRlci1jb2xsYXBzZTpzZXBhcmF0ZVwiO1xuICAgICAgICAgICAgICAgICAgICB0ci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MXB4IHNvbGlkXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDg2K1xuICAgICAgICAgICAgICAgICAgICAvLyBIZWlnaHQgc2V0IHRocm91Z2ggY3NzVGV4dCBkb2VzIG5vdCBnZXQgYXBwbGllZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZWQgaGVpZ2h0IHRoZW4gY29tZXMgYmFjayBhcyAwLlxuICAgICAgICAgICAgICAgICAgICB0ci5zdHlsZS5oZWlnaHQgPSBcIjFweFwiO1xuICAgICAgICAgICAgICAgICAgICB0ckNoaWxkLnN0eWxlLmhlaWdodCA9IFwiOXB4XCI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA4IENocm9tZSA4NitcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gb3VyIGJvZHlCYWNrZ3JvdW5kLmh0bWwgaWZyYW1lLFxuICAgICAgICAgICAgICAgICAgICAvLyBkaXNwbGF5IGZvciBhbGwgZGl2IGVsZW1lbnRzIGlzIHNldCB0byBcImlubGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBjYXVzZXMgYSBwcm9ibGVtIG9ubHkgaW4gQW5kcm9pZCA4IENocm9tZSA4Ni5cbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJpbmcgdGhlIGRpdiBpcyBkaXNwbGF5OiBibG9ja1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXRzIGFyb3VuZCB0aGlzIGlzc3VlLlxuICAgICAgICAgICAgICAgICAgICB0ckNoaWxkLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kQ2hpbGQoIHRhYmxlIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRDaGlsZCggdHIgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZENoaWxkKCB0ckNoaWxkICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCB0ciApO1xuICAgICAgICAgICAgICAgICAgICByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCA9ICggcGFyc2VJbnQoIHRyU3R5bGUuaGVpZ2h0LCAxMCApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KCB0clN0eWxlLmJvcmRlclRvcFdpZHRoLCAxMCApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KCB0clN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCApICkgPT09IHRyLm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIHRhYmxlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSApO1xuICAgIH0gKSgpO1xuXG5cbiAgICBmdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuICAgICAgICB2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuICAgICAgICAgICAgLy8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuICAgICAgICAgICAgLy8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuICAgICAgICAgICAgLy8gb24gZGV0YWNoZWQgZWxlbWVudHNcbiAgICAgICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcblxuICAgICAgICBjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG4gICAgICAgIC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcbiAgICAgICAgLy8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG4gICAgICAgIC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxuICAgICAgICBpZiAoIGNvbXB1dGVkICkge1xuICAgICAgICAgICAgcmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cbiAgICAgICAgICAgIGlmICggcmV0ID09PSBcIlwiICYmICFpc0F0dGFjaGVkKCBlbGVtICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcbiAgICAgICAgICAgIC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuICAgICAgICAgICAgLy8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG4gICAgICAgICAgICBpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG4gICAgICAgICAgICAgICAgd2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgICAgICAgICAgICBtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuICAgICAgICAgICAgICAgIG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cbiAgICAgICAgICAgICAgICAvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG4gICAgICAgICAgICAgICAgc3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuICAgICAgICAgICAgICAgIHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgc3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcbiAgICAgICAgICAgICAgICBzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuICAgICAgICAgICAgLy8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cbiAgICAgICAgICAgIHJldCArIFwiXCIgOlxuICAgICAgICAgICAgcmV0O1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG4gICAgICAgIC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5nZXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICByZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIHZhciBjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG4gICAgICAgIGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGUsXG4gICAgICAgIHZlbmRvclByb3BzID0ge307XG5cbi8vIFJldHVybiBhIHZlbmRvci1wcmVmaXhlZCBwcm9wZXJ0eSBvciB1bmRlZmluZWRcbiAgICBmdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuICAgICAgICAvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG4gICAgICAgIHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG4gICAgICAgICAgICBpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgbmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuICAgICAgICAgICAgaWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbi8vIFJldHVybiBhIHBvdGVudGlhbGx5LW1hcHBlZCBqUXVlcnkuY3NzUHJvcHMgb3IgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG4gICAgZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcbiAgICAgICAgdmFyIGZpbmFsID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gfHwgdmVuZG9yUHJvcHNbIG5hbWUgXTtcblxuICAgICAgICBpZiAoIGZpbmFsICkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlbmRvclByb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG4gICAgfVxuXG5cbiAgICB2YXJcblxuICAgICAgICAvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG4gICAgICAgIC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuICAgICAgICAvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcbiAgICAgICAgcmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuICAgICAgICByY3VzdG9tUHJvcCA9IC9eLS0vLFxuICAgICAgICBjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcbiAgICAgICAgY3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuICAgICAgICAgICAgbGV0dGVyU3BhY2luZzogXCIwXCIsXG4gICAgICAgICAgICBmb250V2VpZ2h0OiBcIjQwMFwiXG4gICAgICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggX2VsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuICAgICAgICAvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG4gICAgICAgIC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuICAgICAgICB2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXMgP1xuXG4gICAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuICAgICAgICAgICAgTWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG4gICAgICAgICAgICB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgYm94LCBpc0JvcmRlckJveCwgc3R5bGVzLCBjb21wdXRlZFZhbCApIHtcbiAgICAgICAgdmFyIGkgPSBkaW1lbnNpb24gPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuICAgICAgICAgICAgZXh0cmEgPSAwLFxuICAgICAgICAgICAgZGVsdGEgPSAwO1xuXG4gICAgICAgIC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCBib3ggPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG4gICAgICAgICAgICAvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cbiAgICAgICAgICAgIGlmICggYm94ID09PSBcIm1hcmdpblwiICkge1xuICAgICAgICAgICAgICAgIGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGNvbnRlbnQtYm94LCB3ZSdyZSBzZWVraW5nIFwicGFkZGluZ1wiIG9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIlxuICAgICAgICAgICAgaWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuICAgICAgICAgICAgICAgIGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuICAgICAgICAgICAgICAgIGlmICggYm94ICE9PSBcInBhZGRpbmdcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2VcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleHRyYSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3JcbiAgICAgICAgICAgICAgICAvLyBcInBhZGRpbmdcIiBvciBcIm1hcmdpblwiXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIFwiY29udGVudFwiLCBzdWJ0cmFjdCBwYWRkaW5nXG4gICAgICAgICAgICAgICAgaWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxuICAgICAgICAgICAgICAgIGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG4gICAgICAgIGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cbiAgICAgICAgICAgIC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcbiAgICAgICAgICAgIC8vIEFzc3VtaW5nIGludGVnZXIgc2Nyb2xsIGd1dHRlciwgc3VidHJhY3QgdGhlIHJlc3QgYW5kIHJvdW5kIGRvd25cbiAgICAgICAgICAgIGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG4gICAgICAgICAgICAgICAgZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cbiAgICAgICAgICAgICAgICBjb21wdXRlZFZhbCAtXG4gICAgICAgICAgICAgICAgZGVsdGEgLVxuICAgICAgICAgICAgICAgIGV4dHJhIC1cbiAgICAgICAgICAgICAgICAwLjVcblxuICAgICAgICAgICAgICAgIC8vIElmIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyB1bmtub3duLCB0aGVuIHdlIGNhbid0IGRldGVybWluZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyXG4gICAgICAgICAgICAgICAgLy8gVXNlIGFuIGV4cGxpY2l0IHplcm8gdG8gYXZvaWQgTmFOIChnaC0zOTY0KVxuICAgICAgICAgICAgKSApIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVsdGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuICAgICAgICAvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG4gICAgICAgIHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuICAgICAgICAgICAgLy8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtNDMyMikuXG4gICAgICAgICAgICAvLyBGYWtlIGNvbnRlbnQtYm94IHVudGlsIHdlIGtub3cgaXQncyBuZWVkZWQgdG8ga25vdyB0aGUgdHJ1ZSB2YWx1ZS5cbiAgICAgICAgICAgIGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG4gICAgICAgICAgICBpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuICAgICAgICAgICAgICAgIGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG4gICAgICAgICAgICB2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3gsXG5cbiAgICAgICAgICAgIHZhbCA9IGN1ckNTUyggZWxlbSwgZGltZW5zaW9uLCBzdHlsZXMgKSxcbiAgICAgICAgICAgIG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuICAgICAgICAvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cbiAgICAgICAgaWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG4gICAgICAgICAgICBpZiAoICFleHRyYSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsID0gXCJhdXRvXCI7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG4gICAgICAgIC8vIFVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlLlxuICAgICAgICAvLyBJbiB0aG9zZSBjYXNlcywgdGhlIGNvbXB1dGVkIHZhbHVlIGNhbiBiZSB0cnVzdGVkIHRvIGJlIGJvcmRlci1ib3guXG4gICAgICAgIGlmICggKCAhc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpICYmIGlzQm9yZGVyQm94IHx8XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDEwIC0gMTErLCBFZGdlIDE1IC0gMTgrXG4gICAgICAgICAgICAvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxuICAgICAgICAgICAgLy8gc2V0IGluIENTUyB3aGlsZSBgb2Zmc2V0KmAgcHJvcGVydGllcyByZXBvcnQgY29ycmVjdCB2YWx1ZXMuXG4gICAgICAgICAgICAvLyBJbnRlcmVzdGluZ2x5LCBpbiBzb21lIGNhc2VzIElFIDkgZG9lc24ndCBzdWZmZXIgZnJvbSB0aGlzIGlzc3VlLlxuICAgICAgICAgICAgIXN1cHBvcnQucmVsaWFibGVUckRpbWVuc2lvbnMoKSAmJiBub2RlTmFtZSggZWxlbSwgXCJ0clwiICkgfHxcblxuICAgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG4gICAgICAgICAgICAvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG4gICAgICAgICAgICB2YWwgPT09IFwiYXV0b1wiIHx8XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgLSA0LjMgb25seVxuICAgICAgICAgICAgLy8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciBtaXNyZXBvcnRlZCBpbmxpbmUgZGltZW5zaW9ucyAoZ2gtMzYwMilcbiAgICAgICAgICAgICFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImlubGluZVwiICkgJiZcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBlbGVtZW50IGlzIHZpc2libGUgJiBjb25uZWN0ZWRcbiAgICAgICAgICAgIGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgIGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuICAgICAgICAgICAgLy8gV2hlcmUgYXZhaWxhYmxlLCBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgYXBwcm94aW1hdGUgYm9yZGVyIGJveCBkaW1lbnNpb25zLlxuICAgICAgICAgICAgLy8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuICAgICAgICAgICAgLy8gcmV0cmlldmVkIHZhbHVlIGFzIGEgY29udGVudCBib3ggZGltZW5zaW9uLlxuICAgICAgICAgICAgdmFsdWVJc0JvcmRlckJveCA9IG9mZnNldFByb3AgaW4gZWxlbTtcbiAgICAgICAgICAgIGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBlbGVtWyBvZmZzZXRQcm9wIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG4gICAgICAgIC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcbiAgICAgICAgcmV0dXJuICggdmFsICtcbiAgICAgICAgICAgIGJveE1vZGVsQWRqdXN0bWVudChcbiAgICAgICAgICAgICAgICBlbGVtLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbixcbiAgICAgICAgICAgICAgICBleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG4gICAgICAgICAgICAgICAgdmFsdWVJc0JvcmRlckJveCxcbiAgICAgICAgICAgICAgICBzdHlsZXMsXG5cbiAgICAgICAgICAgICAgICAvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxuICAgICAgICAgICAgICAgIHZhbFxuICAgICAgICAgICAgKVxuICAgICAgICApICsgXCJweFwiO1xuICAgIH1cblxuICAgIGpRdWVyeS5leHRlbmQoIHtcblxuICAgICAgICAvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcbiAgICAgICAgLy8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG4gICAgICAgIGNzc0hvb2tzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggY29tcHV0ZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG4gICAgICAgIGNzc051bWJlcjoge1xuICAgICAgICAgICAgXCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJmbGV4R3Jvd1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJmbGV4U2hyaW5rXCI6IHRydWUsXG4gICAgICAgICAgICBcImZvbnRXZWlnaHRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiZ3JpZEFyZWFcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiZ3JpZENvbHVtblwiOiB0cnVlLFxuICAgICAgICAgICAgXCJncmlkQ29sdW1uRW5kXCI6IHRydWUsXG4gICAgICAgICAgICBcImdyaWRDb2x1bW5TdGFydFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJncmlkUm93XCI6IHRydWUsXG4gICAgICAgICAgICBcImdyaWRSb3dFbmRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiZ3JpZFJvd1N0YXJ0XCI6IHRydWUsXG4gICAgICAgICAgICBcImxpbmVIZWlnaHRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwib3BhY2l0eVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJvcmRlclwiOiB0cnVlLFxuICAgICAgICAgICAgXCJvcnBoYW5zXCI6IHRydWUsXG4gICAgICAgICAgICBcIndpZG93c1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJ6SW5kZXhcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiem9vbVwiOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuICAgICAgICAvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG4gICAgICAgIGNzc1Byb3BzOiB7fSxcblxuICAgICAgICAvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuICAgICAgICBzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuICAgICAgICAgICAgLy8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG4gICAgICAgICAgICBpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuICAgICAgICAgICAgdmFyIHJldCwgdHlwZSwgaG9va3MsXG4gICAgICAgICAgICAgICAgb3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcbiAgICAgICAgICAgICAgICBpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBlbGVtLnN0eWxlO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG4gICAgICAgICAgICAvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cbiAgICAgICAgICAgIGlmICggIWlzQ3VzdG9tUHJvcCApIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cbiAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcbiAgICAgICAgICAgIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuICAgICAgICAgICAgICAgIGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRml4ZXMgYnVnICM5MjM3XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcIm51bWJlclwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG4gICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIC8vIFRoZSBpc0N1c3RvbVByb3AgY2hlY2sgY2FuIGJlIHJlbW92ZWQgaW4galF1ZXJ5IDQuMCB3aGVuIHdlIG9ubHkgYXV0by1hcHBlbmRcbiAgICAgICAgICAgICAgICAvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cbiAgICAgICAgICAgICAgICBpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWlzQ3VzdG9tUHJvcCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG4gICAgICAgICAgICAgICAgaWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG4gICAgICAgICAgICAgICAgICAgICggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGlzQ3VzdG9tUHJvcCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG4gICAgICAgICAgICAgICAgaWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZVsgbmFtZSBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG4gICAgICAgICAgICB2YXIgdmFsLCBudW0sIGhvb2tzLFxuICAgICAgICAgICAgICAgIG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG4gICAgICAgICAgICAgICAgaXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG4gICAgICAgICAgICAvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG4gICAgICAgICAgICAvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG4gICAgICAgICAgICBpZiAoICFpc0N1c3RvbVByb3AgKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcbiAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG4gICAgICAgICAgICAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuICAgICAgICAgICAgaWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuICAgICAgICAgICAgICAgIHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcbiAgICAgICAgICAgIGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG4gICAgICAgICAgICBpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG4gICAgICAgICAgICBpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuICAgICAgICAgICAgICAgIG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuICAgICAgICAgICAgICAgIHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggX2ksIGRpbWVuc2lvbiApIHtcbiAgICAgICAgalF1ZXJ5LmNzc0hvb2tzWyBkaW1lbnNpb24gXSA9IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGNvbXB1dGVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuICAgICAgICAgICAgICAgICAgICAvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgLy8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVhZCBzdHlsZXMucG9zaXRpb24gaWYgdGhlIHRlc3QgaGFzIGEgY2hhbmNlIHRvIGZhaWxcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdy5cbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYm94U2l6ZUJ1Z2d5ID0gIXN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXMucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIixcblxuICAgICAgICAgICAgICAgICAgICAvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC0zOTkxKVxuICAgICAgICAgICAgICAgICAgICBib3hTaXppbmdOZWVkZWQgPSBzY3JvbGxib3hTaXplQnVnZ3kgfHwgZXh0cmEsXG4gICAgICAgICAgICAgICAgICAgIGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICAgICAgICAgICAgICBzdWJ0cmFjdCA9IGV4dHJhID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGJveE1vZGVsQWRqdXN0bWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0JvcmRlckJveCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgMDtcblxuICAgICAgICAgICAgICAgIC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuICAgICAgICAgICAgICAgIC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG4gICAgICAgICAgICAgICAgaWYgKCBpc0JvcmRlckJveCAmJiBzY3JvbGxib3hTaXplQnVnZ3kgKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnRyYWN0IC09IE1hdGguY2VpbChcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgYm94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIFwiYm9yZGVyXCIsIGZhbHNlLCBzdHlsZXMgKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuICAgICAgICAgICAgICAgICAgICBlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuICAgICAgICBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG4gICAgICAgICAgICBpZiAoIGNvbXB1dGVkICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG4gICAgICAgICAgICAgICAgICAgIHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIH0gKVxuICAgICAgICAgICAgICAgICkgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG4gICAgalF1ZXJ5LmVhY2goIHtcbiAgICAgICAgbWFyZ2luOiBcIlwiLFxuICAgICAgICBwYWRkaW5nOiBcIlwiLFxuICAgICAgICBib3JkZXI6IFwiV2lkdGhcIlxuICAgIH0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcbiAgICAgICAgalF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcbiAgICAgICAgICAgIGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQgPSB7fSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgcGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBleHBhbmRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIHByZWZpeCAhPT0gXCJtYXJnaW5cIiApIHtcbiAgICAgICAgICAgIGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgICAgIGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZXMsIGxlbixcbiAgICAgICAgICAgICAgICAgICAgbWFwID0ge30sXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICBsZW4gPSBuYW1lLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG4gICAgICAgICAgICB9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuXG4gICAgZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuICAgICAgICByZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xuICAgIH1cbiAgICBqUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuICAgIFR3ZWVuLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IFR3ZWVuLFxuICAgICAgICBpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgICAgICAgdGhpcy5wcm9wID0gcHJvcDtcbiAgICAgICAgICAgIHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICAgICAgdGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cbiAgICAgICAgICAgIHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuICAgICAgICAgICAgICAgIGhvb2tzLmdldCggdGhpcyApIDpcbiAgICAgICAgICAgICAgICBUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG4gICAgICAgIH0sXG4gICAgICAgIHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG4gICAgICAgICAgICB2YXIgZWFzZWQsXG4gICAgICAgICAgICAgICAgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcbiAgICAgICAgICAgICAgICBob29rcy5zZXQoIHRoaXMgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgVHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG4gICAgVHdlZW4ucHJvcEhvb2tzID0ge1xuICAgICAgICBfZGVmYXVsdDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAgICAgICAgIC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgLy8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cbiAgICAgICAgICAgICAgICBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcbiAgICAgICAgICAgICAgICAgICAgdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAgICAgICAgLy8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcbiAgICAgICAgICAgICAgICAvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuICAgICAgICAgICAgICAgIC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuICAgICAgICAgICAgICAgIHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuICAgICAgICAgICAgICAgIC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSB8fFxuICAgICAgICAgICAgICAgICAgICB0d2Vlbi5lbGVtLnN0eWxlWyBmaW5hbFByb3BOYW1lKCB0d2Vlbi5wcm9wICkgXSAhPSBudWxsICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG4gICAgVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcbiAgICAgICAgICAgIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGpRdWVyeS5lYXNpbmcgPSB7XG4gICAgICAgIGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgc3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuICAgICAgICAgICAgcmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcbiAgICAgICAgfSxcbiAgICAgICAgX2RlZmF1bHQ6IFwic3dpbmdcIlxuICAgIH07XG5cbiAgICBqUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbiAgICBqUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG4gICAgdmFyXG4gICAgICAgIGZ4Tm93LCBpblByb2dyZXNzLFxuICAgICAgICByZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcbiAgICAgICAgcnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbiAgICBmdW5jdGlvbiBzY2hlZHVsZSgpIHtcbiAgICAgICAgaWYgKCBpblByb2dyZXNzICkge1xuICAgICAgICAgICAgaWYgKCBkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgalF1ZXJ5LmZ4LnRpY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmeE5vdyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSApO1xuICAgICAgICByZXR1cm4gKCBmeE5vdyA9IERhdGUubm93KCkgKTtcbiAgICB9XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG4gICAgZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcbiAgICAgICAgdmFyIHdoaWNoLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cbiAgICAgICAgLy8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuICAgICAgICAvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuICAgICAgICBpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcbiAgICAgICAgZm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuICAgICAgICAgICAgd2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcbiAgICAgICAgICAgIGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBpbmNsdWRlV2lkdGggKSB7XG4gICAgICAgICAgICBhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuICAgICAgICB2YXIgdHdlZW4sXG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgZm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcbiAgICAgICAgICAgIGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIHJldHVybiB0d2VlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuICAgICAgICB2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG4gICAgICAgICAgICBpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuICAgICAgICAgICAgYW5pbSA9IHRoaXMsXG4gICAgICAgICAgICBvcmlnID0ge30sXG4gICAgICAgICAgICBzdHlsZSA9IGVsZW0uc3R5bGUsXG4gICAgICAgICAgICBoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuICAgICAgICAgICAgZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuICAgICAgICAvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3NcbiAgICAgICAgaWYgKCAhb3B0cy5xdWV1ZSApIHtcbiAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcbiAgICAgICAgICAgIGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICBob29rcy51bnF1ZXVlZCA9IDA7XG4gICAgICAgICAgICAgICAgb2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG4gICAgICAgICAgICAgICAgaG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFob29rcy51bnF1ZXVlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZGZpcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBob29rcy51bnF1ZXVlZCsrO1xuXG4gICAgICAgICAgICBhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuICAgICAgICAgICAgICAgIGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9va3MudW5xdWV1ZWQtLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob29rcy5lbXB0eS5maXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcbiAgICAgICAgZm9yICggcHJvcCBpbiBwcm9wcyApIHtcbiAgICAgICAgICAgIHZhbHVlID0gcHJvcHNbIHByb3AgXTtcbiAgICAgICAgICAgIGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcHJvcHNbIHByb3AgXTtcbiAgICAgICAgICAgICAgICB0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG4gICAgICAgICAgICAgICAgaWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW4gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcbiAgICAgICAgcHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuICAgICAgICBpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuICAgICAgICBpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcbiAgICAgICAgICAgIC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuICAgICAgICAgICAgLy8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1kgYW5kIEVkZ2UganVzdCBtaXJyb3JzXG4gICAgICAgICAgICAvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuICAgICAgICAgICAgb3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cbiAgICAgICAgICAgIC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuICAgICAgICAgICAgcmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuICAgICAgICAgICAgaWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuICAgICAgICAgICAgICAgIHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG4gICAgICAgICAgICBpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuICAgICAgICAgICAgICAgIGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgc2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0hpZGUoIFsgZWxlbSBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcbiAgICAgICAgICAgIGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhcHJvcFR3ZWVuICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbS5kb25lKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggb3B0cy5vdmVyZmxvdyApIHtcbiAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgIGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcbiAgICAgICAgICAgICAgICBzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG4gICAgICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG4gICAgICAgIHByb3BUd2VlbiA9IGZhbHNlO1xuICAgICAgICBmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cbiAgICAgICAgICAgIC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG4gICAgICAgICAgICBpZiAoICFwcm9wVHdlZW4gKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBkYXRhU2hvdyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuICAgICAgICAgICAgICAgIGlmICggdG9nZ2xlICkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG4gICAgICAgICAgICAgICAgaWYgKCBoaWRkZW4gKSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG4gICAgICAgICAgICAgICAgYW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoICFoaWRkZW4gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93SGlkZSggWyBlbGVtIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggcHJvcCBpbiBvcmlnICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUGVyLXByb3BlcnR5IHNldHVwXG4gICAgICAgICAgICBwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcbiAgICAgICAgICAgIGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuICAgICAgICAgICAgICAgIGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKCBoaWRkZW4gKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHByb3BUd2Vlbi5zdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG4gICAgICAgIHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cbiAgICAgICAgLy8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG4gICAgICAgIGZvciAoIGluZGV4IGluIHByb3BzICkge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcbiAgICAgICAgICAgIGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcbiAgICAgICAgICAgIHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG4gICAgICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG4gICAgICAgICAgICAgICAgZWFzaW5nID0gdmFsdWVbIDEgXTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBpbmRleCAhPT0gbmFtZSApIHtcbiAgICAgICAgICAgICAgICBwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuICAgICAgICAgICAgaWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG4gICAgICAgICAgICAgICAgLy8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuICAgICAgICAgICAgICAgIC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcbiAgICAgICAgICAgICAgICBmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcbiAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgIHN0b3BwZWQsXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG4gICAgICAgICAgICBkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBkZWxldGUgdGljay5lbGVtO1xuICAgICAgICAgICAgfSApLFxuICAgICAgICAgICAgdGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICggc3RvcHBlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuICAgICAgICAgICAgICAgICAgICAvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG4gICAgICAgICAgICAgICAgICAgIHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudCA9IDEgLSB0ZW1wLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcbiAgICAgICAgICAgICAgICBpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbWFpbmluZztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoICFsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcbiAgICAgICAgICAgICAgICBlbGVtOiBlbGVtLFxuICAgICAgICAgICAgICAgIHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuICAgICAgICAgICAgICAgIG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbEVhc2luZzoge30sXG4gICAgICAgICAgICAgICAgICAgIGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMgKSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICB0d2VlbnM6IFtdLFxuICAgICAgICAgICAgICAgIGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR3ZWVuO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDAsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHN0b3BwZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIGdvdG9FbmQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gKSxcbiAgICAgICAgICAgIHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG4gICAgICAgIHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cbiAgICAgICAgZm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG4gICAgICAgICAgICBpZiAoIHJlc3VsdCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RvcC5iaW5kKCByZXN1bHQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cbiAgICAgICAgaWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuICAgICAgICAgICAgYW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuICAgICAgICBhbmltYXRpb25cbiAgICAgICAgICAgIC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuICAgICAgICAgICAgLmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcbiAgICAgICAgICAgIC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcbiAgICAgICAgICAgIC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG4gICAgICAgIGpRdWVyeS5meC50aW1lcihcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcbiAgICAgICAgICAgICAgICBlbGVtOiBlbGVtLFxuICAgICAgICAgICAgICAgIGFuaW06IGFuaW1hdGlvbixcbiAgICAgICAgICAgICAgICBxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcbiAgICAgICAgICAgIH0gKVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBhbmltYXRpb247XG4gICAgfVxuXG4gICAgalF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG4gICAgICAgIHR3ZWVuZXJzOiB7XG4gICAgICAgICAgICBcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICBhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHdlZW47XG4gICAgICAgICAgICB9IF1cbiAgICAgICAgfSxcblxuICAgICAgICB0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgaWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcHJvcHM7XG4gICAgICAgICAgICAgICAgcHJvcHMgPSBbIFwiKlwiIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByb3AsXG4gICAgICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gcHJvcHNbIGluZGV4IF07XG4gICAgICAgICAgICAgICAgQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG4gICAgICAgIHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuICAgICAgICAgICAgaWYgKCBwcmVwZW5kICkge1xuICAgICAgICAgICAgICAgIEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbiAgICBqUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG4gICAgICAgIHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG4gICAgICAgICAgICAgICAgaXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBzcGVlZCxcbiAgICAgICAgICAgIGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG4gICAgICAgIGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcbiAgICAgICAgICAgIG9wdC5kdXJhdGlvbiA9IDA7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcbiAgICAgICAgICAgICAgICBpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuICAgICAgICAgICAgICAgICAgICBvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG4gICAgICAgIGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuICAgICAgICAgICAgb3B0LnF1ZXVlID0gXCJmeFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUXVldWVpbmdcbiAgICAgICAgb3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuICAgICAgICBvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuICAgICAgICAgICAgICAgIG9wdC5vbGQuY2FsbCggdGhpcyApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG9wdC5xdWV1ZSApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG9wdDtcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuICAgICAgICBmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cbiAgICAgICAgICAgIC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cbiAgICAgICAgICAgICAgICAvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICAuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuICAgICAgICB9LFxuICAgICAgICBhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICB2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuICAgICAgICAgICAgICAgIG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcbiAgICAgICAgICAgICAgICBkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW0uc3RvcCggdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cbiAgICAgICAgICAgIHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG4gICAgICAgICAgICB2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuICAgICAgICAgICAgICAgIHZhciBzdG9wID0gaG9va3Muc3RvcDtcbiAgICAgICAgICAgICAgICBkZWxldGUgaG9va3Muc3RvcDtcbiAgICAgICAgICAgICAgICBzdG9wKCBnb3RvRW5kICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuICAgICAgICAgICAgICAgIGNsZWFyUXVldWUgPSB0eXBlO1xuICAgICAgICAgICAgICAgIHR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIGNsZWFyUXVldWUgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBkZXF1ZXVlID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuICAgICAgICAgICAgICAgICAgICB0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGluZGV4ICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVxdWV1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG4gICAgICAgICAgICAgICAgLy8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuICAgICAgICAgICAgICAgIC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cbiAgICAgICAgICAgICAgICBpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuICAgICAgICB9LFxuICAgICAgICBmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuICAgICAgICAgICAgaWYgKCB0eXBlICE9PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcbiAgICAgICAgICAgICAgICAgICAgcXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuICAgICAgICAgICAgICAgIC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcbiAgICAgICAgICAgICAgICBkYXRhLmZpbmlzaCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3RcbiAgICAgICAgICAgICAgICBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG4gICAgICAgICAgICAgICAgZm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cbiAgICAgICAgICAgICAgICBmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhLmZpbmlzaDtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG4gICAgICAgIHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuICAgICAgICBqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuICAgICAgICAgICAgICAgIGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuICAgICAgICB9O1xuICAgIH0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xuICAgIGpRdWVyeS5lYWNoKCB7XG4gICAgICAgIHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG4gICAgICAgIHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuICAgICAgICBzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcbiAgICAgICAgZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG4gICAgICAgIGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcbiAgICAgICAgZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbiAgICB9LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG4gICAgICAgIGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG4gICAgICAgIH07XG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LnRpbWVycyA9IFtdO1xuICAgIGpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aW1lcixcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgdGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuICAgICAgICBmeE5vdyA9IERhdGUubm93KCk7XG5cbiAgICAgICAgZm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdGltZXIgPSB0aW1lcnNbIGkgXTtcblxuICAgICAgICAgICAgLy8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuICAgICAgICAgICAgaWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG4gICAgICAgICAgICAgICAgdGltZXJzLnNwbGljZSggaS0tLCAxICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuICAgICAgICAgICAgalF1ZXJ5LmZ4LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBmeE5vdyA9IHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuICAgICAgICBqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG4gICAgICAgIGpRdWVyeS5meC5zdGFydCgpO1xuICAgIH07XG5cbiAgICBqUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbiAgICBqUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCBpblByb2dyZXNzICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgIHNjaGVkdWxlKCk7XG4gICAgfTtcblxuICAgIGpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGluUHJvZ3Jlc3MgPSBudWxsO1xuICAgIH07XG5cbiAgICBqUXVlcnkuZnguc3BlZWRzID0ge1xuICAgICAgICBzbG93OiA2MDAsXG4gICAgICAgIGZhc3Q6IDIwMCxcblxuICAgICAgICAvLyBEZWZhdWx0IHNwZWVkXG4gICAgICAgIF9kZWZhdWx0OiA0MDBcbiAgICB9O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG4gICAgalF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG4gICAgICAgIHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG4gICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuICAgICAgICAgICAgaG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gKTtcbiAgICB9O1xuXG5cbiAgICAoIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcbiAgICAgICAgICAgIHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcbiAgICAgICAgICAgIG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cbiAgICAgICAgaW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG4gICAgICAgIHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAgICAgICAvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuICAgICAgICBzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAgICAgICAvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuICAgICAgICBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuICAgICAgICBpbnB1dC52YWx1ZSA9IFwidFwiO1xuICAgICAgICBpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuICAgICAgICBzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG4gICAgfSApKCk7XG5cblxuICAgIHZhciBib29sSG9vayxcbiAgICAgICAgYXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgICAgIGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbiAgICBqUXVlcnkuZXh0ZW5kKCB7XG4gICAgICAgIGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciByZXQsIGhvb2tzLFxuICAgICAgICAgICAgICAgIG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuICAgICAgICAgICAgLy8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuICAgICAgICAgICAgaWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cbiAgICAgICAgICAgIC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcbiAgICAgICAgICAgIGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcbiAgICAgICAgICAgICAgICAgICAgKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHZhbHVlID09PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgICggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuICAgICAgICAgICAgLy8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcbiAgICAgICAgICAgIHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcbiAgICAgICAgfSxcblxuICAgICAgICBhdHRySG9va3M6IHtcbiAgICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2YWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSxcbiAgICAgICAgICAgICAgICBpID0gMCxcblxuICAgICAgICAgICAgICAgIC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcbiAgICAgICAgICAgICAgICBhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG4gICAgICAgICAgICBpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuICAgICAgICAgICAgICAgIHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuICAgIGJvb2xIb29rID0ge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcbiAgICAgICAgICAgIGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBqUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cbiAgICAgICAgYXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuICAgICAgICAgICAgdmFyIHJldCwgaGFuZGxlLFxuICAgICAgICAgICAgICAgIGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGlmICggIWlzWE1MICkge1xuXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuICAgICAgICAgICAgICAgIGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcbiAgICAgICAgICAgICAgICBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG4gICAgICAgICAgICAgICAgcmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICBsb3dlcmNhc2VOYW1lIDpcbiAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgIH0gKTtcblxuXG5cblxuICAgIHZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcbiAgICAgICAgcmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICAgICAgcHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LmV4dGVuZCgge1xuICAgICAgICBwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG4gICAgICAgICAgICB2YXIgcmV0LCBob29rcyxcbiAgICAgICAgICAgICAgICBuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cbiAgICAgICAgICAgIC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcbiAgICAgICAgICAgIGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuICAgICAgICAgICAgICAgIC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3NcbiAgICAgICAgICAgICAgICBuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgICggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtWyBuYW1lIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJvcEhvb2tzOiB7XG4gICAgICAgICAgICB0YWJJbmRleDoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRhYmluZGV4ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICByY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5ocmVmXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHByb3BGaXg6IHtcbiAgICAgICAgICAgIFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG4gICAgICAgIH1cbiAgICB9ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbiAgICBpZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuICAgICAgICBqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuICAgICAgICAgICAgICAgIC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmICggcGFyZW50ICkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBqUXVlcnkuZWFjaCggW1xuICAgICAgICBcInRhYkluZGV4XCIsXG4gICAgICAgIFwicmVhZE9ubHlcIixcbiAgICAgICAgXCJtYXhMZW5ndGhcIixcbiAgICAgICAgXCJjZWxsU3BhY2luZ1wiLFxuICAgICAgICBcImNlbGxQYWRkaW5nXCIsXG4gICAgICAgIFwicm93U3BhblwiLFxuICAgICAgICBcImNvbFNwYW5cIixcbiAgICAgICAgXCJ1c2VNYXBcIixcbiAgICAgICAgXCJmcmFtZUJvcmRlclwiLFxuICAgICAgICBcImNvbnRlbnRFZGl0YWJsZVwiXG4gICAgXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG4gICAgfSApO1xuXG5cblxuXG4gICAgLy8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuICAgIC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2UtYXNjaWktd2hpdGVzcGFjZVxuICAgIGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuICAgICAgICB2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG4gICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFzc2VzVG9BcnJheSggdmFsdWUgKSB7XG4gICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgICAgIGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG4gICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgIGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG4gICAgICAgICAgICBpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgIHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGN1ciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciArPSBjbGF6eiArIFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgICAgdmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICBpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuICAgICAgICAgICAgaWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuICAgICAgICAgICAgICAgICAgICBjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGN1ciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICB0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLFxuICAgICAgICAgICAgICAgIGlzVmFsaWRWYWx1ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSggdmFsdWUgKTtcblxuICAgICAgICAgICAgaWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIGlzVmFsaWRWYWx1ZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZVZhbFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuICAgICAgICAgICAgICAgIGlmICggaXNWYWxpZFZhbHVlICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBzZWxmID0galF1ZXJ5KCB0aGlzICk7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjbGFzc05hbWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lLCBlbGVtLFxuICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG4gICAgICAgICAgICB3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSApO1xuXG5cblxuXG4gICAgdmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG4gICAgICAgIHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICAgICAgdmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcbiAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1sgMCBdO1xuXG4gICAgICAgICAgICBpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgIGlmICggZWxlbSApIHtcbiAgICAgICAgICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2V0XCIgaW4gaG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gZWxlbS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG4gICAgICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsO1xuXG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuICAgICAgICAgICAgICAgIGlmICggdmFsID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgKz0gXCJcIjtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcbiAgICAgICAgICAgICAgICBpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LmV4dGVuZCgge1xuICAgICAgICB2YWxIb29rczoge1xuICAgICAgICAgICAgb3B0aW9uOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwgIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaW5kZXggPCAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IG1heDtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IG9uZSA/IGluZGV4IDogMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFvcHRpb24uZGlzYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBvbmUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25TZXQsIG9wdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IG9wdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggaS0tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhb3B0aW9uU2V0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG4gICAgalF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuICAgICAgICAgICAgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxuICAgIHN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbiAgICB2YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24oIGUgKSB7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9O1xuXG4gICAgalF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cbiAgICAgICAgICAgIHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuICAgICAgICAgICAgICAgIGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuICAgICAgICAgICAgICAgIHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cbiAgICAgICAgICAgIGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG4gICAgICAgICAgICBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuICAgICAgICAgICAgaWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuICAgICAgICAgICAgICAgIC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcbiAgICAgICAgICAgICAgICB0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMuc29ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG4gICAgICAgICAgICAvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuICAgICAgICAgICAgICAgIGV2ZW50IDpcbiAgICAgICAgICAgICAgICBuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuICAgICAgICAgICAgLy8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuICAgICAgICAgICAgZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG4gICAgICAgICAgICBldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG4gICAgICAgICAgICBldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cbiAgICAgICAgICAgICAgICBuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG4gICAgICAgICAgICAgICAgbnVsbDtcblxuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG4gICAgICAgICAgICBldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoICFldmVudC50YXJnZXQgKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gZWxlbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuICAgICAgICAgICAgZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgWyBldmVudCBdIDpcbiAgICAgICAgICAgICAgICBqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuICAgICAgICAgICAgLy8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG4gICAgICAgICAgICBpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuICAgICAgICAgICAgLy8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcbiAgICAgICAgICAgIGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuICAgICAgICAgICAgICAgIGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuICAgICAgICAgICAgICAgIGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gY3VyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuICAgICAgICAgICAgICAgIGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuICAgICAgICAgICAgICAgICAgICBldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG4gICAgICAgICAgICAgICAgbGFzdEVsZW1lbnQgPSBjdXI7XG4gICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9IGkgPiAxID9cbiAgICAgICAgICAgICAgICAgICAgYnViYmxlVHlwZSA6XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuICAgICAgICAgICAgICAgIC8vIGpRdWVyeSBoYW5kbGVyXG4gICAgICAgICAgICAgICAgaGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKSApWyBldmVudC50eXBlIF0gJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcbiAgICAgICAgICAgICAgICBpZiAoIGhhbmRsZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBOYXRpdmUgaGFuZGxlclxuICAgICAgICAgICAgICAgIGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuICAgICAgICAgICAgICAgIGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnR5cGUgPSB0eXBlO1xuXG4gICAgICAgICAgICAvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG4gICAgICAgICAgICBpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG4gICAgICAgICAgICAgICAgICAgIGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0bXAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgb250eXBlIF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtWyB0eXBlIF0oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdG1wICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bIG9udHlwZSBdID0gdG1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQucmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuICAgICAgICAvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuICAgICAgICBzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuICAgICAgICAgICAgdmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuICAgICAgICAgICAgICAgIG5ldyBqUXVlcnkuRXZlbnQoKSxcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGlzU2ltdWxhdGVkOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcbiAgICAgICAgfVxuXG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzWyAwIF07XG4gICAgICAgICAgICBpZiAoIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9ICk7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG4gICAgaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuICAgICAgICBqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG4gICAgICAgICAgICAvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuICAgICAgICAgICAgICAgIHNldHVwOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGU6IHJlZ3VsYXIgbm9kZXMgKHZpYSBgdGhpcy5vd25lckRvY3VtZW50YCksIHdpbmRvd1xuICAgICAgICAgICAgICAgICAgICAvLyAodmlhIGB0aGlzLmRvY3VtZW50YCkgJiBkb2N1bWVudCAodmlhIGB0aGlzYCkuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhYXR0YWNoZXMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGVhcmRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoICFhdHRhY2hlcyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9ICk7XG4gICAgfVxuICAgIHZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxuICAgIHZhciBub25jZSA9IHsgZ3VpZDogRGF0ZS5ub3coKSB9O1xuXG4gICAgdmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbiAgICBqUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcbiAgICAgICAgdmFyIHhtbCwgcGFyc2VyRXJyb3JFbGVtO1xuICAgICAgICBpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuICAgICAgICAvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG4gICAgICAgIH0gY2F0Y2ggKCBlICkge31cblxuICAgICAgICBwYXJzZXJFcnJvckVsZW0gPSB4bWwgJiYgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKVsgMCBdO1xuICAgICAgICBpZiAoICF4bWwgfHwgcGFyc2VyRXJyb3JFbGVtICkge1xuICAgICAgICAgICAgalF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIChcbiAgICAgICAgICAgICAgICBwYXJzZXJFcnJvckVsZW0gP1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWFwKCBwYXJzZXJFcnJvckVsZW0uY2hpbGROb2RlcywgZnVuY3Rpb24oIGVsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB9ICkuam9pbiggXCJcXG5cIiApIDpcbiAgICAgICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgKSApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4bWw7XG4gICAgfTtcblxuXG4gICAgdmFyXG4gICAgICAgIHJicmFja2V0ID0gL1xcW1xcXSQvLFxuICAgICAgICByQ1JMRiA9IC9cXHI/XFxuL2csXG4gICAgICAgIHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcbiAgICAgICAgcnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG4gICAgZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuICAgICAgICB2YXIgbmFtZTtcblxuICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuXG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cbiAgICAgICAgICAgIGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuICAgICAgICAgICAgICAgIGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuICAgICAgICAgICAgICAgICAgICBhZGQoIHByZWZpeCwgdiApO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cbiAgICAgICAgICAgICAgICAgICAgYnVpbGRQYXJhbXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWRpdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG4gICAgICAgICAgICBmb3IgKCBuYW1lIGluIG9iaiApIHtcbiAgICAgICAgICAgICAgICBidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuICAgICAgICAgICAgYWRkKCBwcmVmaXgsIG9iaiApO1xuICAgICAgICB9XG4gICAgfVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG4gICAgalF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuICAgICAgICB2YXIgcHJlZml4LFxuICAgICAgICAgICAgcyA9IFtdLFxuICAgICAgICAgICAgYWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cbiAgICAgICAgICAgICAgICAgICAgdmFsdWVPckZ1bmN0aW9uKCkgOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZU9yRnVuY3Rpb247XG5cbiAgICAgICAgICAgICAgICBzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmICggYSA9PSBudWxsICkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuICAgICAgICAgICAgalF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcbiAgICAgICAgICAgIC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuICAgICAgICAgICAgZm9yICggcHJlZml4IGluIGEgKSB7XG4gICAgICAgICAgICAgICAgYnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cbiAgICAgICAgcmV0dXJuIHMuam9pbiggXCImXCIgKTtcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuICAgICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuICAgICAgICAgICAgfSApLmZpbHRlciggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3NcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG4gICAgICAgICAgICAgICAgICAgIHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuICAgICAgICAgICAgfSApLm1hcCggZnVuY3Rpb24oIF9pLCBlbGVtICkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuICAgICAgICAgICAgICAgIGlmICggdmFsID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcbiAgICAgICAgICAgIH0gKS5nZXQoKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuXG4gICAgdmFyXG4gICAgICAgIHIyMCA9IC8lMjAvZyxcbiAgICAgICAgcmhhc2ggPSAvIy4qJC8sXG4gICAgICAgIHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG4gICAgICAgIHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuICAgICAgICAvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cbiAgICAgICAgcmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcbiAgICAgICAgcm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG4gICAgICAgIHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuICAgICAgICAvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG4gICAgICAgIHByZWZpbHRlcnMgPSB7fSxcblxuICAgICAgICAvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG4gICAgICAgIHRyYW5zcG9ydHMgPSB7fSxcblxuICAgICAgICAvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cbiAgICAgICAgYWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG4gICAgICAgIC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuICAgICAgICBvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG4gICAgb3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG4gICAgZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cbiAgICAgICAgLy8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuICAgICAgICAgICAgaWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkYXRhVHlwZSxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG4gICAgICAgICAgICBpZiAoIGlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuICAgICAgICAgICAgICAgIC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICB3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgYXBwZW5kXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuICAgIGZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cbiAgICAgICAgdmFyIGluc3BlY3RlZCA9IHt9LFxuICAgICAgICAgICAgc2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQ7XG4gICAgICAgICAgICBpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuICAgICAgICAgICAgalF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgIXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xuICAgIH1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbiAgICBmdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcbiAgICAgICAgdmFyIGtleSwgZGVlcCxcbiAgICAgICAgICAgIGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBmb3IgKCBrZXkgaW4gc3JjICkge1xuICAgICAgICAgICAgaWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgKCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIGRlZXAgKSB7XG4gICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG4gICAgZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuICAgICAgICB2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG4gICAgICAgICAgICBjb250ZW50cyA9IHMuY29udGVudHMsXG4gICAgICAgICAgICBkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuICAgICAgICAvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuICAgICAgICB3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcbiAgICAgICAgICAgIGRhdGFUeXBlcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG4gICAgICAgIGlmICggY3QgKSB7XG4gICAgICAgICAgICBmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuICAgICAgICAgICAgICAgIGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuICAgICAgICBpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcbiAgICAgICAgICAgIGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuICAgICAgICAgICAgZm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbERhdGFUeXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG4gICAgICAgICAgICBmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuICAgICAgICAvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuICAgICAgICAvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gICAgICAgIGlmICggZmluYWxEYXRhVHlwZSApIHtcbiAgICAgICAgICAgIGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG4gICAgZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuICAgICAgICB2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcbiAgICAgICAgICAgIGNvbnZlcnRlcnMgPSB7fSxcblxuICAgICAgICAgICAgLy8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuICAgICAgICAgICAgZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuICAgICAgICAvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcbiAgICAgICAgaWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcbiAgICAgICAgICAgIGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuICAgICAgICAgICAgICAgIGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cbiAgICAgICAgLy8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcbiAgICAgICAgd2hpbGUgKCBjdXJyZW50ICkge1xuXG4gICAgICAgICAgICBpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcbiAgICAgICAgICAgICAgICBqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldiA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIGlmICggY3VycmVudCApIHtcblxuICAgICAgICAgICAgICAgIC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cbiAgICAgICAgICAgICAgICBpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBwcmV2O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG4gICAgICAgICAgICAgICAgICAgIGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWNvbnYgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29udiApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb252ID09PSB0cnVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdG1wWyAwIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29udiAmJiBzLnRocm93cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG4gICAgfVxuXG4gICAgalF1ZXJ5LmV4dGVuZCgge1xuXG4gICAgICAgIC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuICAgICAgICBhY3RpdmU6IDAsXG5cbiAgICAgICAgLy8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuICAgICAgICBsYXN0TW9kaWZpZWQ6IHt9LFxuICAgICAgICBldGFnOiB7fSxcblxuICAgICAgICBhamF4U2V0dGluZ3M6IHtcbiAgICAgICAgICAgIHVybDogbG9jYXRpb24uaHJlZixcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICBpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuICAgICAgICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgICAgICAgcHJvY2Vzc0RhdGE6IHRydWUsXG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG4gICAgICAgICAgICAvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG4gICAgICAgICAgICBhY2NlcHRzOiB7XG4gICAgICAgICAgICAgICAgXCIqXCI6IGFsbFR5cGVzLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwidGV4dC9wbGFpblwiLFxuICAgICAgICAgICAgICAgIGh0bWw6IFwidGV4dC9odG1sXCIsXG4gICAgICAgICAgICAgICAgeG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcbiAgICAgICAgICAgICAgICBqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjb250ZW50czoge1xuICAgICAgICAgICAgICAgIHhtbDogL1xcYnhtbFxcYi8sXG4gICAgICAgICAgICAgICAgaHRtbDogL1xcYmh0bWwvLFxuICAgICAgICAgICAgICAgIGpzb246IC9cXGJqc29uXFxiL1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVzcG9uc2VGaWVsZHM6IHtcbiAgICAgICAgICAgICAgICB4bWw6IFwicmVzcG9uc2VYTUxcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuICAgICAgICAgICAgICAgIGpzb246IFwicmVzcG9uc2VKU09OXCJcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIERhdGEgY29udmVydGVyc1xuICAgICAgICAgICAgLy8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAgICAgY29udmVydGVyczoge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG4gICAgICAgICAgICAgICAgXCIqIHRleHRcIjogU3RyaW5nLFxuXG4gICAgICAgICAgICAgICAgLy8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG4gICAgICAgICAgICAgICAgXCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuICAgICAgICAgICAgICAgIC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICBcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdGV4dCBhcyB4bWxcbiAgICAgICAgICAgICAgICBcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcbiAgICAgICAgICAgIC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcbiAgICAgICAgICAgIC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG4gICAgICAgICAgICAvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcbiAgICAgICAgICAgIGZsYXRPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdXJsOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuICAgICAgICAvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG4gICAgICAgIC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG4gICAgICAgIGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MgP1xuXG4gICAgICAgICAgICAgICAgLy8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICAgICAgICBhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cbiAgICAgICAgICAgICAgICAvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG4gICAgICAgICAgICAgICAgYWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG4gICAgICAgIGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG4gICAgICAgIC8vIE1haW4gbWV0aG9kXG4gICAgICAgIGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cbiAgICAgICAgICAgIC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHVybDtcbiAgICAgICAgICAgICAgICB1cmwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAgICAgdmFyIHRyYW5zcG9ydCxcblxuICAgICAgICAgICAgICAgIC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cbiAgICAgICAgICAgICAgICBjYWNoZVVSTCxcblxuICAgICAgICAgICAgICAgIC8vIFJlc3BvbnNlIGhlYWRlcnNcbiAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNTdHJpbmcsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuXG4gICAgICAgICAgICAgICAgLy8gdGltZW91dCBoYW5kbGVcbiAgICAgICAgICAgICAgICB0aW1lb3V0VGltZXIsXG5cbiAgICAgICAgICAgICAgICAvLyBVcmwgY2xlYW51cCB2YXJcbiAgICAgICAgICAgICAgICB1cmxBbmNob3IsXG5cbiAgICAgICAgICAgICAgICAvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG4gICAgICAgICAgICAgICAgY29tcGxldGVkLFxuXG4gICAgICAgICAgICAgICAgLy8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG4gICAgICAgICAgICAgICAgZmlyZUdsb2JhbHMsXG5cbiAgICAgICAgICAgICAgICAvLyBMb29wIHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgaSxcblxuICAgICAgICAgICAgICAgIC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuICAgICAgICAgICAgICAgIHVuY2FjaGVkLFxuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuICAgICAgICAgICAgICAgIHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG4gICAgICAgICAgICAgICAgLy8gQ2FsbGJhY2tzIGNvbnRleHRcbiAgICAgICAgICAgICAgICBjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuICAgICAgICAgICAgICAgIC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcbiAgICAgICAgICAgICAgICAoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LFxuXG4gICAgICAgICAgICAgICAgLy8gRGVmZXJyZWRzXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cbiAgICAgICAgICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cbiAgICAgICAgICAgICAgICAvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzID0ge30sXG4gICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgc3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cbiAgICAgICAgICAgICAgICAvLyBGYWtlIHhoclxuICAgICAgICAgICAgICAgIGpxWEhSID0ge1xuICAgICAgICAgICAgICAgICAgICByZWFkeVN0YXRlOiAwLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgZ2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvbXBsZXRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSB8fCBbXSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQoIG1hdGNoWyAyIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2guam9pbiggXCIsIFwiICk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmF3IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICBnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGVzIHRoZSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgc2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLm1pbWVUeXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbWFwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29tcGxldGVkICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGNvZGUgaW4gbWFwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBDYW5jZWwgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHRyYW5zcG9ydCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSggMCwgZmluYWxUZXh0ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaCBkZWZlcnJlZHNcbiAgICAgICAgICAgIGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuICAgICAgICAgICAgLy8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcbiAgICAgICAgICAgIC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgcy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cbiAgICAgICAgICAgIC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuICAgICAgICAgICAgcy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuICAgICAgICAgICAgcy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cbiAgICAgICAgICAgIC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuICAgICAgICAgICAgaWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgdXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcbiAgICAgICAgICAgICAgICAvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuICAgICAgICAgICAgICAgIC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgLy8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgdXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcbiAgICAgICAgICAgICAgICAgICAgcy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcbiAgICAgICAgICAgICAgICAgICAgcy5jcm9zc0RvbWFpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcbiAgICAgICAgICAgIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICBzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcHBseSBwcmVmaWx0ZXJzXG4gICAgICAgICAgICBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuICAgICAgICAgICAgLy8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcbiAgICAgICAgICAgIGlmICggY29tcGxldGVkICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqcVhIUjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cbiAgICAgICAgICAgIC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG4gICAgICAgICAgICBmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuICAgICAgICAgICAgLy8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuICAgICAgICAgICAgaWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBwZXJjYXNlIHRoZSB0eXBlXG4gICAgICAgICAgICBzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcbiAgICAgICAgICAgIHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2VcbiAgICAgICAgICAgIC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuICAgICAgICAgICAgLy8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuICAgICAgICAgICAgY2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG4gICAgICAgICAgICAvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuICAgICAgICAgICAgaWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG4gICAgICAgICAgICAgICAgdW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG4gICAgICAgICAgICAgICAgaWYgKCBzLmRhdGEgJiYgKCBzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuICAgICAgICAgICAgICAgICAgICAvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzLmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG4gICAgICAgICAgICAgICAgICAgIHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UuZ3VpZCsrICkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5jYWNoZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuICAgICAgICAgICAgICAgIHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuICAgICAgICAgICAgfSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcbiAgICAgICAgICAgICAgICAoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICBzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuICAgICAgICAgICAgaWYgKCBzLmlmTW9kaWZpZWQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuICAgICAgICAgICAgICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcbiAgICAgICAgICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcbiAgICAgICAgICAgIGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuICAgICAgICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlcihcbiAgICAgICAgICAgICAgICBcIkFjY2VwdFwiLFxuICAgICAgICAgICAgICAgIHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuICAgICAgICAgICAgICAgICAgICBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG4gICAgICAgICAgICAgICAgICAgICggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG4gICAgICAgICAgICAgICAgICAgIHMuYWNjZXB0c1sgXCIqXCIgXVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG4gICAgICAgICAgICBmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcbiAgICAgICAgICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG4gICAgICAgICAgICBpZiAoIHMuYmVmb3JlU2VuZCAmJlxuICAgICAgICAgICAgICAgICggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4ganFYSFIuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG4gICAgICAgICAgICBzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuICAgICAgICAgICAgLy8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG4gICAgICAgICAgICBjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuICAgICAgICAgICAganFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG4gICAgICAgICAgICBqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cbiAgICAgICAgICAgIC8vIEdldCB0cmFuc3BvcnRcbiAgICAgICAgICAgIHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG4gICAgICAgICAgICAvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcbiAgICAgICAgICAgIGlmICggIXRyYW5zcG9ydCApIHtcbiAgICAgICAgICAgICAgICBkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuICAgICAgICAgICAgICAgIC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKCBmaXJlR2xvYmFscyApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcbiAgICAgICAgICAgICAgICBpZiAoIGNvbXBsZXRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpxWEhSO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRpbWVvdXRcbiAgICAgICAgICAgICAgICBpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAganFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHMudGltZW91dCApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICggZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGlmICggY29tcGxldGVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICBkb25lKCAtMSwgZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG4gICAgICAgICAgICBmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAoIGNvbXBsZXRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmICggdGltZW91dFRpbWVyICkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuICAgICAgICAgICAgICAgIC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuICAgICAgICAgICAgICAgIC8vIFNldCByZWFkeVN0YXRlXG4gICAgICAgICAgICAgICAganFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG4gICAgICAgICAgICAgICAgaXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgcmVzcG9uc2UgZGF0YVxuICAgICAgICAgICAgICAgIGlmICggcmVzcG9uc2VzICkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgYSBub29wIGNvbnZlcnRlciBmb3IgbWlzc2luZyBzY3JpcHQgYnV0IG5vdCBpZiBqc29ucFxuICAgICAgICAgICAgICAgIGlmICggIWlzU3VjY2VzcyAmJlxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuaW5BcnJheSggXCJzY3JpcHRcIiwgcy5kYXRhVHlwZXMgKSA+IC0xICYmXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5pbkFycmF5KCBcImpzb25cIiwgcy5kYXRhVHlwZXMgKSA8IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHMuY29udmVydGVyc1sgXCJ0ZXh0IHNjcmlwdFwiIF0gPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcbiAgICAgICAgICAgICAgICBpZiAoIGlzU3VjY2VzcyApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIHMuaWZNb2RpZmllZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1vZGlmaWVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIG1vZGlmaWVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBubyBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgbW9kaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3VjY2VzcyA9ICFlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHN0YXR1c1RleHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3RhdHVzIDwgMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3RcbiAgICAgICAgICAgICAgICBqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICAgICAganFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VjY2Vzcy9FcnJvclxuICAgICAgICAgICAgICAgIGlmICggaXNTdWNjZXNzICkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBmaXJlR2xvYmFscyApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENvbXBsZXRlXG4gICAgICAgICAgICAgICAgY29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuICAgICAgICAgICAgICAgIGlmICggZmlyZUdsb2JhbHMgKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGpxWEhSO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBfaSwgbWV0aG9kICkge1xuICAgICAgICBqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cbiAgICAgICAgICAgIC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG4gICAgICAgICAgICBpZiAoIGlzRnVuY3Rpb24oIGRhdGEgKSApIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICB0eXBlOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBjYWxsYmFja1xuICAgICAgICAgICAgfSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG4gICAgICAgIH07XG4gICAgfSApO1xuXG4gICAgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG4gICAgICAgICAgICBpZiAoIGkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIiApIHtcbiAgICAgICAgICAgICAgICBzLmNvbnRlbnRUeXBlID0gcy5oZWFkZXJzWyBpIF0gfHwgXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gKTtcblxuXG4gICAgalF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCwgb3B0aW9ucywgZG9jICkge1xuICAgICAgICByZXR1cm4galF1ZXJ5LmFqYXgoIHtcbiAgICAgICAgICAgIHVybDogdXJsLFxuXG4gICAgICAgICAgICAvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJzY3JpcHRcIixcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgICAgICAgZ2xvYmFsOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gT25seSBldmFsdWF0ZSB0aGUgcmVzcG9uc2UgaWYgaXQgaXMgc3VjY2Vzc2Z1bCAoZ2gtNDEyNilcbiAgICAgICAgICAgIC8vIGRhdGFGaWx0ZXIgaXMgbm90IGludm9rZWQgZm9yIGZhaWx1cmUgcmVzcG9uc2VzLCBzbyB1c2luZyBpdCBpbnN0ZWFkXG4gICAgICAgICAgICAvLyBvZiB0aGUgZGVmYXVsdCBjb252ZXJ0ZXIgaXMga2x1ZGd5IGJ1dCBpdCB3b3Jrcy5cbiAgICAgICAgICAgIGNvbnZlcnRlcnM6IHtcbiAgICAgICAgICAgICAgICBcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCkge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhRmlsdGVyOiBmdW5jdGlvbiggcmVzcG9uc2UgKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5Lmdsb2JhbEV2YWwoIHJlc3BvbnNlLCBvcHRpb25zLCBkb2MgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSApO1xuICAgIH07XG5cblxuICAgIGpRdWVyeS5mbi5leHRlbmQoIHtcbiAgICAgICAgd3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG4gICAgICAgICAgICB2YXIgd3JhcDtcblxuICAgICAgICAgICAgaWYgKCB0aGlzWyAwIF0gKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG4gICAgICAgICAgICAgICAgd3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuICAgICAgICAgICAgICAgICAgICB3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgICAgICAgICB9ICkuYXBwZW5kKCB0aGlzICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG4gICAgICAgICAgICBpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHBlbmQoIGh0bWwgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG4gICAgICAgICAgICB2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cblxuICAgIGpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG4gICAgfTtcbiAgICBqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgICAgICAgcmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbiAgICB9O1xuXG5cblxuXG4gICAgalF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIH0gY2F0Y2ggKCBlICkge31cbiAgICB9O1xuXG4gICAgdmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cbiAgICAgICAgICAgIC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG4gICAgICAgICAgICAwOiAyMDAsXG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgICAgICAgICAvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcbiAgICAgICAgICAgIDEyMjM6IDIwNFxuICAgICAgICB9LFxuICAgICAgICB4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG4gICAgc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuICAgIHN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG4gICAgalF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuICAgICAgICB2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cbiAgICAgICAgLy8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuICAgICAgICBpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIgPSBvcHRpb25zLnhocigpO1xuXG4gICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmFzeW5jLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFzc3dvcmRcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgICAgIGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgaW4gaGVhZGVycyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1c1RleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1c1RleHQsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTGlzdGVuIHRvIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICB4aHIub25sb2FkID0gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICggZSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbiAgICBqUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG4gICAgICAgIGlmICggcy5jcm9zc0RvbWFpbiApIHtcbiAgICAgICAgICAgIHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG4gICAgalF1ZXJ5LmFqYXhTZXR1cCgge1xuICAgICAgICBhY2NlcHRzOiB7XG4gICAgICAgICAgICBzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG4gICAgICAgICAgICAgICAgXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuICAgICAgICB9LFxuICAgICAgICBjb250ZW50czoge1xuICAgICAgICAgICAgc2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cbiAgICAgICAgfSxcbiAgICAgICAgY29udmVydGVyczoge1xuICAgICAgICAgICAgXCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG4gICAgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuICAgICAgICBpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIHMuY2FjaGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG4gICAgICAgICAgICBzLnR5cGUgPSBcIkdFVFwiO1xuICAgICAgICB9XG4gICAgfSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbiAgICBqUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cbiAgICAgICAgLy8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiBvciBmb3JjZWQtYnktYXR0cnMgcmVxdWVzdHNcbiAgICAgICAgaWYgKCBzLmNyb3NzRG9tYWluIHx8IHMuc2NyaXB0QXR0cnMgKSB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0LCBjYWxsYmFjaztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0ciggcy5zY3JpcHRBdHRycyB8fCB7fSApXG4gICAgICAgICAgICAgICAgICAgICAgICAucHJvcCggeyBjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsIHNyYzogcy51cmwgfSApXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oIFwibG9hZCBlcnJvclwiLCBjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGV2dCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9ICk7XG5cblxuXG5cbiAgICB2YXIgb2xkQ2FsbGJhY2tzID0gW10sXG4gICAgICAgIHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbiAgICBqUXVlcnkuYWpheFNldHVwKCB7XG4gICAgICAgIGpzb25wOiBcImNhbGxiYWNrXCIsXG4gICAgICAgIGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UuZ3VpZCsrICkgKTtcbiAgICAgICAgICAgIHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgfSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbiAgICBqUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuICAgICAgICB2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG4gICAgICAgICAgICBqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuICAgICAgICAgICAgICAgICAgICBcInVybFwiIDpcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgICAgICAoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG4gICAgICAgICAgICAgICAgICAgICAgICAuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG4gICAgICAgIGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG4gICAgICAgICAgICAvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG4gICAgICAgICAgICBjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG4gICAgICAgICAgICAgICAgcy5qc29ucENhbGxiYWNrKCkgOlxuICAgICAgICAgICAgICAgIHMuanNvbnBDYWxsYmFjaztcblxuICAgICAgICAgICAgLy8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuICAgICAgICAgICAgaWYgKCBqc29uUHJvcCApIHtcbiAgICAgICAgICAgICAgICBzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgcy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuICAgICAgICAgICAgcy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG4gICAgICAgICAgICBzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cbiAgICAgICAgICAgIC8vIEluc3RhbGwgY2FsbGJhY2tcbiAgICAgICAgICAgIG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcbiAgICAgICAgICAgIHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuICAgICAgICAgICAganFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuICAgICAgICAgICAgICAgIGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTYXZlIGJhY2sgYXMgZnJlZVxuICAgICAgICAgICAgICAgIGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG4gICAgICAgICAgICAgICAgICAgIHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG4gICAgICAgICAgICAgICAgICAgIG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICBpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgLy8gRGVsZWdhdGUgdG8gc2NyaXB0XG4gICAgICAgICAgICByZXR1cm4gXCJzY3JpcHRcIjtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG4gICAgc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG4gICAgICAgIGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuICAgICAgICByZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbiAgICB9ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG4gICAgalF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcbiAgICAgICAgaWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcbiAgICAgICAgICAgIGtlZXBTY3JpcHRzID0gY29udGV4dDtcbiAgICAgICAgICAgIGNvbnRleHQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cbiAgICAgICAgaWYgKCAhY29udGV4dCApIHtcblxuICAgICAgICAgICAgLy8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgaWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuICAgICAgICAgICAgICAgIC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG4gICAgICAgICAgICAgICAgYmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcbiAgICAgICAgICAgICAgICBiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcbiAgICAgICAgc2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuICAgICAgICAvLyBTaW5nbGUgdGFnXG4gICAgICAgIGlmICggcGFyc2VkICkge1xuICAgICAgICAgICAgcmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG4gICAgICAgIGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcbiAgICAgICAgICAgIGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICAgICAqL1xuICAgIGpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgb2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cbiAgICAgICAgaWYgKCBvZmYgPiAtMSApIHtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuICAgICAgICAgICAgdXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0J3MgYSBmdW5jdGlvblxuICAgICAgICBpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG4gICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICAgICAgICBwYXJhbXMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcbiAgICAgICAgfSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG4gICAgICAgICAgICB0eXBlID0gXCJQT1NUXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuICAgICAgICBpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgIGpRdWVyeS5hamF4KCB7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG5cbiAgICAgICAgICAgICAgICAvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuICAgICAgICAgICAgICAgIC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuICAgICAgICAgICAgICAgIC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJodG1sXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogcGFyYW1zXG4gICAgICAgICAgICB9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuICAgICAgICAgICAgICAgIC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5odG1sKCBzZWxlY3RvciA/XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVRleHQgKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cbiAgICAgICAgICAgICAgICAvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG4gICAgICAgICAgICB9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cblxuXG5cbiAgICBqUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG4gICAgICAgIH0gKS5sZW5ndGg7XG4gICAgfTtcblxuXG5cblxuICAgIGpRdWVyeS5vZmZzZXQgPSB7XG4gICAgICAgIHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG4gICAgICAgICAgICB2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG4gICAgICAgICAgICAgICAgY3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuICAgICAgICAgICAgICAgIHByb3BzID0ge307XG5cbiAgICAgICAgICAgIC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cbiAgICAgICAgICAgIGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcbiAgICAgICAgICAgIGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcbiAgICAgICAgICAgIGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuICAgICAgICAgICAgY2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG4gICAgICAgICAgICAgICAgKCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG4gICAgICAgICAgICAvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuICAgICAgICAgICAgLy8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG4gICAgICAgICAgICBpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuICAgICAgICAgICAgICAgIGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcbiAgICAgICAgICAgICAgICBjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuICAgICAgICAgICAgICAgIGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBpc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuICAgICAgICAgICAgICAgIHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuICAgICAgICAgICAgICAgIHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJFbGVtLmNzcyggcHJvcHMgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKCB7XG5cbiAgICAgICAgLy8gb2Zmc2V0KCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgYm9yZGVyIGJveCB0byB0aGUgZG9jdW1lbnQgb3JpZ2luXG4gICAgICAgIG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcbiAgICAgICAgICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcyA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZWN0LCB3aW4sXG4gICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbIDAgXTtcblxuICAgICAgICAgICAgaWYgKCAhZWxlbSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4gICAgICAgICAgICAvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG4gICAgICAgICAgICAvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3JcbiAgICAgICAgICAgIGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1JcbiAgICAgICAgICAgIHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgd2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0LFxuICAgICAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxuICAgICAgICAvLyBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBiZWhhdmlvciBvZiBDU1MgYWJzb2x1dGUgcG9zaXRpb25pbmdcbiAgICAgICAgcG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCAhdGhpc1sgMCBdICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXG4gICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbIDAgXSxcbiAgICAgICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG4gICAgICAgICAgICAvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuICAgICAgICAgICAgaWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG4gICAgICAgICAgICAgICAgLy8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuICAgICAgICAgICAgICAgIC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcbiAgICAgICAgICAgICAgICBkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuICAgICAgICAgICAgICAgICggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxuICAgICAgICAgICAgICAgIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG4gICAgICAgICAgICAgICAgbGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgICAgIC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cbiAgICAgICAgLy8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG4gICAgICAgIC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcbiAgICAgICAgLy8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuICAgICAgICAvL1xuICAgICAgICAvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcbiAgICAgICAgLy8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG4gICAgICAgIG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuICAgICAgICAgICAgICAgIHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xuICAgIGpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcbiAgICAgICAgdmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuICAgICAgICBqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblxuICAgICAgICAgICAgICAgIC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuICAgICAgICAgICAgICAgIHZhciB3aW47XG4gICAgICAgICAgICAgICAgaWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuICAgICAgICAgICAgICAgICAgICB3aW4gPSBlbGVtO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCB3aW4gKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbi5zY3JvbGxUbyhcbiAgICAgICAgICAgICAgICAgICAgICAgICF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG4gICAgICAgIH07XG4gICAgfSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG4gICAgalF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIF9pLCBwcm9wICkge1xuICAgICAgICBqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuICAgICAgICAgICAgZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuICAgICAgICAgICAgICAgIGlmICggY29tcHV0ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbiAgICBqUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG4gICAgICAgIGpRdWVyeS5lYWNoKCB7XG4gICAgICAgICAgICBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLFxuICAgICAgICAgICAgY29udGVudDogdHlwZSxcbiAgICAgICAgICAgIFwiXCI6IFwib3V0ZXJcIiArIG5hbWVcbiAgICAgICAgfSwgZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cbiAgICAgICAgICAgIC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuICAgICAgICAgICAgalF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG4gICAgICAgICAgICAgICAgfSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gKTtcbiAgICB9ICk7XG5cblxuICAgIGpRdWVyeS5lYWNoKCBbXG4gICAgICAgIFwiYWpheFN0YXJ0XCIsXG4gICAgICAgIFwiYWpheFN0b3BcIixcbiAgICAgICAgXCJhamF4Q29tcGxldGVcIixcbiAgICAgICAgXCJhamF4RXJyb3JcIixcbiAgICAgICAgXCJhamF4U3VjY2Vzc1wiLFxuICAgICAgICBcImFqYXhTZW5kXCJcbiAgICBdLCBmdW5jdGlvbiggX2ksIHR5cGUgKSB7XG4gICAgICAgIGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG4gICAgICAgIH07XG4gICAgfSApO1xuXG5cblxuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCgge1xuXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cbiAgICAgICAgICAgIC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cbiAgICAgICAgICAgICAgICB0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcbiAgICAgICAgICAgICAgICB0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcbiAgICAgICAgfSxcblxuICAgICAgICBob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGpRdWVyeS5lYWNoKFxuICAgICAgICAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuICAgICAgICAgICAgXCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG4gICAgICAgICAgICBcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuICAgICAgICBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG4gICAgICAgICAgICBqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCBuYW1lICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgKTtcblxuXG5cblxuLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG4vLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1BcbiAgICB2YXIgcnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbi8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuLy8gYXJndW1lbnRzLlxuLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxuLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG4gICAgalF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuICAgICAgICB2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuICAgICAgICBpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgdG1wID0gZm5bIGNvbnRleHQgXTtcbiAgICAgICAgICAgIGNvbnRleHQgPSBmbjtcbiAgICAgICAgICAgIGZuID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcbiAgICAgICAgLy8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICAgICAgaWYgKCAhaXNGdW5jdGlvbiggZm4gKSApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW11bGF0ZWQgYmluZFxuICAgICAgICBhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG4gICAgICAgIHByb3h5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcbiAgICAgICAgcHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cbiAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgIH07XG5cbiAgICBqUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XG4gICAgICAgIGlmICggaG9sZCApIHtcbiAgICAgICAgICAgIGpRdWVyeS5yZWFkeVdhaXQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBqUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gICAgalF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG4gICAgalF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG4gICAgalF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIGpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xuICAgIGpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG4gICAgalF1ZXJ5LnR5cGUgPSB0b1R5cGU7XG5cbiAgICBqUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbiAgICBqUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcblxuICAgICAgICAvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuICAgICAgICAvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG4gICAgICAgIC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG4gICAgICAgIHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuICAgICAgICByZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG4gICAgICAgICAgICAvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcbiAgICAgICAgICAgIC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcbiAgICAgICAgICAgIC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuICAgICAgICAgICAgIWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xuICAgIH07XG5cbiAgICBqUXVlcnkudHJpbSA9IGZ1bmN0aW9uKCB0ZXh0ICkge1xuICAgICAgICByZXR1cm4gdGV4dCA9PSBudWxsID9cbiAgICAgICAgICAgIFwiXCIgOlxuICAgICAgICAgICAgKCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG4gICAgfTtcblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuICAgIGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG4gICAgICAgIGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeTtcbiAgICAgICAgfSApO1xuICAgIH1cblxuXG5cblxuICAgIHZhclxuXG4gICAgICAgIC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgICAgICBfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuICAgICAgICAvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgICAgICBfJCA9IHdpbmRvdy4kO1xuXG4gICAgalF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcbiAgICAgICAgaWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuICAgICAgICAgICAgd2luZG93LiQgPSBfJDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG4gICAgICAgICAgICB3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqUXVlcnk7XG4gICAgfTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbiAgICBpZiAoIHR5cGVvZiBub0dsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiApIHtcbiAgICAgICAgd2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xuICAgIH1cblxuXG5cblxuICAgIHJldHVybiBqUXVlcnk7XG59ICk7XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsIm1vZHVsZSIsImV4cG9ydHMiLCJkb2N1bWVudCIsInciLCJFcnJvciIsIndpbmRvdyIsIm5vR2xvYmFsIiwiYXJyIiwiZ2V0UHJvdG8iLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsInNsaWNlIiwiZmxhdCIsImFycmF5IiwiY2FsbCIsImNvbmNhdCIsImFwcGx5IiwicHVzaCIsImluZGV4T2YiLCJjbGFzczJ0eXBlIiwidG9TdHJpbmciLCJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsImZuVG9TdHJpbmciLCJPYmplY3RGdW5jdGlvblN0cmluZyIsInN1cHBvcnQiLCJpc0Z1bmN0aW9uIiwib2JqIiwibm9kZVR5cGUiLCJpdGVtIiwiaXNXaW5kb3ciLCJwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzIiwidHlwZSIsInNyYyIsIm5vbmNlIiwibm9Nb2R1bGUiLCJET01FdmFsIiwiY29kZSIsIm5vZGUiLCJkb2MiLCJpIiwidmFsIiwic2NyaXB0IiwiY3JlYXRlRWxlbWVudCIsInRleHQiLCJnZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJ0b1R5cGUiLCJ2ZXJzaW9uIiwialF1ZXJ5Iiwic2VsZWN0b3IiLCJjb250ZXh0IiwiZm4iLCJpbml0IiwicHJvdG90eXBlIiwianF1ZXJ5IiwiY29uc3RydWN0b3IiLCJsZW5ndGgiLCJ0b0FycmF5IiwiZ2V0IiwibnVtIiwicHVzaFN0YWNrIiwiZWxlbXMiLCJyZXQiLCJtZXJnZSIsInByZXZPYmplY3QiLCJlYWNoIiwiY2FsbGJhY2siLCJtYXAiLCJlbGVtIiwiYXJndW1lbnRzIiwiZmlyc3QiLCJlcSIsImxhc3QiLCJldmVuIiwiZ3JlcCIsIl9lbGVtIiwib2RkIiwibGVuIiwiaiIsImVuZCIsInNvcnQiLCJzcGxpY2UiLCJleHRlbmQiLCJvcHRpb25zIiwibmFtZSIsImNvcHkiLCJjb3B5SXNBcnJheSIsImNsb25lIiwidGFyZ2V0IiwiZGVlcCIsImlzUGxhaW5PYmplY3QiLCJBcnJheSIsImlzQXJyYXkiLCJ1bmRlZmluZWQiLCJleHBhbmRvIiwiTWF0aCIsInJhbmRvbSIsInJlcGxhY2UiLCJpc1JlYWR5IiwiZXJyb3IiLCJtc2ciLCJub29wIiwicHJvdG8iLCJDdG9yIiwiaXNFbXB0eU9iamVjdCIsImdsb2JhbEV2YWwiLCJpc0FycmF5TGlrZSIsIm1ha2VBcnJheSIsInJlc3VsdHMiLCJpbkFycmF5Iiwic2Vjb25kIiwiaW52ZXJ0IiwiY2FsbGJhY2tJbnZlcnNlIiwibWF0Y2hlcyIsImNhbGxiYWNrRXhwZWN0IiwiYXJnIiwidmFsdWUiLCJndWlkIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJzcGxpdCIsIl9pIiwidG9Mb3dlckNhc2UiLCJTaXp6bGUiLCJFeHByIiwiZ2V0VGV4dCIsImlzWE1MIiwidG9rZW5pemUiLCJjb21waWxlIiwic2VsZWN0Iiwib3V0ZXJtb3N0Q29udGV4dCIsInNvcnRJbnB1dCIsImhhc0R1cGxpY2F0ZSIsInNldERvY3VtZW50IiwiZG9jRWxlbSIsImRvY3VtZW50SXNIVE1MIiwicmJ1Z2d5UVNBIiwicmJ1Z2d5TWF0Y2hlcyIsImNvbnRhaW5zIiwiRGF0ZSIsInByZWZlcnJlZERvYyIsImRpcnJ1bnMiLCJkb25lIiwiY2xhc3NDYWNoZSIsImNyZWF0ZUNhY2hlIiwidG9rZW5DYWNoZSIsImNvbXBpbGVyQ2FjaGUiLCJub25uYXRpdmVTZWxlY3RvckNhY2hlIiwic29ydE9yZGVyIiwiYSIsImIiLCJwb3AiLCJwdXNoTmF0aXZlIiwibGlzdCIsImJvb2xlYW5zIiwid2hpdGVzcGFjZSIsImlkZW50aWZpZXIiLCJhdHRyaWJ1dGVzIiwicHNldWRvcyIsInJ3aGl0ZXNwYWNlIiwiUmVnRXhwIiwicnRyaW0iLCJyY29tbWEiLCJyY29tYmluYXRvcnMiLCJyZGVzY2VuZCIsInJwc2V1ZG8iLCJyaWRlbnRpZmllciIsIm1hdGNoRXhwciIsInJodG1sIiwicmlucHV0cyIsInJoZWFkZXIiLCJybmF0aXZlIiwicnF1aWNrRXhwciIsInJzaWJsaW5nIiwicnVuZXNjYXBlIiwiZnVuZXNjYXBlIiwiZXNjYXBlIiwibm9uSGV4IiwiaGlnaCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInJjc3Nlc2NhcGUiLCJmY3NzZXNjYXBlIiwiY2giLCJhc0NvZGVQb2ludCIsImNoYXJDb2RlQXQiLCJ1bmxvYWRIYW5kbGVyIiwiaW5EaXNhYmxlZEZpZWxkc2V0IiwiYWRkQ29tYmluYXRvciIsImRpc2FibGVkIiwibm9kZU5hbWUiLCJkaXIiLCJuZXh0IiwiY2hpbGROb2RlcyIsImUiLCJlbHMiLCJzZWVkIiwibSIsIm5pZCIsIm1hdGNoIiwiZ3JvdXBzIiwibmV3U2VsZWN0b3IiLCJuZXdDb250ZXh0Iiwib3duZXJEb2N1bWVudCIsImV4ZWMiLCJnZXRFbGVtZW50QnlJZCIsImlkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwicXNhIiwidGVzdCIsInRlc3RDb250ZXh0Iiwic2NvcGUiLCJ0b1NlbGVjdG9yIiwiam9pbiIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJxc2FFcnJvciIsInJlbW92ZUF0dHJpYnV0ZSIsImtleXMiLCJjYWNoZSIsImtleSIsImNhY2hlTGVuZ3RoIiwic2hpZnQiLCJtYXJrRnVuY3Rpb24iLCJhc3NlcnQiLCJlbCIsImFkZEhhbmRsZSIsImF0dHJzIiwiaGFuZGxlciIsImF0dHJIYW5kbGUiLCJzaWJsaW5nQ2hlY2siLCJjdXIiLCJkaWZmIiwic291cmNlSW5kZXgiLCJuZXh0U2libGluZyIsImNyZWF0ZUlucHV0UHNldWRvIiwiY3JlYXRlQnV0dG9uUHNldWRvIiwiY3JlYXRlRGlzYWJsZWRQc2V1ZG8iLCJpc0Rpc2FibGVkIiwiY3JlYXRlUG9zaXRpb25hbFBzZXVkbyIsImFyZ3VtZW50IiwibWF0Y2hJbmRleGVzIiwibmFtZXNwYWNlIiwibmFtZXNwYWNlVVJJIiwiZG9jdW1lbnRFbGVtZW50IiwiaGFzQ29tcGFyZSIsInN1YldpbmRvdyIsImRlZmF1bHRWaWV3IiwidG9wIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiY2xhc3NOYW1lIiwiY3JlYXRlQ29tbWVudCIsImdldEJ5SWQiLCJnZXRFbGVtZW50c0J5TmFtZSIsImZpbHRlciIsImF0dHJJZCIsImZpbmQiLCJnZXRBdHRyaWJ1dGVOb2RlIiwidGFnIiwidG1wIiwiaW5wdXQiLCJpbm5lckhUTUwiLCJtYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJkaXNjb25uZWN0ZWRNYXRjaCIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiYWRvd24iLCJidXAiLCJjb21wYXJlIiwic29ydERldGFjaGVkIiwiYXVwIiwiYXAiLCJicCIsInVuc2hpZnQiLCJleHByIiwiZWxlbWVudHMiLCJhdHRyIiwic3BlY2lmaWVkIiwic2VsIiwidW5pcXVlU29ydCIsImR1cGxpY2F0ZXMiLCJkZXRlY3REdXBsaWNhdGVzIiwic29ydFN0YWJsZSIsInRleHRDb250ZW50IiwiZmlyc3RDaGlsZCIsIm5vZGVWYWx1ZSIsInNlbGVjdG9ycyIsImNyZWF0ZVBzZXVkbyIsInJlbGF0aXZlIiwicHJlRmlsdGVyIiwiZXhjZXNzIiwidW5xdW90ZWQiLCJub2RlTmFtZVNlbGVjdG9yIiwicGF0dGVybiIsIm9wZXJhdG9yIiwiY2hlY2siLCJyZXN1bHQiLCJ3aGF0IiwiX2FyZ3VtZW50Iiwic2ltcGxlIiwiZm9yd2FyZCIsIm9mVHlwZSIsIl9jb250ZXh0IiwieG1sIiwidW5pcXVlQ2FjaGUiLCJvdXRlckNhY2hlIiwibm9kZUluZGV4Iiwic3RhcnQiLCJwYXJlbnQiLCJ1c2VDYWNoZSIsImxhc3RDaGlsZCIsInVuaXF1ZUlEIiwicHNldWRvIiwiYXJncyIsInNldEZpbHRlcnMiLCJpZHgiLCJtYXRjaGVkIiwibWF0Y2hlciIsInVubWF0Y2hlZCIsImxhbmciLCJlbGVtTGFuZyIsImhhc2giLCJsb2NhdGlvbiIsImFjdGl2ZUVsZW1lbnQiLCJoYXNGb2N1cyIsImhyZWYiLCJ0YWJJbmRleCIsImNoZWNrZWQiLCJzZWxlY3RlZCIsInNlbGVjdGVkSW5kZXgiLCJfbWF0Y2hJbmRleGVzIiwicmFkaW8iLCJjaGVja2JveCIsImZpbGUiLCJwYXNzd29yZCIsImltYWdlIiwic3VibWl0IiwicmVzZXQiLCJmaWx0ZXJzIiwicGFyc2VPbmx5IiwidG9rZW5zIiwic29GYXIiLCJwcmVGaWx0ZXJzIiwiY2FjaGVkIiwiY29tYmluYXRvciIsImJhc2UiLCJza2lwIiwiY2hlY2tOb25FbGVtZW50cyIsImRvbmVOYW1lIiwib2xkQ2FjaGUiLCJuZXdDYWNoZSIsImVsZW1lbnRNYXRjaGVyIiwibWF0Y2hlcnMiLCJtdWx0aXBsZUNvbnRleHRzIiwiY29udGV4dHMiLCJjb25kZW5zZSIsIm5ld1VubWF0Y2hlZCIsIm1hcHBlZCIsInNldE1hdGNoZXIiLCJwb3N0RmlsdGVyIiwicG9zdEZpbmRlciIsInBvc3RTZWxlY3RvciIsInRlbXAiLCJwcmVNYXAiLCJwb3N0TWFwIiwicHJlZXhpc3RpbmciLCJtYXRjaGVySW4iLCJtYXRjaGVyT3V0IiwibWF0Y2hlckZyb21Ub2tlbnMiLCJjaGVja0NvbnRleHQiLCJsZWFkaW5nUmVsYXRpdmUiLCJpbXBsaWNpdFJlbGF0aXZlIiwibWF0Y2hDb250ZXh0IiwibWF0Y2hBbnlDb250ZXh0IiwibWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzIiwiZWxlbWVudE1hdGNoZXJzIiwic2V0TWF0Y2hlcnMiLCJieVNldCIsImJ5RWxlbWVudCIsInN1cGVyTWF0Y2hlciIsIm91dGVybW9zdCIsIm1hdGNoZWRDb3VudCIsInNldE1hdGNoZWQiLCJjb250ZXh0QmFja3VwIiwiZGlycnVuc1VuaXF1ZSIsInRva2VuIiwiY29tcGlsZWQiLCJfbmFtZSIsImRlZmF1bHRWYWx1ZSIsInVuaXF1ZSIsImlzWE1MRG9jIiwiZXNjYXBlU2VsZWN0b3IiLCJ1bnRpbCIsInRydW5jYXRlIiwiaXMiLCJzaWJsaW5ncyIsIm4iLCJybmVlZHNDb250ZXh0IiwibmVlZHNDb250ZXh0IiwicnNpbmdsZVRhZyIsIndpbm5vdyIsInF1YWxpZmllciIsIm5vdCIsInNlbGYiLCJyb290alF1ZXJ5Iiwicm9vdCIsInBhcnNlSFRNTCIsInJlYWR5IiwicnBhcmVudHNwcmV2IiwiZ3VhcmFudGVlZFVuaXF1ZSIsImNoaWxkcmVuIiwiY29udGVudHMiLCJwcmV2IiwiaGFzIiwidGFyZ2V0cyIsImwiLCJjbG9zZXN0IiwiaW5kZXgiLCJwcmV2QWxsIiwiYWRkIiwiYWRkQmFjayIsInNpYmxpbmciLCJwYXJlbnRzIiwicGFyZW50c1VudGlsIiwibmV4dEFsbCIsIm5leHRVbnRpbCIsInByZXZVbnRpbCIsImNvbnRlbnREb2N1bWVudCIsImNvbnRlbnQiLCJyZXZlcnNlIiwicm5vdGh0bWx3aGl0ZSIsImNyZWF0ZU9wdGlvbnMiLCJvYmplY3QiLCJfIiwiZmxhZyIsIkNhbGxiYWNrcyIsImZpcmluZyIsIm1lbW9yeSIsImZpcmVkIiwibG9ja2VkIiwicXVldWUiLCJmaXJpbmdJbmRleCIsImZpcmUiLCJvbmNlIiwic3RvcE9uRmFsc2UiLCJyZW1vdmUiLCJlbXB0eSIsImRpc2FibGUiLCJsb2NrIiwiZmlyZVdpdGgiLCJJZGVudGl0eSIsInYiLCJUaHJvd2VyIiwiZXgiLCJhZG9wdFZhbHVlIiwicmVzb2x2ZSIsInJlamVjdCIsIm5vVmFsdWUiLCJtZXRob2QiLCJwcm9taXNlIiwiZmFpbCIsInRoZW4iLCJEZWZlcnJlZCIsImZ1bmMiLCJ0dXBsZXMiLCJzdGF0ZSIsImFsd2F5cyIsImRlZmVycmVkIiwicGlwZSIsImZucyIsIm5ld0RlZmVyIiwidHVwbGUiLCJyZXR1cm5lZCIsInByb2dyZXNzIiwibm90aWZ5Iiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwib25Qcm9ncmVzcyIsIm1heERlcHRoIiwiZGVwdGgiLCJzcGVjaWFsIiwidGhhdCIsIm1pZ2h0VGhyb3ciLCJUeXBlRXJyb3IiLCJub3RpZnlXaXRoIiwicmVzb2x2ZVdpdGgiLCJwcm9jZXNzIiwiZXhjZXB0aW9uSG9vayIsInN0YWNrVHJhY2UiLCJyZWplY3RXaXRoIiwiZ2V0U3RhY2tIb29rIiwic2V0VGltZW91dCIsInN0YXRlU3RyaW5nIiwid2hlbiIsInNpbmdsZVZhbHVlIiwicmVtYWluaW5nIiwicmVzb2x2ZUNvbnRleHRzIiwicmVzb2x2ZVZhbHVlcyIsInByaW1hcnkiLCJ1cGRhdGVGdW5jIiwicmVycm9yTmFtZXMiLCJzdGFjayIsImNvbnNvbGUiLCJ3YXJuIiwibWVzc2FnZSIsInJlYWR5RXhjZXB0aW9uIiwicmVhZHlMaXN0IiwicmVhZHlXYWl0Iiwid2FpdCIsImNvbXBsZXRlZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZWFkeVN0YXRlIiwiZG9TY3JvbGwiLCJhY2Nlc3MiLCJjaGFpbmFibGUiLCJlbXB0eUdldCIsInJhdyIsImJ1bGsiLCJfa2V5Iiwicm1zUHJlZml4IiwicmRhc2hBbHBoYSIsImZjYW1lbENhc2UiLCJfYWxsIiwibGV0dGVyIiwidG9VcHBlckNhc2UiLCJjYW1lbENhc2UiLCJzdHJpbmciLCJhY2NlcHREYXRhIiwib3duZXIiLCJEYXRhIiwidWlkIiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJzZXQiLCJkYXRhIiwicHJvcCIsImhhc0RhdGEiLCJkYXRhUHJpdiIsImRhdGFVc2VyIiwicmJyYWNlIiwicm11bHRpRGFzaCIsImdldERhdGEiLCJKU09OIiwicGFyc2UiLCJkYXRhQXR0ciIsInJlbW92ZURhdGEiLCJfZGF0YSIsIl9yZW1vdmVEYXRhIiwiZGVxdWV1ZSIsInN0YXJ0TGVuZ3RoIiwiaG9va3MiLCJfcXVldWVIb29rcyIsInN0b3AiLCJzZXR0ZXIiLCJjbGVhclF1ZXVlIiwiY291bnQiLCJkZWZlciIsInBudW0iLCJzb3VyY2UiLCJyY3NzTnVtIiwiY3NzRXhwYW5kIiwiaXNBdHRhY2hlZCIsImNvbXBvc2VkIiwiZ2V0Um9vdE5vZGUiLCJpc0hpZGRlbldpdGhpblRyZWUiLCJzdHlsZSIsImRpc3BsYXkiLCJjc3MiLCJhZGp1c3RDU1MiLCJ2YWx1ZVBhcnRzIiwidHdlZW4iLCJhZGp1c3RlZCIsInNjYWxlIiwibWF4SXRlcmF0aW9ucyIsImN1cnJlbnRWYWx1ZSIsImluaXRpYWwiLCJ1bml0IiwiY3NzTnVtYmVyIiwiaW5pdGlhbEluVW5pdCIsImRlZmF1bHREaXNwbGF5TWFwIiwiZ2V0RGVmYXVsdERpc3BsYXkiLCJib2R5Iiwic2hvd0hpZGUiLCJzaG93IiwidmFsdWVzIiwiaGlkZSIsInRvZ2dsZSIsInJjaGVja2FibGVUeXBlIiwicnRhZ05hbWUiLCJyc2NyaXB0VHlwZSIsImZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImRpdiIsImNoZWNrQ2xvbmUiLCJjbG9uZU5vZGUiLCJub0Nsb25lQ2hlY2tlZCIsIm9wdGlvbiIsIndyYXBNYXAiLCJ0aGVhZCIsImNvbCIsInRyIiwidGQiLCJfZGVmYXVsdCIsInRib2R5IiwidGZvb3QiLCJjb2xncm91cCIsImNhcHRpb24iLCJ0aCIsIm9wdGdyb3VwIiwiZ2V0QWxsIiwic2V0R2xvYmFsRXZhbCIsInJlZkVsZW1lbnRzIiwiYnVpbGRGcmFnbWVudCIsInNjcmlwdHMiLCJzZWxlY3Rpb24iLCJpZ25vcmVkIiwid3JhcCIsImF0dGFjaGVkIiwibm9kZXMiLCJjcmVhdGVUZXh0Tm9kZSIsImh0bWxQcmVmaWx0ZXIiLCJydHlwZW5hbWVzcGFjZSIsInJldHVyblRydWUiLCJyZXR1cm5GYWxzZSIsImV4cGVjdFN5bmMiLCJzYWZlQWN0aXZlRWxlbWVudCIsImVyciIsIm9uIiwidHlwZXMiLCJvbmUiLCJvcmlnRm4iLCJldmVudCIsIm9mZiIsImhhbmRsZU9iakluIiwiZXZlbnRIYW5kbGUiLCJldmVudHMiLCJ0IiwiaGFuZGxlT2JqIiwiaGFuZGxlcnMiLCJuYW1lc3BhY2VzIiwib3JpZ1R5cGUiLCJlbGVtRGF0YSIsImNyZWF0ZSIsImhhbmRsZSIsInRyaWdnZXJlZCIsImRpc3BhdGNoIiwiZGVsZWdhdGVUeXBlIiwiYmluZFR5cGUiLCJkZWxlZ2F0ZUNvdW50Iiwic2V0dXAiLCJtYXBwZWRUeXBlcyIsIm9yaWdDb3VudCIsInRlYXJkb3duIiwicmVtb3ZlRXZlbnQiLCJuYXRpdmVFdmVudCIsImhhbmRsZXJRdWV1ZSIsImZpeCIsImRlbGVnYXRlVGFyZ2V0IiwicHJlRGlzcGF0Y2giLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImN1cnJlbnRUYXJnZXQiLCJpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCIsInJuYW1lc3BhY2UiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsInBvc3REaXNwYXRjaCIsIm1hdGNoZWRIYW5kbGVycyIsIm1hdGNoZWRTZWxlY3RvcnMiLCJidXR0b24iLCJhZGRQcm9wIiwiaG9vayIsIkV2ZW50IiwiZW51bWVyYWJsZSIsIm9yaWdpbmFsRXZlbnQiLCJ3cml0YWJsZSIsImxvYWQiLCJub0J1YmJsZSIsImNsaWNrIiwibGV2ZXJhZ2VOYXRpdmUiLCJ0cmlnZ2VyIiwiYmVmb3JldW5sb2FkIiwicmV0dXJuVmFsdWUiLCJub3RBc3luYyIsInNhdmVkIiwiaXNUcmlnZ2VyIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicHJvcHMiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJkZWZhdWx0UHJldmVudGVkIiwicmVsYXRlZFRhcmdldCIsInRpbWVTdGFtcCIsIm5vdyIsImlzU2ltdWxhdGVkIiwiYWx0S2V5IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJjaGFuZ2VkVG91Y2hlcyIsImN0cmxLZXkiLCJkZXRhaWwiLCJldmVudFBoYXNlIiwibWV0YUtleSIsInBhZ2VYIiwicGFnZVkiLCJzaGlmdEtleSIsInZpZXciLCJjaGFyQ29kZSIsImtleUNvZGUiLCJidXR0b25zIiwiY2xpZW50WCIsImNsaWVudFkiLCJvZmZzZXRYIiwib2Zmc2V0WSIsInBvaW50ZXJJZCIsInBvaW50ZXJUeXBlIiwic2NyZWVuWCIsInNjcmVlblkiLCJ0YXJnZXRUb3VjaGVzIiwidG9FbGVtZW50IiwidG91Y2hlcyIsIndoaWNoIiwiZm9jdXMiLCJibHVyIiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJwb2ludGVyZW50ZXIiLCJwb2ludGVybGVhdmUiLCJvcmlnIiwicmVsYXRlZCIsInJub0lubmVyaHRtbCIsInJjaGVja2VkIiwicmNsZWFuU2NyaXB0IiwibWFuaXB1bGF0aW9uVGFyZ2V0IiwiZGlzYWJsZVNjcmlwdCIsInJlc3RvcmVTY3JpcHQiLCJjbG9uZUNvcHlFdmVudCIsImRlc3QiLCJwZGF0YU9sZCIsInVkYXRhT2xkIiwidWRhdGFDdXIiLCJmaXhJbnB1dCIsImRvbU1hbmlwIiwiY29sbGVjdGlvbiIsImhhc1NjcmlwdHMiLCJpTm9DbG9uZSIsInZhbHVlSXNGdW5jdGlvbiIsImh0bWwiLCJfZXZhbFVybCIsImtlZXBEYXRhIiwiY2xlYW5EYXRhIiwiZGF0YUFuZEV2ZW50cyIsImRlZXBEYXRhQW5kRXZlbnRzIiwic3JjRWxlbWVudHMiLCJkZXN0RWxlbWVudHMiLCJpblBhZ2UiLCJkZXRhY2giLCJhcHBlbmQiLCJwcmVwZW5kIiwiaW5zZXJ0QmVmb3JlIiwiYmVmb3JlIiwiYWZ0ZXIiLCJyZXBsYWNlV2l0aCIsInJlcGxhY2VDaGlsZCIsImFwcGVuZFRvIiwicHJlcGVuZFRvIiwiaW5zZXJ0QWZ0ZXIiLCJyZXBsYWNlQWxsIiwib3JpZ2luYWwiLCJpbnNlcnQiLCJybnVtbm9ucHgiLCJnZXRTdHlsZXMiLCJvcGVuZXIiLCJnZXRDb21wdXRlZFN0eWxlIiwic3dhcCIsIm9sZCIsInJib3hTdHlsZSIsImNvbXB1dGVTdHlsZVRlc3RzIiwiY29udGFpbmVyIiwiY3NzVGV4dCIsImRpdlN0eWxlIiwicGl4ZWxQb3NpdGlvblZhbCIsInJlbGlhYmxlTWFyZ2luTGVmdFZhbCIsInJvdW5kUGl4ZWxNZWFzdXJlcyIsIm1hcmdpbkxlZnQiLCJyaWdodCIsInBpeGVsQm94U3R5bGVzVmFsIiwiYm94U2l6aW5nUmVsaWFibGVWYWwiLCJ3aWR0aCIsInBvc2l0aW9uIiwic2Nyb2xsYm94U2l6ZVZhbCIsIm9mZnNldFdpZHRoIiwibWVhc3VyZSIsInJvdW5kIiwicGFyc2VGbG9hdCIsInJlbGlhYmxlVHJEaW1lbnNpb25zVmFsIiwiYmFja2dyb3VuZENsaXAiLCJjbGVhckNsb25lU3R5bGUiLCJib3hTaXppbmdSZWxpYWJsZSIsInBpeGVsQm94U3R5bGVzIiwicGl4ZWxQb3NpdGlvbiIsInJlbGlhYmxlTWFyZ2luTGVmdCIsInNjcm9sbGJveFNpemUiLCJyZWxpYWJsZVRyRGltZW5zaW9ucyIsInRhYmxlIiwidHJDaGlsZCIsInRyU3R5bGUiLCJoZWlnaHQiLCJwYXJzZUludCIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJjdXJDU1MiLCJjb21wdXRlZCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiYWRkR2V0SG9va0lmIiwiY29uZGl0aW9uRm4iLCJob29rRm4iLCJjc3NQcmVmaXhlcyIsImVtcHR5U3R5bGUiLCJ2ZW5kb3JQcm9wcyIsInZlbmRvclByb3BOYW1lIiwiY2FwTmFtZSIsImZpbmFsUHJvcE5hbWUiLCJmaW5hbCIsImNzc1Byb3BzIiwicmRpc3BsYXlzd2FwIiwicmN1c3RvbVByb3AiLCJjc3NTaG93IiwidmlzaWJpbGl0eSIsImNzc05vcm1hbFRyYW5zZm9ybSIsImxldHRlclNwYWNpbmciLCJmb250V2VpZ2h0Iiwic2V0UG9zaXRpdmVOdW1iZXIiLCJzdWJ0cmFjdCIsIm1heCIsImJveE1vZGVsQWRqdXN0bWVudCIsImRpbWVuc2lvbiIsImJveCIsImlzQm9yZGVyQm94Iiwic3R5bGVzIiwiY29tcHV0ZWRWYWwiLCJleHRyYSIsImRlbHRhIiwiY2VpbCIsImdldFdpZHRoT3JIZWlnaHQiLCJib3hTaXppbmdOZWVkZWQiLCJ2YWx1ZUlzQm9yZGVyQm94Iiwib2Zmc2V0UHJvcCIsImdldENsaWVudFJlY3RzIiwiY3NzSG9va3MiLCJvcGFjaXR5Iiwib3JpZ05hbWUiLCJpc0N1c3RvbVByb3AiLCJzZXRQcm9wZXJ0eSIsImlzRmluaXRlIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2Nyb2xsYm94U2l6ZUJ1Z2d5IiwibGVmdCIsIm1hcmdpbiIsInBhZGRpbmciLCJib3JkZXIiLCJwcmVmaXgiLCJzdWZmaXgiLCJleHBhbmQiLCJleHBhbmRlZCIsInBhcnRzIiwiVHdlZW4iLCJlYXNpbmciLCJwcm9wSG9va3MiLCJydW4iLCJwZXJjZW50IiwiZWFzZWQiLCJkdXJhdGlvbiIsInBvcyIsInN0ZXAiLCJmeCIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJsaW5lYXIiLCJwIiwic3dpbmciLCJjb3MiLCJQSSIsImZ4Tm93IiwiaW5Qcm9ncmVzcyIsInJmeHR5cGVzIiwicnJ1biIsInNjaGVkdWxlIiwiaGlkZGVuIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaW50ZXJ2YWwiLCJ0aWNrIiwiY3JlYXRlRnhOb3ciLCJnZW5GeCIsImluY2x1ZGVXaWR0aCIsImNyZWF0ZVR3ZWVuIiwiYW5pbWF0aW9uIiwiQW5pbWF0aW9uIiwidHdlZW5lcnMiLCJkZWZhdWx0UHJlZmlsdGVyIiwib3B0cyIsIm9sZGZpcmUiLCJwcm9wVHdlZW4iLCJyZXN0b3JlRGlzcGxheSIsImlzQm94IiwiYW5pbSIsImRhdGFTaG93IiwidW5xdWV1ZWQiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsInByb3BGaWx0ZXIiLCJzcGVjaWFsRWFzaW5nIiwicHJvcGVydGllcyIsInN0b3BwZWQiLCJwcmVmaWx0ZXJzIiwiY3VycmVudFRpbWUiLCJzdGFydFRpbWUiLCJ0d2VlbnMiLCJvcmlnaW5hbFByb3BlcnRpZXMiLCJvcmlnaW5hbE9wdGlvbnMiLCJnb3RvRW5kIiwiYmluZCIsImNvbXBsZXRlIiwidGltZXIiLCJ0d2VlbmVyIiwicHJlZmlsdGVyIiwic3BlZWQiLCJvcHQiLCJzcGVlZHMiLCJmYWRlVG8iLCJ0byIsImFuaW1hdGUiLCJvcHRhbGwiLCJkb0FuaW1hdGlvbiIsImZpbmlzaCIsInN0b3BRdWV1ZSIsInRpbWVycyIsImNzc0ZuIiwic2xpZGVEb3duIiwic2xpZGVVcCIsInNsaWRlVG9nZ2xlIiwiZmFkZUluIiwiZmFkZU91dCIsImZhZGVUb2dnbGUiLCJzbG93IiwiZmFzdCIsImRlbGF5IiwidGltZSIsInRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJjaGVja09uIiwib3B0U2VsZWN0ZWQiLCJyYWRpb1ZhbHVlIiwiYm9vbEhvb2siLCJyZW1vdmVBdHRyIiwiblR5cGUiLCJhdHRySG9va3MiLCJib29sIiwiYXR0ck5hbWVzIiwiZ2V0dGVyIiwibG93ZXJjYXNlTmFtZSIsInJmb2N1c2FibGUiLCJyY2xpY2thYmxlIiwicmVtb3ZlUHJvcCIsInByb3BGaXgiLCJ0YWJpbmRleCIsInN0cmlwQW5kQ29sbGFwc2UiLCJnZXRDbGFzcyIsImNsYXNzZXNUb0FycmF5IiwiYWRkQ2xhc3MiLCJjbGFzc2VzIiwiY3VyVmFsdWUiLCJjbGF6eiIsImZpbmFsVmFsdWUiLCJyZW1vdmVDbGFzcyIsInRvZ2dsZUNsYXNzIiwic3RhdGVWYWwiLCJpc1ZhbGlkVmFsdWUiLCJjbGFzc05hbWVzIiwiaGFzQ2xhc3MiLCJycmV0dXJuIiwidmFsSG9va3MiLCJvcHRpb25TZXQiLCJmb2N1c2luIiwicmZvY3VzTW9ycGgiLCJzdG9wUHJvcGFnYXRpb25DYWxsYmFjayIsIm9ubHlIYW5kbGVycyIsImJ1YmJsZVR5cGUiLCJvbnR5cGUiLCJsYXN0RWxlbWVudCIsImV2ZW50UGF0aCIsInBhcmVudFdpbmRvdyIsInNpbXVsYXRlIiwidHJpZ2dlckhhbmRsZXIiLCJhdHRhY2hlcyIsInJxdWVyeSIsInBhcnNlWE1MIiwicGFyc2VyRXJyb3JFbGVtIiwiRE9NUGFyc2VyIiwicGFyc2VGcm9tU3RyaW5nIiwicmJyYWNrZXQiLCJyQ1JMRiIsInJzdWJtaXR0ZXJUeXBlcyIsInJzdWJtaXR0YWJsZSIsImJ1aWxkUGFyYW1zIiwidHJhZGl0aW9uYWwiLCJwYXJhbSIsInMiLCJ2YWx1ZU9yRnVuY3Rpb24iLCJlbmNvZGVVUklDb21wb25lbnQiLCJzZXJpYWxpemUiLCJzZXJpYWxpemVBcnJheSIsInIyMCIsInJoYXNoIiwicmFudGlDYWNoZSIsInJoZWFkZXJzIiwicmxvY2FsUHJvdG9jb2wiLCJybm9Db250ZW50IiwicnByb3RvY29sIiwidHJhbnNwb3J0cyIsImFsbFR5cGVzIiwib3JpZ2luQW5jaG9yIiwiYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzIiwic3RydWN0dXJlIiwiZGF0YVR5cGVFeHByZXNzaW9uIiwiZGF0YVR5cGUiLCJkYXRhVHlwZXMiLCJpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyIsImpxWEhSIiwiaW5zcGVjdGVkIiwic2Vla2luZ1RyYW5zcG9ydCIsImluc3BlY3QiLCJwcmVmaWx0ZXJPckZhY3RvcnkiLCJkYXRhVHlwZU9yVHJhbnNwb3J0IiwiYWpheEV4dGVuZCIsImZsYXRPcHRpb25zIiwiYWpheFNldHRpbmdzIiwiYWpheEhhbmRsZVJlc3BvbnNlcyIsInJlc3BvbnNlcyIsImN0IiwiZmluYWxEYXRhVHlwZSIsImZpcnN0RGF0YVR5cGUiLCJtaW1lVHlwZSIsImdldFJlc3BvbnNlSGVhZGVyIiwiY29udmVydGVycyIsImFqYXhDb252ZXJ0IiwicmVzcG9uc2UiLCJpc1N1Y2Nlc3MiLCJjb252MiIsImN1cnJlbnQiLCJjb252IiwicmVzcG9uc2VGaWVsZHMiLCJkYXRhRmlsdGVyIiwiYWN0aXZlIiwibGFzdE1vZGlmaWVkIiwiZXRhZyIsInVybCIsImlzTG9jYWwiLCJwcm90b2NvbCIsInByb2Nlc3NEYXRhIiwiYXN5bmMiLCJjb250ZW50VHlwZSIsImFjY2VwdHMiLCJqc29uIiwiYWpheFNldHVwIiwic2V0dGluZ3MiLCJhamF4UHJlZmlsdGVyIiwiYWpheFRyYW5zcG9ydCIsImFqYXgiLCJ0cmFuc3BvcnQiLCJjYWNoZVVSTCIsInJlc3BvbnNlSGVhZGVyc1N0cmluZyIsInJlc3BvbnNlSGVhZGVycyIsInRpbWVvdXRUaW1lciIsInVybEFuY2hvciIsImZpcmVHbG9iYWxzIiwidW5jYWNoZWQiLCJjYWxsYmFja0NvbnRleHQiLCJnbG9iYWxFdmVudENvbnRleHQiLCJjb21wbGV0ZURlZmVycmVkIiwic3RhdHVzQ29kZSIsInJlcXVlc3RIZWFkZXJzIiwicmVxdWVzdEhlYWRlcnNOYW1lcyIsInN0ckFib3J0IiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwic2V0UmVxdWVzdEhlYWRlciIsIm92ZXJyaWRlTWltZVR5cGUiLCJzdGF0dXMiLCJhYm9ydCIsInN0YXR1c1RleHQiLCJmaW5hbFRleHQiLCJjcm9zc0RvbWFpbiIsImhvc3QiLCJoYXNDb250ZW50IiwiaWZNb2RpZmllZCIsImhlYWRlcnMiLCJiZWZvcmVTZW5kIiwic3VjY2VzcyIsInNlbmQiLCJuYXRpdmVTdGF0dXNUZXh0IiwibW9kaWZpZWQiLCJnZXRKU09OIiwiZ2V0U2NyaXB0Iiwid3JhcEFsbCIsImZpcnN0RWxlbWVudENoaWxkIiwid3JhcElubmVyIiwiaHRtbElzRnVuY3Rpb24iLCJ1bndyYXAiLCJ2aXNpYmxlIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJ4aHJTdWNjZXNzU3RhdHVzIiwieGhyU3VwcG9ydGVkIiwiY29ycyIsImVycm9yQ2FsbGJhY2siLCJvcGVuIiwidXNlcm5hbWUiLCJ4aHJGaWVsZHMiLCJvbmxvYWQiLCJvbmVycm9yIiwib25hYm9ydCIsIm9udGltZW91dCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlc3BvbnNlVHlwZSIsInJlc3BvbnNlVGV4dCIsImJpbmFyeSIsInNjcmlwdEF0dHJzIiwiY2hhcnNldCIsInNjcmlwdENoYXJzZXQiLCJldnQiLCJvbGRDYWxsYmFja3MiLCJyanNvbnAiLCJqc29ucCIsImpzb25wQ2FsbGJhY2siLCJvcmlnaW5hbFNldHRpbmdzIiwiY2FsbGJhY2tOYW1lIiwib3ZlcndyaXR0ZW4iLCJyZXNwb25zZUNvbnRhaW5lciIsImpzb25Qcm9wIiwiY3JlYXRlSFRNTERvY3VtZW50IiwiaW1wbGVtZW50YXRpb24iLCJrZWVwU2NyaXB0cyIsInBhcnNlZCIsInBhcmFtcyIsImFuaW1hdGVkIiwib2Zmc2V0Iiwic2V0T2Zmc2V0IiwiY3VyUG9zaXRpb24iLCJjdXJMZWZ0IiwiY3VyQ1NTVG9wIiwiY3VyVG9wIiwiY3VyT2Zmc2V0IiwiY3VyQ1NTTGVmdCIsImNhbGN1bGF0ZVBvc2l0aW9uIiwiY3VyRWxlbSIsInVzaW5nIiwicmVjdCIsIndpbiIsInBhZ2VZT2Zmc2V0IiwicGFnZVhPZmZzZXQiLCJvZmZzZXRQYXJlbnQiLCJwYXJlbnRPZmZzZXQiLCJzY3JvbGxUbyIsIkhlaWdodCIsIldpZHRoIiwiZGVmYXVsdEV4dHJhIiwiZnVuY05hbWUiLCJ1bmJpbmQiLCJkZWxlZ2F0ZSIsInVuZGVsZWdhdGUiLCJob3ZlciIsImZuT3ZlciIsImZuT3V0IiwicHJveHkiLCJob2xkUmVhZHkiLCJob2xkIiwicGFyc2VKU09OIiwiaXNOdW1lcmljIiwiaXNOYU4iLCJ0cmltIiwiZGVmaW5lIiwiYW1kIiwiX2pRdWVyeSIsIl8kIiwiJCIsIm5vQ29uZmxpY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/jquery.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/js/jquery.js");
/******/ 	
/******/ })()
;